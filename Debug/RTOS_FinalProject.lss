
RTOS_FinalProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004852  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000c2  00800060  00004852  000048e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000651  00800122  00800122  000049a8  2**0
                  ALLOC
  3 .stab         0000a464  00000000  00000000  000049a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00006b94  00000000  00000000  0000ee0c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 b7 01 	jmp	0x36e	; 0x36e <__vector_1>
       8:	0c 94 de 01 	jmp	0x3bc	; 0x3bc <__vector_2>
       c:	0c 94 05 02 	jmp	0x40a	; 0x40a <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 54 0c 	jmp	0x18a8	; 0x18a8 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 19 01 	jmp	0x232	; 0x232 <__vector_10>
      2c:	0c 94 f2 00 	jmp	0x1e4	; 0x1e4 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e5       	ldi	r30, 0x52	; 82
      68:	f8 e4       	ldi	r31, 0x48	; 72
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 32       	cpi	r26, 0x22	; 34
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a2 e2       	ldi	r26, 0x22	; 34
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 37       	cpi	r26, 0x73	; 115
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 43 23 	call	0x4686	; 0x4686 <main>
      8a:	0c 94 27 24 	jmp	0x484e	; 0x484e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <TWI_InitM>:
      92:	81 b1       	in	r24, 0x01	; 1
      94:	8c 7f       	andi	r24, 0xFC	; 252
      96:	81 b9       	out	0x01, r24	; 1
      98:	88 e4       	ldi	r24, 0x48	; 72
      9a:	80 b9       	out	0x00, r24	; 0
      9c:	08 95       	ret

0000009e <TWI_StartM>:
	TWBR = 72; /***100000 Bit rate ##1.0KHz##***/
}

void TWI_StartM(void)
{
	TWCR = (1 <<TWINT) | (1 <<TWSTA) | (1 <<TWEN);
      9e:	84 ea       	ldi	r24, 0xA4	; 164
      a0:	86 bf       	out	0x36, r24	; 54
	while (!(TWCR & (1 << TWINT)));
      a2:	06 b6       	in	r0, 0x36	; 54
      a4:	07 fe       	sbrs	r0, 7
      a6:	fd cf       	rjmp	.-6      	; 0xa2 <TWI_StartM+0x4>
	while((TWSR & 0xF8)!= TW_START);
      a8:	81 b1       	in	r24, 0x01	; 1
      aa:	88 7f       	andi	r24, 0xF8	; 248
      ac:	88 30       	cpi	r24, 0x08	; 8
      ae:	e1 f7       	brne	.-8      	; 0xa8 <TWI_StartM+0xa>
}
      b0:	08 95       	ret

000000b2 <TWI_REPStartM>:

void TWI_REPStartM(void)
{
	TWCR = (1 <<TWINT) | (1 <<TWSTA) | (1 <<TWEN);
      b2:	84 ea       	ldi	r24, 0xA4	; 164
      b4:	86 bf       	out	0x36, r24	; 54
	while (!(TWCR & (1 << TWINT)));
      b6:	06 b6       	in	r0, 0x36	; 54
      b8:	07 fe       	sbrs	r0, 7
      ba:	fd cf       	rjmp	.-6      	; 0xb6 <TWI_REPStartM+0x4>
	while((TWSR & 0xF8)!= TW_REP_START);
      bc:	81 b1       	in	r24, 0x01	; 1
      be:	88 7f       	andi	r24, 0xF8	; 248
      c0:	80 31       	cpi	r24, 0x10	; 16
      c2:	e1 f7       	brne	.-8      	; 0xbc <TWI_REPStartM+0xa>
}
      c4:	08 95       	ret

000000c6 <TMI_WriteA>:

void TMI_WriteA(uint8_t Address ,uint8_t typeTWI)
{
	TWDR = Address;
      c6:	83 b9       	out	0x03, r24	; 3
	TWCR = (1 <<TWINT) | (1 <<TWEN);
      c8:	84 e8       	ldi	r24, 0x84	; 132
      ca:	86 bf       	out	0x36, r24	; 54
	while ((TWCR & (1 <<TWINT)) == 0);
      cc:	06 b6       	in	r0, 0x36	; 54
      ce:	07 fe       	sbrs	r0, 7
      d0:	fd cf       	rjmp	.-6      	; 0xcc <TMI_WriteA+0x6>
	while( (TWSR & 0xF8) != typeTWI);
      d2:	70 e0       	ldi	r23, 0x00	; 0
      d4:	81 b1       	in	r24, 0x01	; 1
      d6:	90 e0       	ldi	r25, 0x00	; 0
      d8:	88 7f       	andi	r24, 0xF8	; 248
      da:	90 70       	andi	r25, 0x00	; 0
      dc:	86 17       	cp	r24, r22
      de:	97 07       	cpc	r25, r23
      e0:	c9 f7       	brne	.-14     	; 0xd4 <TMI_WriteA+0xe>
}
      e2:	08 95       	ret

000000e4 <TMI_WriteD>:

void TMI_WriteD(uint8_t Data ,uint8_t type)
{
	TWDR = Data;
      e4:	83 b9       	out	0x03, r24	; 3
	TWCR = (1 <<TWINT) | (1 <<TWEN);
      e6:	84 e8       	ldi	r24, 0x84	; 132
      e8:	86 bf       	out	0x36, r24	; 54
	while (!(TWCR & (1 << TWINT)));
      ea:	06 b6       	in	r0, 0x36	; 54
      ec:	07 fe       	sbrs	r0, 7
      ee:	fd cf       	rjmp	.-6      	; 0xea <TMI_WriteD+0x6>
	while( (TWSR & 0xF8) != type);
      f0:	70 e0       	ldi	r23, 0x00	; 0
      f2:	81 b1       	in	r24, 0x01	; 1
      f4:	90 e0       	ldi	r25, 0x00	; 0
      f6:	88 7f       	andi	r24, 0xF8	; 248
      f8:	90 70       	andi	r25, 0x00	; 0
      fa:	86 17       	cp	r24, r22
      fc:	97 07       	cpc	r25, r23
      fe:	c9 f7       	brne	.-14     	; 0xf2 <TMI_WriteD+0xe>
}
     100:	08 95       	ret

00000102 <TWI_stop>:

void TWI_stop(void)
{
	TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
     102:	84 e9       	ldi	r24, 0x94	; 148
     104:	86 bf       	out	0x36, r24	; 54
}
     106:	08 95       	ret

00000108 <TWI_Init_S>:
void TWI_Init_S(uint8_t Addr)
{
	TWAR = Addr;
     108:	82 b9       	out	0x02, r24	; 2
}
     10a:	08 95       	ret

0000010c <TWI_Receive>:

uint8_t TWI_Receive(void)
{
	TWCR = (1<<TWINT)|(1<<TWEA)|(1<<TWEN);
     10c:	84 ec       	ldi	r24, 0xC4	; 196
     10e:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & (1<<TWINT)));
     110:	06 b6       	in	r0, 0x36	; 54
     112:	07 fe       	sbrs	r0, 7
     114:	fd cf       	rjmp	.-6      	; 0x110 <TWI_Receive+0x4>
	while((TWSR & 0xf8) != TW_MR_DATA_ACK);
     116:	81 b1       	in	r24, 0x01	; 1
     118:	88 7f       	andi	r24, 0xF8	; 248
     11a:	80 35       	cpi	r24, 0x50	; 80
     11c:	e1 f7       	brne	.-8      	; 0x116 <TWI_Receive+0xa>
	return TWDR;
     11e:	83 b1       	in	r24, 0x03	; 3
}
     120:	08 95       	ret

00000122 <TWI_ACK>:

void TWI_ACK(void)
{
	while ((TWSR & 0xf8) != 0x60)
	{
		TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
     122:	94 ec       	ldi	r25, 0xC4	; 196
     124:	04 c0       	rjmp	.+8      	; 0x12e <TWI_ACK+0xc>
     126:	96 bf       	out	0x36, r25	; 54
		while(!(TWCR & (1<<TWINT)));
     128:	06 b6       	in	r0, 0x36	; 54
     12a:	07 fe       	sbrs	r0, 7
     12c:	fd cf       	rjmp	.-6      	; 0x128 <TWI_ACK+0x6>
	return TWDR;
}

void TWI_ACK(void)
{
	while ((TWSR & 0xf8) != 0x60)
     12e:	81 b1       	in	r24, 0x01	; 1
     130:	88 7f       	andi	r24, 0xF8	; 248
     132:	80 36       	cpi	r24, 0x60	; 96
     134:	c1 f7       	brne	.-16     	; 0x126 <TWI_ACK+0x4>
	{
		TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
		while(!(TWCR & (1<<TWINT)));
	}
}
     136:	08 95       	ret

00000138 <TWI_Read>:

uint8_t TWI_Read(uint8_t NACK0)
{
	if (NACK0){
     138:	88 23       	and	r24, r24
     13a:	59 f0       	breq	.+22     	; 0x152 <TWI_Read+0x1a>
		TWCR = (1 <<TWINT) | (1 <<TWEN);
     13c:	84 e8       	ldi	r24, 0x84	; 132
     13e:	86 bf       	out	0x36, r24	; 54
		while ((TWCR & (1 <<TWINT)) == 0);
     140:	06 b6       	in	r0, 0x36	; 54
     142:	07 fe       	sbrs	r0, 7
     144:	fd cf       	rjmp	.-6      	; 0x140 <TWI_Read+0x8>
		while((TWSR & 0xF8) != TW_MR_DATA_NACK);
     146:	81 b1       	in	r24, 0x01	; 1
     148:	88 7f       	andi	r24, 0xF8	; 248
     14a:	88 35       	cpi	r24, 0x58	; 88
     14c:	e1 f7       	brne	.-8      	; 0x146 <TWI_Read+0xe>
		return TWDR;
     14e:	83 b1       	in	r24, 0x03	; 3
     150:	08 95       	ret
	}
	else{
		TWCR = (1 <<TWINT) | (1 <<TWEN) | (1 <<TWEA);
     152:	84 ec       	ldi	r24, 0xC4	; 196
     154:	86 bf       	out	0x36, r24	; 54
		while ((TWCR & (1 <<TWINT)) == 0);
     156:	06 b6       	in	r0, 0x36	; 54
     158:	07 fe       	sbrs	r0, 7
     15a:	fd cf       	rjmp	.-6      	; 0x156 <TWI_Read+0x1e>
		while((TWSR & 0xF8) != TW_MR_DATA_ACK);
     15c:	81 b1       	in	r24, 0x01	; 1
     15e:	88 7f       	andi	r24, 0xF8	; 248
     160:	80 35       	cpi	r24, 0x50	; 80
     162:	e1 f7       	brne	.-8      	; 0x15c <TWI_Read+0x24>
		return TWDR;
     164:	83 b1       	in	r24, 0x03	; 3
	}
}
     166:	08 95       	ret

00000168 <MTIMER0_void_Init>:
void (*pv_ptrCTCCALLBackptr)(void) = NULL;
void MTIMER0_void_Init(void)// prescaler , mode, OC0 mode
{
	/*step 1 : choose Timer mode*/
#if(MTIMER0_MODE  == MTIMER0_MODE_NORMAL)
	CLR_BIT(MTIMER0_TCCR0_Register ,WGM00);
     168:	83 b7       	in	r24, 0x33	; 51
     16a:	8f 7b       	andi	r24, 0xBF	; 191
     16c:	83 bf       	out	0x33, r24	; 51
	CLR_BIT(MTIMER0_TCCR0_Register ,WGM01);
     16e:	83 b7       	in	r24, 0x33	; 51
     170:	87 7f       	andi	r24, 0xF7	; 247
     172:	83 bf       	out	0x33, r24	; 51
#elif(MTIMER0_MODE  ==MTIMER0_MODE_PHASE_CORRECT)
	SET_BIT(MTIMER0_TCCR0_Register ,WGM00);
	CLR_BIT(MTIMER0_TCCR0_Register ,WGM01);
#endif
	/*step 2: choose prescaler*/
	MTIMER0_TCCR0_Register &= MTIMER0_PRESCALER_MASK;
     174:	83 b7       	in	r24, 0x33	; 51
     176:	88 7f       	andi	r24, 0xF8	; 248
     178:	83 bf       	out	0x33, r24	; 51
	MTIMER0_TCCR0_Register |= MTIMER0_PRESCALER;
     17a:	83 b7       	in	r24, 0x33	; 51
     17c:	81 60       	ori	r24, 0x01	; 1
     17e:	83 bf       	out	0x33, r24	; 51
	/*step 3: choose OC0 mode*/
	MTIMER0_TCCR0_Register &= MTIMER0_OC0MODE_MASK ;
     180:	83 b7       	in	r24, 0x33	; 51
     182:	8f 7c       	andi	r24, 0xCF	; 207
     184:	83 bf       	out	0x33, r24	; 51
	MTIMER0_TCCR0_Register |= MTIMER0_OC0_MODE << 4;
     186:	83 b7       	in	r24, 0x33	; 51
     188:	83 bf       	out	0x33, r24	; 51
}
     18a:	08 95       	ret

0000018c <MTIMER0_void_TimerStart>:
void MTIMER0_void_TimerStart() // CLK or prescaller
{
	MTIMER0_TCCR0_Register &= MTIMER0_PRESCALER_MASK;
     18c:	83 b7       	in	r24, 0x33	; 51
     18e:	88 7f       	andi	r24, 0xF8	; 248
     190:	83 bf       	out	0x33, r24	; 51
	MTIMER0_TCCR0_Register |= MTIMER0_PRESCALER ;
     192:	83 b7       	in	r24, 0x33	; 51
     194:	81 60       	ori	r24, 0x01	; 1
     196:	83 bf       	out	0x33, r24	; 51
}
     198:	08 95       	ret

0000019a <MTIMER0_void_TimerStop>:
void MTIMER0_void_TimerStop()// NO clk
{
	MTIMER0_TCCR0_Register &= MTIMER0_PRESCALER_MASK;
     19a:	83 b7       	in	r24, 0x33	; 51
     19c:	88 7f       	andi	r24, 0xF8	; 248
     19e:	83 bf       	out	0x33, r24	; 51
	MTIMER0_TCCR0_Register |= MTIMER0_PRESCALER_NO_CLOCK ;
     1a0:	83 b7       	in	r24, 0x33	; 51
     1a2:	83 bf       	out	0x33, r24	; 51

}
     1a4:	08 95       	ret

000001a6 <MTIMER0_void_EnableOVFInt>:

void MTIMER0_void_EnableOVFInt()
{
	 SET_BIT(MTIMER0_TIMSK_Register,TOIE0);
     1a6:	89 b7       	in	r24, 0x39	; 57
     1a8:	81 60       	ori	r24, 0x01	; 1
     1aa:	89 bf       	out	0x39, r24	; 57
}
     1ac:	08 95       	ret

000001ae <MTIMER0_void_DisableOVFInt>:
void MTIMER0_void_DisableOVFInt()
{
	 CLR_BIT(MTIMER0_TIMSK_Register,TOIE0);
     1ae:	89 b7       	in	r24, 0x39	; 57
     1b0:	8e 7f       	andi	r24, 0xFE	; 254
     1b2:	89 bf       	out	0x39, r24	; 57
}
     1b4:	08 95       	ret

000001b6 <MTIMER0_void_OVFsetCallBack>:
void MTIMER0_void_OVFsetCallBack(void (*copy_ptrfun)(void))
{
	pv_ptrOVFCALLBackptr = copy_ptrfun;
     1b6:	90 93 23 01 	sts	0x0123, r25
     1ba:	80 93 22 01 	sts	0x0122, r24
}
     1be:	08 95       	ret

000001c0 <MTIMER0_void_setPreload>:
void MTIMER0_void_setPreload(u8 copy_u8Preload)
{
	MTIMER0_TCNT0_Register =  copy_u8Preload;
     1c0:	82 bf       	out	0x32, r24	; 50
}
     1c2:	08 95       	ret

000001c4 <MTIMER0_void_EnableCTCInt>:

void MTIMER0_void_EnableCTCInt()
{
	 SET_BIT(MTIMER0_TIMSK_Register,OCIE0);
     1c4:	89 b7       	in	r24, 0x39	; 57
     1c6:	82 60       	ori	r24, 0x02	; 2
     1c8:	89 bf       	out	0x39, r24	; 57
}
     1ca:	08 95       	ret

000001cc <MTIMER0_void_DisableCTCInt>:
void MTIMER0_void_DisableCTCInt()
{
	 CLR_BIT(MTIMER0_TIMSK_Register,OCIE0);
     1cc:	89 b7       	in	r24, 0x39	; 57
     1ce:	8d 7f       	andi	r24, 0xFD	; 253
     1d0:	89 bf       	out	0x39, r24	; 57
}
     1d2:	08 95       	ret

000001d4 <MTIMER0_void_CTCsetCallBack>:
void MTIMER0_void_CTCsetCallBack(void (*copy_ptrfun)(void))
{
	pv_ptrCTCCALLBackptr = copy_ptrfun;
     1d4:	90 93 25 01 	sts	0x0125, r25
     1d8:	80 93 24 01 	sts	0x0124, r24
}
     1dc:	08 95       	ret

000001de <MTIMER0_void_setCompareValue>:
void MTIMER0_void_setCompareValue(u8 copy_u8CompareValue)
{
	MTIMER0_OCR0_Register = copy_u8CompareValue;
     1de:	8c bf       	out	0x3c, r24	; 60
}
     1e0:	08 95       	ret

000001e2 <MTIMER0_void_setFastPWM>:
#if(MTIMER0_OC0_MODE == MTIMER0_OC0_FASTPWM_NONINVERTING)
	MTIMER0_OCR0_Register = (copy_dutyCycle *256)/100;
#elif(MTIMER0_OC0_MODE == MTIMER0_OC0_FASTPWM_INVERTING)
	MTIMER0_OCR0_Register = 255 - (copy_dutyCycle *256)/100;
#endif
}
     1e2:	08 95       	ret

000001e4 <__vector_11>:



ISR(TIMER0_OVF_vect)
{
     1e4:	1f 92       	push	r1
     1e6:	0f 92       	push	r0
     1e8:	0f b6       	in	r0, 0x3f	; 63
     1ea:	0f 92       	push	r0
     1ec:	11 24       	eor	r1, r1
     1ee:	2f 93       	push	r18
     1f0:	3f 93       	push	r19
     1f2:	4f 93       	push	r20
     1f4:	5f 93       	push	r21
     1f6:	6f 93       	push	r22
     1f8:	7f 93       	push	r23
     1fa:	8f 93       	push	r24
     1fc:	9f 93       	push	r25
     1fe:	af 93       	push	r26
     200:	bf 93       	push	r27
     202:	ef 93       	push	r30
     204:	ff 93       	push	r31
	pv_ptrOVFCALLBackptr();
     206:	e0 91 22 01 	lds	r30, 0x0122
     20a:	f0 91 23 01 	lds	r31, 0x0123
     20e:	09 95       	icall
}
     210:	ff 91       	pop	r31
     212:	ef 91       	pop	r30
     214:	bf 91       	pop	r27
     216:	af 91       	pop	r26
     218:	9f 91       	pop	r25
     21a:	8f 91       	pop	r24
     21c:	7f 91       	pop	r23
     21e:	6f 91       	pop	r22
     220:	5f 91       	pop	r21
     222:	4f 91       	pop	r20
     224:	3f 91       	pop	r19
     226:	2f 91       	pop	r18
     228:	0f 90       	pop	r0
     22a:	0f be       	out	0x3f, r0	; 63
     22c:	0f 90       	pop	r0
     22e:	1f 90       	pop	r1
     230:	18 95       	reti

00000232 <__vector_10>:
ISR(TIMER0_COMP_vect)
{
     232:	1f 92       	push	r1
     234:	0f 92       	push	r0
     236:	0f b6       	in	r0, 0x3f	; 63
     238:	0f 92       	push	r0
     23a:	11 24       	eor	r1, r1
     23c:	2f 93       	push	r18
     23e:	3f 93       	push	r19
     240:	4f 93       	push	r20
     242:	5f 93       	push	r21
     244:	6f 93       	push	r22
     246:	7f 93       	push	r23
     248:	8f 93       	push	r24
     24a:	9f 93       	push	r25
     24c:	af 93       	push	r26
     24e:	bf 93       	push	r27
     250:	ef 93       	push	r30
     252:	ff 93       	push	r31
	pv_ptrCTCCALLBackptr();
     254:	e0 91 24 01 	lds	r30, 0x0124
     258:	f0 91 25 01 	lds	r31, 0x0125
     25c:	09 95       	icall
}
     25e:	ff 91       	pop	r31
     260:	ef 91       	pop	r30
     262:	bf 91       	pop	r27
     264:	af 91       	pop	r26
     266:	9f 91       	pop	r25
     268:	8f 91       	pop	r24
     26a:	7f 91       	pop	r23
     26c:	6f 91       	pop	r22
     26e:	5f 91       	pop	r21
     270:	4f 91       	pop	r20
     272:	3f 91       	pop	r19
     274:	2f 91       	pop	r18
     276:	0f 90       	pop	r0
     278:	0f be       	out	0x3f, r0	; 63
     27a:	0f 90       	pop	r0
     27c:	1f 90       	pop	r1
     27e:	18 95       	reti

00000280 <MEXTI_voidEnable_Int>:

void (*global_ptrf_INT0)(void);
void (*global_ptrf_INT1)(void);
void (*global_ptrf_INT2)(void);

void MEXTI_voidEnable_Int(u8 copy_u8IntID, u8 copy_u8IntSrc) {
     280:	98 2f       	mov	r25, r24
	/*step 1 : enable GIE*/
	SET_BIT(MEXTI_SREG_Register, I_BIT);
     282:	8f b7       	in	r24, 0x3f	; 63
     284:	80 68       	ori	r24, 0x80	; 128
     286:	8f bf       	out	0x3f, r24	; 63
	switch (copy_u8IntID) {
     288:	91 30       	cpi	r25, 0x01	; 1
     28a:	19 f1       	breq	.+70     	; 0x2d2 <MEXTI_voidEnable_Int+0x52>
     28c:	91 30       	cpi	r25, 0x01	; 1
     28e:	20 f0       	brcs	.+8      	; 0x298 <MEXTI_voidEnable_Int+0x18>
     290:	92 30       	cpi	r25, 0x02	; 2
     292:	09 f0       	breq	.+2      	; 0x296 <MEXTI_voidEnable_Int+0x16>
     294:	4a c0       	rjmp	.+148    	; 0x32a <MEXTI_voidEnable_Int+0xaa>
     296:	3b c0       	rjmp	.+118    	; 0x30e <MEXTI_voidEnable_Int+0x8e>
	case INT0_ID:
		/*enable PIE for INT0*/
		SET_BIT(MEXTI_GICR_Register, INT0);
     298:	8b b7       	in	r24, 0x3b	; 59
     29a:	80 64       	ori	r24, 0x40	; 64
     29c:	8b bf       	out	0x3b, r24	; 59
		/*config trigger for INT0*/
		switch (copy_u8IntSrc) {
     29e:	61 30       	cpi	r22, 0x01	; 1
     2a0:	79 f0       	breq	.+30     	; 0x2c0 <MEXTI_voidEnable_Int+0x40>
     2a2:	61 30       	cpi	r22, 0x01	; 1
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <MEXTI_voidEnable_Int+0x46>
     2a6:	62 30       	cpi	r22, 0x02	; 2
     2a8:	29 f0       	breq	.+10     	; 0x2b4 <MEXTI_voidEnable_Int+0x34>
     2aa:	63 30       	cpi	r22, 0x03	; 3
     2ac:	f1 f5       	brne	.+124    	; 0x32a <MEXTI_voidEnable_Int+0xaa>
		case LOW_LEVEL:
			CLR_BIT(MEXTI_MCUCR_Register, ISC00);
     2ae:	85 b7       	in	r24, 0x35	; 53
     2b0:	8e 7f       	andi	r24, 0xFE	; 254
     2b2:	02 c0       	rjmp	.+4      	; 0x2b8 <MEXTI_voidEnable_Int+0x38>
			CLR_BIT(MEXTI_MCUCR_Register, ISC01);
			break;
		case ANY_CHANGE:
			SET_BIT(MEXTI_MCUCR_Register, ISC00);
     2b4:	85 b7       	in	r24, 0x35	; 53
     2b6:	81 60       	ori	r24, 0x01	; 1
     2b8:	85 bf       	out	0x35, r24	; 53
			CLR_BIT(MEXTI_MCUCR_Register, ISC01);
     2ba:	85 b7       	in	r24, 0x35	; 53
     2bc:	8d 7f       	andi	r24, 0xFD	; 253
     2be:	25 c0       	rjmp	.+74     	; 0x30a <MEXTI_voidEnable_Int+0x8a>
			break;
		case FALL_EDGE:
			CLR_BIT(MEXTI_MCUCR_Register, ISC00);
     2c0:	85 b7       	in	r24, 0x35	; 53
     2c2:	8e 7f       	andi	r24, 0xFE	; 254
     2c4:	02 c0       	rjmp	.+4      	; 0x2ca <MEXTI_voidEnable_Int+0x4a>
			SET_BIT(MEXTI_MCUCR_Register, ISC01);
			break;
		case RISE_EDGE:
			SET_BIT(MEXTI_MCUCR_Register, ISC00);
     2c6:	85 b7       	in	r24, 0x35	; 53
     2c8:	81 60       	ori	r24, 0x01	; 1
     2ca:	85 bf       	out	0x35, r24	; 53
			SET_BIT(MEXTI_MCUCR_Register, ISC01);
     2cc:	85 b7       	in	r24, 0x35	; 53
     2ce:	82 60       	ori	r24, 0x02	; 2
     2d0:	1c c0       	rjmp	.+56     	; 0x30a <MEXTI_voidEnable_Int+0x8a>
		}

		break;
	case INT1_ID:
		/*enable PIE for INT1*/
		SET_BIT(MEXTI_GICR_Register, INT1);
     2d2:	8b b7       	in	r24, 0x3b	; 59
     2d4:	80 68       	ori	r24, 0x80	; 128
     2d6:	8b bf       	out	0x3b, r24	; 59
		/*config trigger for INT1*/
		switch (copy_u8IntSrc) {
     2d8:	61 30       	cpi	r22, 0x01	; 1
     2da:	79 f0       	breq	.+30     	; 0x2fa <MEXTI_voidEnable_Int+0x7a>
     2dc:	61 30       	cpi	r22, 0x01	; 1
     2de:	80 f0       	brcs	.+32     	; 0x300 <MEXTI_voidEnable_Int+0x80>
     2e0:	62 30       	cpi	r22, 0x02	; 2
     2e2:	29 f0       	breq	.+10     	; 0x2ee <MEXTI_voidEnable_Int+0x6e>
     2e4:	63 30       	cpi	r22, 0x03	; 3
     2e6:	09 f5       	brne	.+66     	; 0x32a <MEXTI_voidEnable_Int+0xaa>
		case LOW_LEVEL:
			CLR_BIT(MEXTI_MCUCR_Register, ISC10);
     2e8:	85 b7       	in	r24, 0x35	; 53
     2ea:	8b 7f       	andi	r24, 0xFB	; 251
     2ec:	02 c0       	rjmp	.+4      	; 0x2f2 <MEXTI_voidEnable_Int+0x72>
			CLR_BIT(MEXTI_MCUCR_Register, ISC11);
			break;
		case ANY_CHANGE:
			SET_BIT(MEXTI_MCUCR_Register, ISC10);
     2ee:	85 b7       	in	r24, 0x35	; 53
     2f0:	84 60       	ori	r24, 0x04	; 4
     2f2:	85 bf       	out	0x35, r24	; 53
			CLR_BIT(MEXTI_MCUCR_Register, ISC11);
     2f4:	85 b7       	in	r24, 0x35	; 53
     2f6:	87 7f       	andi	r24, 0xF7	; 247
     2f8:	08 c0       	rjmp	.+16     	; 0x30a <MEXTI_voidEnable_Int+0x8a>
			break;
		case FALL_EDGE:
			CLR_BIT(MEXTI_MCUCR_Register, ISC10);
     2fa:	85 b7       	in	r24, 0x35	; 53
     2fc:	8b 7f       	andi	r24, 0xFB	; 251
     2fe:	02 c0       	rjmp	.+4      	; 0x304 <MEXTI_voidEnable_Int+0x84>
			SET_BIT(MEXTI_MCUCR_Register, ISC11);
			break;
		case RISE_EDGE:
			SET_BIT(MEXTI_MCUCR_Register, ISC10);
     300:	85 b7       	in	r24, 0x35	; 53
     302:	84 60       	ori	r24, 0x04	; 4
     304:	85 bf       	out	0x35, r24	; 53
			SET_BIT(MEXTI_MCUCR_Register, ISC11);
     306:	85 b7       	in	r24, 0x35	; 53
     308:	88 60       	ori	r24, 0x08	; 8
     30a:	85 bf       	out	0x35, r24	; 53
     30c:	08 95       	ret
		}

		break;
	case INT2_ID:
		/*enable PIE for INT2*/
		SET_BIT(MEXTI_GICR_Register, INT2);
     30e:	8b b7       	in	r24, 0x3b	; 59
     310:	80 62       	ori	r24, 0x20	; 32
     312:	8b bf       	out	0x3b, r24	; 59
		/*config trigger for INT2*/
		switch (copy_u8IntSrc) {
     314:	66 23       	and	r22, r22
     316:	31 f0       	breq	.+12     	; 0x324 <MEXTI_voidEnable_Int+0xa4>
     318:	61 30       	cpi	r22, 0x01	; 1
     31a:	39 f4       	brne	.+14     	; 0x32a <MEXTI_voidEnable_Int+0xaa>

		case FALL_EDGE:
			CLR_BIT(MEXTI_MCUCSR_Register, ISC2);
     31c:	84 b7       	in	r24, 0x34	; 52
     31e:	8f 7b       	andi	r24, 0xBF	; 191
     320:	84 bf       	out	0x34, r24	; 52
     322:	08 95       	ret
			break;
		case RISE_EDGE:
			SET_BIT(MEXTI_MCUCSR_Register, ISC2);
     324:	84 b7       	in	r24, 0x34	; 52
     326:	80 64       	ori	r24, 0x40	; 64
     328:	84 bf       	out	0x34, r24	; 52
     32a:	08 95       	ret

0000032c <MEXTI_voidDisable_Int>:

		break;
	}
}
void MEXTI_voidDisable_Int(u8 copy_u8IntID) {
	switch(copy_u8IntID)
     32c:	81 30       	cpi	r24, 0x01	; 1
     32e:	41 f0       	breq	.+16     	; 0x340 <MEXTI_voidDisable_Int+0x14>
     330:	81 30       	cpi	r24, 0x01	; 1
     332:	18 f0       	brcs	.+6      	; 0x33a <MEXTI_voidDisable_Int+0xe>
     334:	82 30       	cpi	r24, 0x02	; 2
     336:	59 f4       	brne	.+22     	; 0x34e <MEXTI_voidDisable_Int+0x22>
     338:	07 c0       	rjmp	.+14     	; 0x348 <MEXTI_voidDisable_Int+0x1c>
	  {
	  case INT0_ID:
	       CLR_BIT(MEXTI_GICR_Register,INT0);
     33a:	8b b7       	in	r24, 0x3b	; 59
     33c:	8f 7b       	andi	r24, 0xBF	; 191
     33e:	02 c0       	rjmp	.+4      	; 0x344 <MEXTI_voidDisable_Int+0x18>
	       break;
	  case INT1_ID:
	       CLR_BIT(MEXTI_GICR_Register,INT1);
     340:	8b b7       	in	r24, 0x3b	; 59
     342:	8f 77       	andi	r24, 0x7F	; 127
     344:	8b bf       	out	0x3b, r24	; 59
     346:	08 95       	ret
	        break;
	  case INT2_ID:
	        CLR_BIT(MEXTI_GICR_Register,INT2);
     348:	8b b7       	in	r24, 0x3b	; 59
     34a:	8f 7d       	andi	r24, 0xDF	; 223
     34c:	8b bf       	out	0x3b, r24	; 59
     34e:	08 95       	ret

00000350 <MEXTI_setCallBack_INT0>:
	        break;
	  }
}
void MEXTI_setCallBack_INT0(void (*copy_ptr_function)(void)) {
	global_ptrf_INT0 = copy_ptr_function;
     350:	90 93 3c 07 	sts	0x073C, r25
     354:	80 93 3b 07 	sts	0x073B, r24
}
     358:	08 95       	ret

0000035a <MEXTI_setCallBack_INT1>:
void MEXTI_setCallBack_INT1(void (*copy_ptr_function)(void)) {
	global_ptrf_INT1 = copy_ptr_function;
     35a:	90 93 3e 07 	sts	0x073E, r25
     35e:	80 93 3d 07 	sts	0x073D, r24
}
     362:	08 95       	ret

00000364 <MEXTI_setCallBack_INT2>:
void MEXTI_setCallBack_INT2(void (*copy_ptr_function)(void)) {
	global_ptrf_INT2 = copy_ptr_function;
     364:	90 93 3a 07 	sts	0x073A, r25
     368:	80 93 39 07 	sts	0x0739, r24
}
     36c:	08 95       	ret

0000036e <__vector_1>:
ISR(INT0_vect) {
     36e:	1f 92       	push	r1
     370:	0f 92       	push	r0
     372:	0f b6       	in	r0, 0x3f	; 63
     374:	0f 92       	push	r0
     376:	11 24       	eor	r1, r1
     378:	2f 93       	push	r18
     37a:	3f 93       	push	r19
     37c:	4f 93       	push	r20
     37e:	5f 93       	push	r21
     380:	6f 93       	push	r22
     382:	7f 93       	push	r23
     384:	8f 93       	push	r24
     386:	9f 93       	push	r25
     388:	af 93       	push	r26
     38a:	bf 93       	push	r27
     38c:	ef 93       	push	r30
     38e:	ff 93       	push	r31
	global_ptrf_INT0();
     390:	e0 91 3b 07 	lds	r30, 0x073B
     394:	f0 91 3c 07 	lds	r31, 0x073C
     398:	09 95       	icall
}
     39a:	ff 91       	pop	r31
     39c:	ef 91       	pop	r30
     39e:	bf 91       	pop	r27
     3a0:	af 91       	pop	r26
     3a2:	9f 91       	pop	r25
     3a4:	8f 91       	pop	r24
     3a6:	7f 91       	pop	r23
     3a8:	6f 91       	pop	r22
     3aa:	5f 91       	pop	r21
     3ac:	4f 91       	pop	r20
     3ae:	3f 91       	pop	r19
     3b0:	2f 91       	pop	r18
     3b2:	0f 90       	pop	r0
     3b4:	0f be       	out	0x3f, r0	; 63
     3b6:	0f 90       	pop	r0
     3b8:	1f 90       	pop	r1
     3ba:	18 95       	reti

000003bc <__vector_2>:
ISR(INT1_vect) {
     3bc:	1f 92       	push	r1
     3be:	0f 92       	push	r0
     3c0:	0f b6       	in	r0, 0x3f	; 63
     3c2:	0f 92       	push	r0
     3c4:	11 24       	eor	r1, r1
     3c6:	2f 93       	push	r18
     3c8:	3f 93       	push	r19
     3ca:	4f 93       	push	r20
     3cc:	5f 93       	push	r21
     3ce:	6f 93       	push	r22
     3d0:	7f 93       	push	r23
     3d2:	8f 93       	push	r24
     3d4:	9f 93       	push	r25
     3d6:	af 93       	push	r26
     3d8:	bf 93       	push	r27
     3da:	ef 93       	push	r30
     3dc:	ff 93       	push	r31
	global_ptrf_INT1();
     3de:	e0 91 3d 07 	lds	r30, 0x073D
     3e2:	f0 91 3e 07 	lds	r31, 0x073E
     3e6:	09 95       	icall
}
     3e8:	ff 91       	pop	r31
     3ea:	ef 91       	pop	r30
     3ec:	bf 91       	pop	r27
     3ee:	af 91       	pop	r26
     3f0:	9f 91       	pop	r25
     3f2:	8f 91       	pop	r24
     3f4:	7f 91       	pop	r23
     3f6:	6f 91       	pop	r22
     3f8:	5f 91       	pop	r21
     3fa:	4f 91       	pop	r20
     3fc:	3f 91       	pop	r19
     3fe:	2f 91       	pop	r18
     400:	0f 90       	pop	r0
     402:	0f be       	out	0x3f, r0	; 63
     404:	0f 90       	pop	r0
     406:	1f 90       	pop	r1
     408:	18 95       	reti

0000040a <__vector_3>:
ISR(INT2_vect) {
     40a:	1f 92       	push	r1
     40c:	0f 92       	push	r0
     40e:	0f b6       	in	r0, 0x3f	; 63
     410:	0f 92       	push	r0
     412:	11 24       	eor	r1, r1
     414:	2f 93       	push	r18
     416:	3f 93       	push	r19
     418:	4f 93       	push	r20
     41a:	5f 93       	push	r21
     41c:	6f 93       	push	r22
     41e:	7f 93       	push	r23
     420:	8f 93       	push	r24
     422:	9f 93       	push	r25
     424:	af 93       	push	r26
     426:	bf 93       	push	r27
     428:	ef 93       	push	r30
     42a:	ff 93       	push	r31
	global_ptrf_INT2();
     42c:	e0 91 39 07 	lds	r30, 0x0739
     430:	f0 91 3a 07 	lds	r31, 0x073A
     434:	09 95       	icall
}
     436:	ff 91       	pop	r31
     438:	ef 91       	pop	r30
     43a:	bf 91       	pop	r27
     43c:	af 91       	pop	r26
     43e:	9f 91       	pop	r25
     440:	8f 91       	pop	r24
     442:	7f 91       	pop	r23
     444:	6f 91       	pop	r22
     446:	5f 91       	pop	r21
     448:	4f 91       	pop	r20
     44a:	3f 91       	pop	r19
     44c:	2f 91       	pop	r18
     44e:	0f 90       	pop	r0
     450:	0f be       	out	0x3f, r0	; 63
     452:	0f 90       	pop	r0
     454:	1f 90       	pop	r1
     456:	18 95       	reti

00000458 <MADC_voidInit>:
#include "MADC_private.h"

void MADC_voidInit(void)
{
	/* step 1: config prescaler */
	MADC_ADCSRA_REG &=  MADC_PRESCALER_MASK;
     458:	86 b1       	in	r24, 0x06	; 6
     45a:	88 7f       	andi	r24, 0xF8	; 248
     45c:	86 b9       	out	0x06, r24	; 6
	MADC_ADCSRA_REG |= MADC_PRESCALER;
     45e:	32 9a       	sbi	0x06, 2	; 6

	/* step 2: vref select */
	MADC_ADMUX_REG &= MADC_VREF_MASK;
     460:	87 b1       	in	r24, 0x07	; 7
     462:	8f 73       	andi	r24, 0x3F	; 63
     464:	87 b9       	out	0x07, r24	; 7
	MADC_ADMUX_REG |= MADC_VREF<< 6;
     466:	3e 9a       	sbi	0x07, 6	; 7

	/* step 3: disable INT*/
	CLR_BIT(MADC_ADCSRA_REG,ADIE);
     468:	33 98       	cbi	0x06, 3	; 6

	/* step 4: config adjustment */
	CLR_BIT(MADC_ADMUX_REG,ADLAR);
     46a:	3d 98       	cbi	0x07, 5	; 7

	/* step : Enable ADC */
	SET_BIT(MADC_ADCSRA_REG,ADEN);
     46c:	37 9a       	sbi	0x06, 7	; 6
}
     46e:	08 95       	ret

00000470 <MADC_voidADCread>:
u16 MADC_voidADCread(u8 copy_ADCchannel)
{
	u16 adc_digital_value;

	/* step 1: choose channel */
	MADC_ADMUX_REG &= CHANNEL_MASK;
     470:	97 b1       	in	r25, 0x07	; 7
     472:	90 7e       	andi	r25, 0xE0	; 224
     474:	97 b9       	out	0x07, r25	; 7
	MADC_ADMUX_REG |= copy_ADCchannel;
     476:	97 b1       	in	r25, 0x07	; 7
     478:	98 2b       	or	r25, r24
     47a:	97 b9       	out	0x07, r25	; 7

	/* step 2: start conversion */
	SET_BIT(MADC_ADCSRA_REG,ADSC);
     47c:	36 9a       	sbi	0x06, 6	; 6

	/* step 3: wait until conversion is complete */
	while(GET_BIT(MADC_ADCSRA_REG,ADIF)==0);
     47e:	34 9b       	sbis	0x06, 4	; 6
     480:	fe cf       	rjmp	.-4      	; 0x47e <MADC_voidADCread+0xe>

	/* step 4: read value */
	adc_digital_value = MADC_ADCL_REG + (MADC_ADCH_REG<<8);
     482:	94 b1       	in	r25, 0x04	; 4
     484:	85 b1       	in	r24, 0x05	; 5
     486:	38 2f       	mov	r19, r24
     488:	20 e0       	ldi	r18, 0x00	; 0
     48a:	29 0f       	add	r18, r25
     48c:	31 1d       	adc	r19, r1

	/* step 5: return value */
	return adc_digital_value;
}
     48e:	c9 01       	movw	r24, r18
     490:	08 95       	ret

00000492 <GPI_voidEnable>:
#include "GPI_private.h"


void GPI_voidEnable(void)
{
	SET_BIT(GPI_SREG,GPI_I_BIT);
     492:	8f b7       	in	r24, 0x3f	; 63
     494:	80 68       	ori	r24, 0x80	; 128
     496:	8f bf       	out	0x3f, r24	; 63
}
     498:	08 95       	ret

0000049a <GPI_voidDisable>:
void GPI_voidDisable(void)
{
	CLR_BIT(GPI_SREG,GPI_I_BIT);
     49a:	8f b7       	in	r24, 0x3f	; 63
     49c:	8f 77       	andi	r24, 0x7F	; 127
     49e:	8f bf       	out	0x3f, r24	; 63
}
     4a0:	08 95       	ret

000004a2 <DIO_voidInit>:
#include "DIO_interface.h"
#include "DIO_private.h"
#include "DIO_config.h"
void DIO_voidInit         (void){
	/* Set Directions of All Pins Of Our MC */
	DIO_u8_DDRA_REG = PRIVATE_CONC(DIO_u8_PA7_DIRECTION,DIO_u8_PA6_DIRECTION,DIO_u8_PA5_DIRECTION,DIO_u8_PA4_DIRECTION,
     4a2:	1a ba       	out	0x1a, r1	; 26
								   DIO_u8_PA3_DIRECTION,DIO_u8_PA2_DIRECTION,DIO_u8_PA1_DIRECTION,DIO_u8_PA0_DIRECTION);

	DIO_u8_DDRB_REG = PRIVATE_CONC(DIO_u8_PB7_DIRECTION,DIO_u8_PB6_DIRECTION,DIO_u8_PB5_DIRECTION,DIO_u8_PB4_DIRECTION,
     4a4:	17 ba       	out	0x17, r1	; 23
								   DIO_u8_PB3_DIRECTION,DIO_u8_PB2_DIRECTION,DIO_u8_PB1_DIRECTION,DIO_u8_PB0_DIRECTION);

	DIO_u8_DDRC_REG = PRIVATE_CONC(DIO_u8_PC7_DIRECTION,DIO_u8_PC6_DIRECTION,DIO_u8_PC5_DIRECTION,DIO_u8_PC4_DIRECTION,
     4a6:	14 ba       	out	0x14, r1	; 20
								   DIO_u8_PC3_DIRECTION,DIO_u8_PC2_DIRECTION,DIO_u8_PC1_DIRECTION,DIO_u8_PC0_DIRECTION);

	DIO_u8_DDRD_REG = PRIVATE_CONC(DIO_u8_PD7_DIRECTION,DIO_u8_PD6_DIRECTION,DIO_u8_PD5_DIRECTION,DIO_u8_PD4_DIRECTION,
     4a8:	80 e4       	ldi	r24, 0x40	; 64
     4aa:	81 bb       	out	0x11, r24	; 17
								   DIO_u8_PD3_DIRECTION,DIO_u8_PD2_DIRECTION,DIO_u8_PD1_DIRECTION,DIO_u8_PD0_DIRECTION);

	/* Set Init Values of All Pins Of Our MC */
	DIO_u8_PORTA_REG = PRIVATE_CONC(DIO_u8_PA7_VALUE,DIO_u8_PA6_VALUE,DIO_u8_PA5_VALUE,DIO_u8_PA4_VALUE,
     4ac:	1b ba       	out	0x1b, r1	; 27
								   DIO_u8_PA3_VALUE,DIO_u8_PA2_VALUE,DIO_u8_PA1_VALUE,DIO_u8_PA0_VALUE);

	DIO_u8_PORTB_REG = PRIVATE_CONC(DIO_u8_PB7_VALUE,DIO_u8_PB6_VALUE,DIO_u8_PB5_VALUE,DIO_u8_PB4_VALUE,
     4ae:	88 e0       	ldi	r24, 0x08	; 8
     4b0:	88 bb       	out	0x18, r24	; 24
								   DIO_u8_PB3_VALUE,DIO_u8_PB2_VALUE,DIO_u8_PB1_VALUE,DIO_u8_PB0_VALUE);

	DIO_u8_PORTC_REG = PRIVATE_CONC(DIO_u8_PC7_VALUE,DIO_u8_PC6_VALUE,DIO_u8_PC5_VALUE,DIO_u8_PC4_VALUE,
     4b2:	15 ba       	out	0x15, r1	; 21
								   DIO_u8_PC3_VALUE,DIO_u8_PC2_VALUE,DIO_u8_PC1_VALUE,DIO_u8_PC0_VALUE);

	DIO_u8_PORTD_REG = PRIVATE_CONC(DIO_u8_PD7_VALUE,DIO_u8_PD6_VALUE,DIO_u8_PD5_VALUE,DIO_u8_PD4_VALUE,
     4b4:	12 ba       	out	0x12, r1	; 18
								   DIO_u8_PD3_VALUE,DIO_u8_PD2_VALUE,DIO_u8_PD1_VALUE,DIO_u8_PD0_VALUE);
}
     4b6:	08 95       	ret

000004b8 <DIO_u8SetPinDirection>:
u8 DIO_u8SetPinDirection(u8 Copy_u8PortId, u8 Copy_u8PinId,
		u8 Copy_u8PinDirection) {
	u8 Local_u8ErrorState = STD_TYPES_OK;
	if (Copy_u8PinId <= DIO_u8_PIN7) {
     4b8:	68 30       	cpi	r22, 0x08	; 8
     4ba:	08 f0       	brcs	.+2      	; 0x4be <DIO_u8SetPinDirection+0x6>
     4bc:	c7 c0       	rjmp	.+398    	; 0x64c <DIO_u8SetPinDirection+0x194>
		switch (Copy_u8PortId) {
     4be:	81 30       	cpi	r24, 0x01	; 1
     4c0:	c1 f1       	breq	.+112    	; 0x532 <DIO_u8SetPinDirection+0x7a>
     4c2:	81 30       	cpi	r24, 0x01	; 1
     4c4:	38 f0       	brcs	.+14     	; 0x4d4 <DIO_u8SetPinDirection+0x1c>
     4c6:	82 30       	cpi	r24, 0x02	; 2
     4c8:	09 f4       	brne	.+2      	; 0x4cc <DIO_u8SetPinDirection+0x14>
     4ca:	62 c0       	rjmp	.+196    	; 0x590 <DIO_u8SetPinDirection+0xd8>
     4cc:	83 30       	cpi	r24, 0x03	; 3
     4ce:	09 f0       	breq	.+2      	; 0x4d2 <DIO_u8SetPinDirection+0x1a>
     4d0:	bd c0       	rjmp	.+378    	; 0x64c <DIO_u8SetPinDirection+0x194>
     4d2:	8d c0       	rjmp	.+282    	; 0x5ee <DIO_u8SetPinDirection+0x136>
		case DIO_u8_PORTA:
			switch (Copy_u8PinDirection) {
     4d4:	41 30       	cpi	r20, 0x01	; 1
     4d6:	31 f0       	breq	.+12     	; 0x4e4 <DIO_u8SetPinDirection+0x2c>
     4d8:	41 30       	cpi	r20, 0x01	; 1
     4da:	78 f0       	brcs	.+30     	; 0x4fa <DIO_u8SetPinDirection+0x42>
     4dc:	42 30       	cpi	r20, 0x02	; 2
     4de:	09 f0       	breq	.+2      	; 0x4e2 <DIO_u8SetPinDirection+0x2a>
     4e0:	b5 c0       	rjmp	.+362    	; 0x64c <DIO_u8SetPinDirection+0x194>
     4e2:	17 c0       	rjmp	.+46     	; 0x512 <DIO_u8SetPinDirection+0x5a>
			case DIO_u8_OUTPUT:
				SET_BIT(DIO_u8_DDRA_REG, Copy_u8PinId);
     4e4:	2a b3       	in	r18, 0x1a	; 26
     4e6:	81 e0       	ldi	r24, 0x01	; 1
     4e8:	90 e0       	ldi	r25, 0x00	; 0
     4ea:	02 c0       	rjmp	.+4      	; 0x4f0 <DIO_u8SetPinDirection+0x38>
     4ec:	88 0f       	add	r24, r24
     4ee:	99 1f       	adc	r25, r25
     4f0:	6a 95       	dec	r22
     4f2:	e2 f7       	brpl	.-8      	; 0x4ec <DIO_u8SetPinDirection+0x34>
     4f4:	28 2b       	or	r18, r24
     4f6:	2a bb       	out	0x1a, r18	; 26
     4f8:	a7 c0       	rjmp	.+334    	; 0x648 <DIO_u8SetPinDirection+0x190>
				break;
			case DIO_u8_INPUT_FLOATING:
				CLR_BIT(DIO_u8_DDRA_REG, Copy_u8PinId);
     4fa:	2a b3       	in	r18, 0x1a	; 26
     4fc:	81 e0       	ldi	r24, 0x01	; 1
     4fe:	90 e0       	ldi	r25, 0x00	; 0
     500:	02 c0       	rjmp	.+4      	; 0x506 <DIO_u8SetPinDirection+0x4e>
     502:	88 0f       	add	r24, r24
     504:	99 1f       	adc	r25, r25
     506:	6a 95       	dec	r22
     508:	e2 f7       	brpl	.-8      	; 0x502 <DIO_u8SetPinDirection+0x4a>
     50a:	80 95       	com	r24
     50c:	82 23       	and	r24, r18
     50e:	8a bb       	out	0x1a, r24	; 26
     510:	9b c0       	rjmp	.+310    	; 0x648 <DIO_u8SetPinDirection+0x190>
				break;
			case DIO_u8_INPUT_PULLED_UP:
				CLR_BIT(DIO_u8_DDRA_REG, Copy_u8PinId);
     512:	3a b3       	in	r19, 0x1a	; 26
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 c0       	rjmp	.+4      	; 0x51e <DIO_u8SetPinDirection+0x66>
     51a:	88 0f       	add	r24, r24
     51c:	99 1f       	adc	r25, r25
     51e:	6a 95       	dec	r22
     520:	e2 f7       	brpl	.-8      	; 0x51a <DIO_u8SetPinDirection+0x62>
     522:	28 2f       	mov	r18, r24
     524:	20 95       	com	r18
     526:	23 23       	and	r18, r19
     528:	2a bb       	out	0x1a, r18	; 26
				SET_BIT(DIO_u8_PORTA_REG, Copy_u8PinId);
     52a:	2b b3       	in	r18, 0x1b	; 27
     52c:	82 2b       	or	r24, r18
     52e:	8b bb       	out	0x1b, r24	; 27
     530:	8b c0       	rjmp	.+278    	; 0x648 <DIO_u8SetPinDirection+0x190>
			default:
				Local_u8ErrorState = STD_TYPES_NOK;
			}
			break;
			case DIO_u8_PORTB:
				switch (Copy_u8PinDirection) {
     532:	41 30       	cpi	r20, 0x01	; 1
     534:	31 f0       	breq	.+12     	; 0x542 <DIO_u8SetPinDirection+0x8a>
     536:	41 30       	cpi	r20, 0x01	; 1
     538:	78 f0       	brcs	.+30     	; 0x558 <DIO_u8SetPinDirection+0xa0>
     53a:	42 30       	cpi	r20, 0x02	; 2
     53c:	09 f0       	breq	.+2      	; 0x540 <DIO_u8SetPinDirection+0x88>
     53e:	86 c0       	rjmp	.+268    	; 0x64c <DIO_u8SetPinDirection+0x194>
     540:	17 c0       	rjmp	.+46     	; 0x570 <DIO_u8SetPinDirection+0xb8>
				case DIO_u8_OUTPUT:
					SET_BIT(DIO_u8_DDRB_REG, Copy_u8PinId);
     542:	27 b3       	in	r18, 0x17	; 23
     544:	81 e0       	ldi	r24, 0x01	; 1
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	02 c0       	rjmp	.+4      	; 0x54e <DIO_u8SetPinDirection+0x96>
     54a:	88 0f       	add	r24, r24
     54c:	99 1f       	adc	r25, r25
     54e:	6a 95       	dec	r22
     550:	e2 f7       	brpl	.-8      	; 0x54a <DIO_u8SetPinDirection+0x92>
     552:	28 2b       	or	r18, r24
     554:	27 bb       	out	0x17, r18	; 23
     556:	78 c0       	rjmp	.+240    	; 0x648 <DIO_u8SetPinDirection+0x190>
					break;
				case DIO_u8_INPUT_FLOATING:
					CLR_BIT(DIO_u8_DDRB_REG, Copy_u8PinId);
     558:	27 b3       	in	r18, 0x17	; 23
     55a:	81 e0       	ldi	r24, 0x01	; 1
     55c:	90 e0       	ldi	r25, 0x00	; 0
     55e:	02 c0       	rjmp	.+4      	; 0x564 <DIO_u8SetPinDirection+0xac>
     560:	88 0f       	add	r24, r24
     562:	99 1f       	adc	r25, r25
     564:	6a 95       	dec	r22
     566:	e2 f7       	brpl	.-8      	; 0x560 <DIO_u8SetPinDirection+0xa8>
     568:	80 95       	com	r24
     56a:	82 23       	and	r24, r18
     56c:	87 bb       	out	0x17, r24	; 23
     56e:	6c c0       	rjmp	.+216    	; 0x648 <DIO_u8SetPinDirection+0x190>
					break;
				case DIO_u8_INPUT_PULLED_UP:
					CLR_BIT(DIO_u8_DDRB_REG, Copy_u8PinId);
     570:	37 b3       	in	r19, 0x17	; 23
     572:	81 e0       	ldi	r24, 0x01	; 1
     574:	90 e0       	ldi	r25, 0x00	; 0
     576:	02 c0       	rjmp	.+4      	; 0x57c <DIO_u8SetPinDirection+0xc4>
     578:	88 0f       	add	r24, r24
     57a:	99 1f       	adc	r25, r25
     57c:	6a 95       	dec	r22
     57e:	e2 f7       	brpl	.-8      	; 0x578 <DIO_u8SetPinDirection+0xc0>
     580:	28 2f       	mov	r18, r24
     582:	20 95       	com	r18
     584:	23 23       	and	r18, r19
     586:	27 bb       	out	0x17, r18	; 23
					SET_BIT(DIO_u8_PORTB_REG, Copy_u8PinId);
     588:	28 b3       	in	r18, 0x18	; 24
     58a:	82 2b       	or	r24, r18
     58c:	88 bb       	out	0x18, r24	; 24
     58e:	5c c0       	rjmp	.+184    	; 0x648 <DIO_u8SetPinDirection+0x190>
				default:
					Local_u8ErrorState = STD_TYPES_NOK;
				}
				break;
				case DIO_u8_PORTC:
					switch (Copy_u8PinDirection) {
     590:	41 30       	cpi	r20, 0x01	; 1
     592:	31 f0       	breq	.+12     	; 0x5a0 <DIO_u8SetPinDirection+0xe8>
     594:	41 30       	cpi	r20, 0x01	; 1
     596:	78 f0       	brcs	.+30     	; 0x5b6 <DIO_u8SetPinDirection+0xfe>
     598:	42 30       	cpi	r20, 0x02	; 2
     59a:	09 f0       	breq	.+2      	; 0x59e <DIO_u8SetPinDirection+0xe6>
     59c:	57 c0       	rjmp	.+174    	; 0x64c <DIO_u8SetPinDirection+0x194>
     59e:	17 c0       	rjmp	.+46     	; 0x5ce <DIO_u8SetPinDirection+0x116>
					case DIO_u8_OUTPUT:
						SET_BIT(DIO_u8_DDRC_REG, Copy_u8PinId);
     5a0:	24 b3       	in	r18, 0x14	; 20
     5a2:	81 e0       	ldi	r24, 0x01	; 1
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	02 c0       	rjmp	.+4      	; 0x5ac <DIO_u8SetPinDirection+0xf4>
     5a8:	88 0f       	add	r24, r24
     5aa:	99 1f       	adc	r25, r25
     5ac:	6a 95       	dec	r22
     5ae:	e2 f7       	brpl	.-8      	; 0x5a8 <DIO_u8SetPinDirection+0xf0>
     5b0:	28 2b       	or	r18, r24
     5b2:	24 bb       	out	0x14, r18	; 20
     5b4:	49 c0       	rjmp	.+146    	; 0x648 <DIO_u8SetPinDirection+0x190>
						break;
					case DIO_u8_INPUT_FLOATING:
						CLR_BIT(DIO_u8_DDRC_REG, Copy_u8PinId);
     5b6:	24 b3       	in	r18, 0x14	; 20
     5b8:	81 e0       	ldi	r24, 0x01	; 1
     5ba:	90 e0       	ldi	r25, 0x00	; 0
     5bc:	02 c0       	rjmp	.+4      	; 0x5c2 <DIO_u8SetPinDirection+0x10a>
     5be:	88 0f       	add	r24, r24
     5c0:	99 1f       	adc	r25, r25
     5c2:	6a 95       	dec	r22
     5c4:	e2 f7       	brpl	.-8      	; 0x5be <DIO_u8SetPinDirection+0x106>
     5c6:	80 95       	com	r24
     5c8:	82 23       	and	r24, r18
     5ca:	84 bb       	out	0x14, r24	; 20
     5cc:	3d c0       	rjmp	.+122    	; 0x648 <DIO_u8SetPinDirection+0x190>
						break;
					case DIO_u8_INPUT_PULLED_UP:
						CLR_BIT(DIO_u8_DDRC_REG, Copy_u8PinId);
     5ce:	34 b3       	in	r19, 0x14	; 20
     5d0:	81 e0       	ldi	r24, 0x01	; 1
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	02 c0       	rjmp	.+4      	; 0x5da <DIO_u8SetPinDirection+0x122>
     5d6:	88 0f       	add	r24, r24
     5d8:	99 1f       	adc	r25, r25
     5da:	6a 95       	dec	r22
     5dc:	e2 f7       	brpl	.-8      	; 0x5d6 <DIO_u8SetPinDirection+0x11e>
     5de:	28 2f       	mov	r18, r24
     5e0:	20 95       	com	r18
     5e2:	23 23       	and	r18, r19
     5e4:	24 bb       	out	0x14, r18	; 20
						SET_BIT(DIO_u8_PORTC_REG, Copy_u8PinId);
     5e6:	25 b3       	in	r18, 0x15	; 21
     5e8:	82 2b       	or	r24, r18
     5ea:	85 bb       	out	0x15, r24	; 21
     5ec:	2d c0       	rjmp	.+90     	; 0x648 <DIO_u8SetPinDirection+0x190>
					default:
						Local_u8ErrorState = STD_TYPES_NOK;
					}
					break;
					case DIO_u8_PORTD:
						switch (Copy_u8PinDirection) {
     5ee:	41 30       	cpi	r20, 0x01	; 1
     5f0:	29 f0       	breq	.+10     	; 0x5fc <DIO_u8SetPinDirection+0x144>
     5f2:	41 30       	cpi	r20, 0x01	; 1
     5f4:	70 f0       	brcs	.+28     	; 0x612 <DIO_u8SetPinDirection+0x15a>
     5f6:	42 30       	cpi	r20, 0x02	; 2
     5f8:	49 f5       	brne	.+82     	; 0x64c <DIO_u8SetPinDirection+0x194>
     5fa:	17 c0       	rjmp	.+46     	; 0x62a <DIO_u8SetPinDirection+0x172>
						case DIO_u8_OUTPUT:
							SET_BIT(DIO_u8_DDRD_REG, Copy_u8PinId);
     5fc:	21 b3       	in	r18, 0x11	; 17
     5fe:	81 e0       	ldi	r24, 0x01	; 1
     600:	90 e0       	ldi	r25, 0x00	; 0
     602:	02 c0       	rjmp	.+4      	; 0x608 <DIO_u8SetPinDirection+0x150>
     604:	88 0f       	add	r24, r24
     606:	99 1f       	adc	r25, r25
     608:	6a 95       	dec	r22
     60a:	e2 f7       	brpl	.-8      	; 0x604 <DIO_u8SetPinDirection+0x14c>
     60c:	28 2b       	or	r18, r24
     60e:	21 bb       	out	0x11, r18	; 17
     610:	1b c0       	rjmp	.+54     	; 0x648 <DIO_u8SetPinDirection+0x190>
							break;
						case DIO_u8_INPUT_FLOATING:
							CLR_BIT(DIO_u8_DDRD_REG, Copy_u8PinId);
     612:	21 b3       	in	r18, 0x11	; 17
     614:	81 e0       	ldi	r24, 0x01	; 1
     616:	90 e0       	ldi	r25, 0x00	; 0
     618:	02 c0       	rjmp	.+4      	; 0x61e <DIO_u8SetPinDirection+0x166>
     61a:	88 0f       	add	r24, r24
     61c:	99 1f       	adc	r25, r25
     61e:	6a 95       	dec	r22
     620:	e2 f7       	brpl	.-8      	; 0x61a <DIO_u8SetPinDirection+0x162>
     622:	80 95       	com	r24
     624:	82 23       	and	r24, r18
     626:	81 bb       	out	0x11, r24	; 17
     628:	0f c0       	rjmp	.+30     	; 0x648 <DIO_u8SetPinDirection+0x190>
							break;
						case DIO_u8_INPUT_PULLED_UP:
							CLR_BIT(DIO_u8_DDRD_REG, Copy_u8PinId);
     62a:	31 b3       	in	r19, 0x11	; 17
     62c:	81 e0       	ldi	r24, 0x01	; 1
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	02 c0       	rjmp	.+4      	; 0x636 <DIO_u8SetPinDirection+0x17e>
     632:	88 0f       	add	r24, r24
     634:	99 1f       	adc	r25, r25
     636:	6a 95       	dec	r22
     638:	e2 f7       	brpl	.-8      	; 0x632 <DIO_u8SetPinDirection+0x17a>
     63a:	28 2f       	mov	r18, r24
     63c:	20 95       	com	r18
     63e:	23 23       	and	r18, r19
     640:	21 bb       	out	0x11, r18	; 17
							SET_BIT(DIO_u8_PORTD_REG, Copy_u8PinId);
     642:	22 b3       	in	r18, 0x12	; 18
     644:	82 2b       	or	r24, r18
     646:	82 bb       	out	0x12, r24	; 18
     648:	81 e0       	ldi	r24, 0x01	; 1
     64a:	08 95       	ret
							break;/* Activate Pull up resistor */
     64c:	80 e0       	ldi	r24, 0x00	; 0
		}
	} else {
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
     64e:	08 95       	ret

00000650 <DIO_u8SetPinValue>:

u8 DIO_u8SetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 Copy_u8PinValue) {
	u8 Local_u8ErrorState = STD_TYPES_OK;
	if (Copy_u8PinId <= DIO_u8_PIN7) {
     650:	68 30       	cpi	r22, 0x08	; 8
     652:	08 f0       	brcs	.+2      	; 0x656 <DIO_u8SetPinValue+0x6>
     654:	7e c0       	rjmp	.+252    	; 0x752 <DIO_u8SetPinValue+0x102>
		switch (Copy_u8PortId) {
     656:	81 30       	cpi	r24, 0x01	; 1
     658:	31 f1       	breq	.+76     	; 0x6a6 <DIO_u8SetPinValue+0x56>
     65a:	81 30       	cpi	r24, 0x01	; 1
     65c:	38 f0       	brcs	.+14     	; 0x66c <DIO_u8SetPinValue+0x1c>
     65e:	82 30       	cpi	r24, 0x02	; 2
     660:	09 f4       	brne	.+2      	; 0x664 <DIO_u8SetPinValue+0x14>
     662:	3e c0       	rjmp	.+124    	; 0x6e0 <DIO_u8SetPinValue+0x90>
     664:	83 30       	cpi	r24, 0x03	; 3
     666:	09 f0       	breq	.+2      	; 0x66a <DIO_u8SetPinValue+0x1a>
     668:	74 c0       	rjmp	.+232    	; 0x752 <DIO_u8SetPinValue+0x102>
     66a:	56 c0       	rjmp	.+172    	; 0x718 <DIO_u8SetPinValue+0xc8>
		case DIO_u8_PORTA:
			switch (Copy_u8PinValue) {
     66c:	44 23       	and	r20, r20
     66e:	21 f0       	breq	.+8      	; 0x678 <DIO_u8SetPinValue+0x28>
     670:	41 30       	cpi	r20, 0x01	; 1
     672:	09 f0       	breq	.+2      	; 0x676 <DIO_u8SetPinValue+0x26>
     674:	6e c0       	rjmp	.+220    	; 0x752 <DIO_u8SetPinValue+0x102>
     676:	0c c0       	rjmp	.+24     	; 0x690 <DIO_u8SetPinValue+0x40>
			case DIO_u8_LOW:
				CLR_BIT(DIO_u8_PORTA_REG, Copy_u8PinId);
     678:	2b b3       	in	r18, 0x1b	; 27
     67a:	81 e0       	ldi	r24, 0x01	; 1
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	02 c0       	rjmp	.+4      	; 0x684 <DIO_u8SetPinValue+0x34>
     680:	88 0f       	add	r24, r24
     682:	99 1f       	adc	r25, r25
     684:	6a 95       	dec	r22
     686:	e2 f7       	brpl	.-8      	; 0x680 <DIO_u8SetPinValue+0x30>
     688:	80 95       	com	r24
     68a:	82 23       	and	r24, r18
     68c:	8b bb       	out	0x1b, r24	; 27
     68e:	5f c0       	rjmp	.+190    	; 0x74e <DIO_u8SetPinValue+0xfe>
				break;
			case DIO_u8_HIGH:
				SET_BIT(DIO_u8_PORTA_REG, Copy_u8PinId);
     690:	2b b3       	in	r18, 0x1b	; 27
     692:	81 e0       	ldi	r24, 0x01	; 1
     694:	90 e0       	ldi	r25, 0x00	; 0
     696:	02 c0       	rjmp	.+4      	; 0x69c <DIO_u8SetPinValue+0x4c>
     698:	88 0f       	add	r24, r24
     69a:	99 1f       	adc	r25, r25
     69c:	6a 95       	dec	r22
     69e:	e2 f7       	brpl	.-8      	; 0x698 <DIO_u8SetPinValue+0x48>
     6a0:	28 2b       	or	r18, r24
     6a2:	2b bb       	out	0x1b, r18	; 27
     6a4:	54 c0       	rjmp	.+168    	; 0x74e <DIO_u8SetPinValue+0xfe>
			default:
				Local_u8ErrorState = STD_TYPES_NOK;
			}
			break;
			case DIO_u8_PORTB:
				switch (Copy_u8PinValue) {
     6a6:	44 23       	and	r20, r20
     6a8:	21 f0       	breq	.+8      	; 0x6b2 <DIO_u8SetPinValue+0x62>
     6aa:	41 30       	cpi	r20, 0x01	; 1
     6ac:	09 f0       	breq	.+2      	; 0x6b0 <DIO_u8SetPinValue+0x60>
     6ae:	51 c0       	rjmp	.+162    	; 0x752 <DIO_u8SetPinValue+0x102>
     6b0:	0c c0       	rjmp	.+24     	; 0x6ca <DIO_u8SetPinValue+0x7a>
				case DIO_u8_LOW:
					CLR_BIT(DIO_u8_PORTB_REG, Copy_u8PinId);
     6b2:	28 b3       	in	r18, 0x18	; 24
     6b4:	81 e0       	ldi	r24, 0x01	; 1
     6b6:	90 e0       	ldi	r25, 0x00	; 0
     6b8:	02 c0       	rjmp	.+4      	; 0x6be <DIO_u8SetPinValue+0x6e>
     6ba:	88 0f       	add	r24, r24
     6bc:	99 1f       	adc	r25, r25
     6be:	6a 95       	dec	r22
     6c0:	e2 f7       	brpl	.-8      	; 0x6ba <DIO_u8SetPinValue+0x6a>
     6c2:	80 95       	com	r24
     6c4:	82 23       	and	r24, r18
     6c6:	88 bb       	out	0x18, r24	; 24
     6c8:	42 c0       	rjmp	.+132    	; 0x74e <DIO_u8SetPinValue+0xfe>
					break;
				case DIO_u8_HIGH:
					SET_BIT(DIO_u8_PORTB_REG, Copy_u8PinId);
     6ca:	28 b3       	in	r18, 0x18	; 24
     6cc:	81 e0       	ldi	r24, 0x01	; 1
     6ce:	90 e0       	ldi	r25, 0x00	; 0
     6d0:	02 c0       	rjmp	.+4      	; 0x6d6 <DIO_u8SetPinValue+0x86>
     6d2:	88 0f       	add	r24, r24
     6d4:	99 1f       	adc	r25, r25
     6d6:	6a 95       	dec	r22
     6d8:	e2 f7       	brpl	.-8      	; 0x6d2 <DIO_u8SetPinValue+0x82>
     6da:	28 2b       	or	r18, r24
     6dc:	28 bb       	out	0x18, r18	; 24
     6de:	37 c0       	rjmp	.+110    	; 0x74e <DIO_u8SetPinValue+0xfe>
				default:
					Local_u8ErrorState = STD_TYPES_NOK;
				}
				break;
				case DIO_u8_PORTC:
					switch (Copy_u8PinValue) {
     6e0:	44 23       	and	r20, r20
     6e2:	19 f0       	breq	.+6      	; 0x6ea <DIO_u8SetPinValue+0x9a>
     6e4:	41 30       	cpi	r20, 0x01	; 1
     6e6:	a9 f5       	brne	.+106    	; 0x752 <DIO_u8SetPinValue+0x102>
     6e8:	0c c0       	rjmp	.+24     	; 0x702 <DIO_u8SetPinValue+0xb2>
					case DIO_u8_LOW:
						CLR_BIT(DIO_u8_PORTC_REG, Copy_u8PinId);
     6ea:	25 b3       	in	r18, 0x15	; 21
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	02 c0       	rjmp	.+4      	; 0x6f6 <DIO_u8SetPinValue+0xa6>
     6f2:	88 0f       	add	r24, r24
     6f4:	99 1f       	adc	r25, r25
     6f6:	6a 95       	dec	r22
     6f8:	e2 f7       	brpl	.-8      	; 0x6f2 <DIO_u8SetPinValue+0xa2>
     6fa:	80 95       	com	r24
     6fc:	82 23       	and	r24, r18
     6fe:	85 bb       	out	0x15, r24	; 21
     700:	26 c0       	rjmp	.+76     	; 0x74e <DIO_u8SetPinValue+0xfe>
						break;
					case DIO_u8_HIGH:
						SET_BIT(DIO_u8_PORTC_REG, Copy_u8PinId);
     702:	25 b3       	in	r18, 0x15	; 21
     704:	81 e0       	ldi	r24, 0x01	; 1
     706:	90 e0       	ldi	r25, 0x00	; 0
     708:	02 c0       	rjmp	.+4      	; 0x70e <DIO_u8SetPinValue+0xbe>
     70a:	88 0f       	add	r24, r24
     70c:	99 1f       	adc	r25, r25
     70e:	6a 95       	dec	r22
     710:	e2 f7       	brpl	.-8      	; 0x70a <DIO_u8SetPinValue+0xba>
     712:	28 2b       	or	r18, r24
     714:	25 bb       	out	0x15, r18	; 21
     716:	1b c0       	rjmp	.+54     	; 0x74e <DIO_u8SetPinValue+0xfe>
					default:
						Local_u8ErrorState = STD_TYPES_NOK;
					}
					break;
					case DIO_u8_PORTD:
						switch (Copy_u8PinValue) {
     718:	44 23       	and	r20, r20
     71a:	19 f0       	breq	.+6      	; 0x722 <DIO_u8SetPinValue+0xd2>
     71c:	41 30       	cpi	r20, 0x01	; 1
     71e:	c9 f4       	brne	.+50     	; 0x752 <DIO_u8SetPinValue+0x102>
     720:	0c c0       	rjmp	.+24     	; 0x73a <DIO_u8SetPinValue+0xea>
						case DIO_u8_LOW:
							CLR_BIT(DIO_u8_PORTD_REG, Copy_u8PinId);
     722:	22 b3       	in	r18, 0x12	; 18
     724:	81 e0       	ldi	r24, 0x01	; 1
     726:	90 e0       	ldi	r25, 0x00	; 0
     728:	02 c0       	rjmp	.+4      	; 0x72e <DIO_u8SetPinValue+0xde>
     72a:	88 0f       	add	r24, r24
     72c:	99 1f       	adc	r25, r25
     72e:	6a 95       	dec	r22
     730:	e2 f7       	brpl	.-8      	; 0x72a <DIO_u8SetPinValue+0xda>
     732:	80 95       	com	r24
     734:	82 23       	and	r24, r18
     736:	82 bb       	out	0x12, r24	; 18
     738:	0a c0       	rjmp	.+20     	; 0x74e <DIO_u8SetPinValue+0xfe>
							break;
						case DIO_u8_HIGH:
							SET_BIT(DIO_u8_PORTD_REG, Copy_u8PinId);
     73a:	22 b3       	in	r18, 0x12	; 18
     73c:	81 e0       	ldi	r24, 0x01	; 1
     73e:	90 e0       	ldi	r25, 0x00	; 0
     740:	02 c0       	rjmp	.+4      	; 0x746 <DIO_u8SetPinValue+0xf6>
     742:	88 0f       	add	r24, r24
     744:	99 1f       	adc	r25, r25
     746:	6a 95       	dec	r22
     748:	e2 f7       	brpl	.-8      	; 0x742 <DIO_u8SetPinValue+0xf2>
     74a:	28 2b       	or	r18, r24
     74c:	22 bb       	out	0x12, r18	; 18
     74e:	81 e0       	ldi	r24, 0x01	; 1
     750:	08 95       	ret
							break;
     752:	80 e0       	ldi	r24, 0x00	; 0
		}
	} else {
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
     754:	08 95       	ret

00000756 <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId,
		u8 * Copy_Pu8ReturnedValue) {
     756:	fa 01       	movw	r30, r20
	u8 Local_u8ErrorState = STD_TYPES_OK;
	if ((Copy_u8PinId <= DIO_u8_PIN7) && (Copy_Pu8ReturnedValue != NULL)) {
     758:	68 30       	cpi	r22, 0x08	; 8
     75a:	e8 f4       	brcc	.+58     	; 0x796 <DIO_u8GetPinValue+0x40>
     75c:	41 15       	cp	r20, r1
     75e:	51 05       	cpc	r21, r1
     760:	d1 f0       	breq	.+52     	; 0x796 <DIO_u8GetPinValue+0x40>
		switch (Copy_u8PortId) {
     762:	81 30       	cpi	r24, 0x01	; 1
     764:	49 f0       	breq	.+18     	; 0x778 <DIO_u8GetPinValue+0x22>
     766:	81 30       	cpi	r24, 0x01	; 1
     768:	28 f0       	brcs	.+10     	; 0x774 <DIO_u8GetPinValue+0x1e>
     76a:	82 30       	cpi	r24, 0x02	; 2
     76c:	39 f0       	breq	.+14     	; 0x77c <DIO_u8GetPinValue+0x26>
     76e:	83 30       	cpi	r24, 0x03	; 3
     770:	91 f4       	brne	.+36     	; 0x796 <DIO_u8GetPinValue+0x40>
     772:	06 c0       	rjmp	.+12     	; 0x780 <DIO_u8GetPinValue+0x2a>
		case DIO_u8_PORTA:
			*Copy_Pu8ReturnedValue = GET_BIT(DIO_u8_PINA_REG, Copy_u8PinId);
     774:	89 b3       	in	r24, 0x19	; 25
     776:	05 c0       	rjmp	.+10     	; 0x782 <DIO_u8GetPinValue+0x2c>
			break;
		case DIO_u8_PORTB:
			*Copy_Pu8ReturnedValue = GET_BIT(DIO_u8_PINB_REG, Copy_u8PinId);
     778:	86 b3       	in	r24, 0x16	; 22
     77a:	03 c0       	rjmp	.+6      	; 0x782 <DIO_u8GetPinValue+0x2c>
			break;
		case DIO_u8_PORTC:
			*Copy_Pu8ReturnedValue = GET_BIT(DIO_u8_PINC_REG, Copy_u8PinId);
     77c:	83 b3       	in	r24, 0x13	; 19
     77e:	01 c0       	rjmp	.+2      	; 0x782 <DIO_u8GetPinValue+0x2c>
			break;
		case DIO_u8_PORTD:
			*Copy_Pu8ReturnedValue = GET_BIT(DIO_u8_PIND_REG, Copy_u8PinId);
     780:	80 b3       	in	r24, 0x10	; 16
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	02 c0       	rjmp	.+4      	; 0x78a <DIO_u8GetPinValue+0x34>
     786:	95 95       	asr	r25
     788:	87 95       	ror	r24
     78a:	6a 95       	dec	r22
     78c:	e2 f7       	brpl	.-8      	; 0x786 <DIO_u8GetPinValue+0x30>
     78e:	81 70       	andi	r24, 0x01	; 1
     790:	80 83       	st	Z, r24
     792:	81 e0       	ldi	r24, 0x01	; 1
     794:	08 95       	ret
			break;
     796:	80 e0       	ldi	r24, 0x00	; 0
		}
	} else {
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
     798:	08 95       	ret

0000079a <DIO_u8TogPinValue>:

u8 DIO_u8TogPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId) {
	u8 Local_u8ErrorState = STD_TYPES_OK;
	if (Copy_u8PinId <= DIO_u8_PIN7) {
     79a:	68 30       	cpi	r22, 0x08	; 8
     79c:	b0 f5       	brcc	.+108    	; 0x80a <DIO_u8TogPinValue+0x70>
		switch (Copy_u8PortId) {
     79e:	81 30       	cpi	r24, 0x01	; 1
     7a0:	91 f0       	breq	.+36     	; 0x7c6 <DIO_u8TogPinValue+0x2c>
     7a2:	81 30       	cpi	r24, 0x01	; 1
     7a4:	28 f0       	brcs	.+10     	; 0x7b0 <DIO_u8TogPinValue+0x16>
     7a6:	82 30       	cpi	r24, 0x02	; 2
     7a8:	c9 f0       	breq	.+50     	; 0x7dc <DIO_u8TogPinValue+0x42>
     7aa:	83 30       	cpi	r24, 0x03	; 3
     7ac:	71 f5       	brne	.+92     	; 0x80a <DIO_u8TogPinValue+0x70>
     7ae:	21 c0       	rjmp	.+66     	; 0x7f2 <DIO_u8TogPinValue+0x58>
		case DIO_u8_PORTA:
			TOG_BIT(DIO_u8_PORTA_REG, Copy_u8PinId);
     7b0:	2b b3       	in	r18, 0x1b	; 27
     7b2:	81 e0       	ldi	r24, 0x01	; 1
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	02 c0       	rjmp	.+4      	; 0x7bc <DIO_u8TogPinValue+0x22>
     7b8:	88 0f       	add	r24, r24
     7ba:	99 1f       	adc	r25, r25
     7bc:	6a 95       	dec	r22
     7be:	e2 f7       	brpl	.-8      	; 0x7b8 <DIO_u8TogPinValue+0x1e>
     7c0:	28 27       	eor	r18, r24
     7c2:	2b bb       	out	0x1b, r18	; 27
     7c4:	20 c0       	rjmp	.+64     	; 0x806 <DIO_u8TogPinValue+0x6c>
			break;
		case DIO_u8_PORTB:
			TOG_BIT(DIO_u8_PORTB_REG, Copy_u8PinId);
     7c6:	28 b3       	in	r18, 0x18	; 24
     7c8:	81 e0       	ldi	r24, 0x01	; 1
     7ca:	90 e0       	ldi	r25, 0x00	; 0
     7cc:	02 c0       	rjmp	.+4      	; 0x7d2 <DIO_u8TogPinValue+0x38>
     7ce:	88 0f       	add	r24, r24
     7d0:	99 1f       	adc	r25, r25
     7d2:	6a 95       	dec	r22
     7d4:	e2 f7       	brpl	.-8      	; 0x7ce <DIO_u8TogPinValue+0x34>
     7d6:	28 27       	eor	r18, r24
     7d8:	28 bb       	out	0x18, r18	; 24
     7da:	15 c0       	rjmp	.+42     	; 0x806 <DIO_u8TogPinValue+0x6c>
			break;
		case DIO_u8_PORTC:
			TOG_BIT(DIO_u8_PORTC_REG, Copy_u8PinId);
     7dc:	25 b3       	in	r18, 0x15	; 21
     7de:	81 e0       	ldi	r24, 0x01	; 1
     7e0:	90 e0       	ldi	r25, 0x00	; 0
     7e2:	02 c0       	rjmp	.+4      	; 0x7e8 <DIO_u8TogPinValue+0x4e>
     7e4:	88 0f       	add	r24, r24
     7e6:	99 1f       	adc	r25, r25
     7e8:	6a 95       	dec	r22
     7ea:	e2 f7       	brpl	.-8      	; 0x7e4 <DIO_u8TogPinValue+0x4a>
     7ec:	28 27       	eor	r18, r24
     7ee:	25 bb       	out	0x15, r18	; 21
     7f0:	0a c0       	rjmp	.+20     	; 0x806 <DIO_u8TogPinValue+0x6c>
			break;
		case DIO_u8_PORTD:
			TOG_BIT(DIO_u8_PORTD_REG, Copy_u8PinId);
     7f2:	22 b3       	in	r18, 0x12	; 18
     7f4:	81 e0       	ldi	r24, 0x01	; 1
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	02 c0       	rjmp	.+4      	; 0x7fe <DIO_u8TogPinValue+0x64>
     7fa:	88 0f       	add	r24, r24
     7fc:	99 1f       	adc	r25, r25
     7fe:	6a 95       	dec	r22
     800:	e2 f7       	brpl	.-8      	; 0x7fa <DIO_u8TogPinValue+0x60>
     802:	28 27       	eor	r18, r24
     804:	22 bb       	out	0x12, r18	; 18
     806:	81 e0       	ldi	r24, 0x01	; 1
     808:	08 95       	ret
			break;
     80a:	80 e0       	ldi	r24, 0x00	; 0
		}
	} else {
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
     80c:	08 95       	ret

0000080e <DIO_u8SetPortDirection>:

u8 DIO_u8SetPortDirection(u8 Copy_u8PortId, u8 Copy_u8PortDirection) {
	u8 Local_u8ErrorState = STD_TYPES_OK;
	switch (Copy_u8PortId) {
     80e:	81 30       	cpi	r24, 0x01	; 1
     810:	c1 f0       	breq	.+48     	; 0x842 <DIO_u8SetPortDirection+0x34>
     812:	81 30       	cpi	r24, 0x01	; 1
     814:	30 f0       	brcs	.+12     	; 0x822 <DIO_u8SetPortDirection+0x14>
     816:	82 30       	cpi	r24, 0x02	; 2
     818:	21 f1       	breq	.+72     	; 0x862 <__stack+0x3>
     81a:	83 30       	cpi	r24, 0x03	; 3
     81c:	09 f0       	breq	.+2      	; 0x820 <DIO_u8SetPortDirection+0x12>
     81e:	42 c0       	rjmp	.+132    	; 0x8a4 <__stack+0x45>
     820:	30 c0       	rjmp	.+96     	; 0x882 <__stack+0x23>
	case DIO_u8_PORTA:
		switch (Copy_u8PortDirection) {
     822:	61 30       	cpi	r22, 0x01	; 1
     824:	29 f0       	breq	.+10     	; 0x830 <DIO_u8SetPortDirection+0x22>
     826:	61 30       	cpi	r22, 0x01	; 1
     828:	30 f0       	brcs	.+12     	; 0x836 <DIO_u8SetPortDirection+0x28>
     82a:	62 30       	cpi	r22, 0x02	; 2
     82c:	d9 f5       	brne	.+118    	; 0x8a4 <__stack+0x45>
     82e:	05 c0       	rjmp	.+10     	; 0x83a <DIO_u8SetPortDirection+0x2c>
		case DIO_u8_OUTPUT:
			DIO_u8_DDRA_REG = 0xff;
     830:	8f ef       	ldi	r24, 0xFF	; 255
     832:	8a bb       	out	0x1a, r24	; 26
     834:	35 c0       	rjmp	.+106    	; 0x8a0 <__stack+0x41>
			break;
		case DIO_u8_INPUT_FLOATING:
			DIO_u8_DDRA_REG = 0;
     836:	1a ba       	out	0x1a, r1	; 26
     838:	33 c0       	rjmp	.+102    	; 0x8a0 <__stack+0x41>
			break;
		case DIO_u8_INPUT_PULLED_UP:
			DIO_u8_DDRA_REG = 0;
     83a:	1a ba       	out	0x1a, r1	; 26
			DIO_u8_PORTA_REG = 0xff;
     83c:	8f ef       	ldi	r24, 0xFF	; 255
     83e:	8b bb       	out	0x1b, r24	; 27
     840:	2f c0       	rjmp	.+94     	; 0x8a0 <__stack+0x41>
		default:
			Local_u8ErrorState = STD_TYPES_NOK;
		}
		break;
		case DIO_u8_PORTB:
			switch (Copy_u8PortDirection) {
     842:	61 30       	cpi	r22, 0x01	; 1
     844:	29 f0       	breq	.+10     	; 0x850 <DIO_u8SetPortDirection+0x42>
     846:	61 30       	cpi	r22, 0x01	; 1
     848:	30 f0       	brcs	.+12     	; 0x856 <DIO_u8SetPortDirection+0x48>
     84a:	62 30       	cpi	r22, 0x02	; 2
     84c:	59 f5       	brne	.+86     	; 0x8a4 <__stack+0x45>
     84e:	05 c0       	rjmp	.+10     	; 0x85a <DIO_u8SetPortDirection+0x4c>
			case DIO_u8_OUTPUT:
				DIO_u8_DDRB_REG = 0xff;
     850:	8f ef       	ldi	r24, 0xFF	; 255
     852:	87 bb       	out	0x17, r24	; 23
     854:	25 c0       	rjmp	.+74     	; 0x8a0 <__stack+0x41>
				break;
			case DIO_u8_INPUT_FLOATING:
				DIO_u8_DDRB_REG = 0;
     856:	17 ba       	out	0x17, r1	; 23
     858:	23 c0       	rjmp	.+70     	; 0x8a0 <__stack+0x41>
				break;
			case DIO_u8_INPUT_PULLED_UP:
				DIO_u8_DDRB_REG = 0;
     85a:	17 ba       	out	0x17, r1	; 23
				DIO_u8_PORTB_REG = 0xff;
     85c:	8f ef       	ldi	r24, 0xFF	; 255
     85e:	88 bb       	out	0x18, r24	; 24
     860:	1f c0       	rjmp	.+62     	; 0x8a0 <__stack+0x41>
			default:
				Local_u8ErrorState = STD_TYPES_NOK;
			}
			break;
			case DIO_u8_PORTC:
				switch (Copy_u8PortDirection) {
     862:	61 30       	cpi	r22, 0x01	; 1
     864:	29 f0       	breq	.+10     	; 0x870 <__stack+0x11>
     866:	61 30       	cpi	r22, 0x01	; 1
     868:	30 f0       	brcs	.+12     	; 0x876 <__stack+0x17>
     86a:	62 30       	cpi	r22, 0x02	; 2
     86c:	d9 f4       	brne	.+54     	; 0x8a4 <__stack+0x45>
     86e:	05 c0       	rjmp	.+10     	; 0x87a <__stack+0x1b>
				case DIO_u8_OUTPUT:
					DIO_u8_DDRC_REG = 0xff;
     870:	8f ef       	ldi	r24, 0xFF	; 255
     872:	84 bb       	out	0x14, r24	; 20
     874:	15 c0       	rjmp	.+42     	; 0x8a0 <__stack+0x41>
					break;
				case DIO_u8_INPUT_FLOATING:
					DIO_u8_DDRC_REG = 0;
     876:	14 ba       	out	0x14, r1	; 20
     878:	13 c0       	rjmp	.+38     	; 0x8a0 <__stack+0x41>
					break;
				case DIO_u8_INPUT_PULLED_UP:
					DIO_u8_DDRC_REG = 0;
     87a:	14 ba       	out	0x14, r1	; 20
					DIO_u8_PORTC_REG = 0xff;
     87c:	8f ef       	ldi	r24, 0xFF	; 255
     87e:	85 bb       	out	0x15, r24	; 21
     880:	0f c0       	rjmp	.+30     	; 0x8a0 <__stack+0x41>
				default:
					Local_u8ErrorState = STD_TYPES_NOK;
				}
				break;
				case DIO_u8_PORTD:
					switch (Copy_u8PortDirection) {
     882:	61 30       	cpi	r22, 0x01	; 1
     884:	29 f0       	breq	.+10     	; 0x890 <__stack+0x31>
     886:	61 30       	cpi	r22, 0x01	; 1
     888:	30 f0       	brcs	.+12     	; 0x896 <__stack+0x37>
     88a:	62 30       	cpi	r22, 0x02	; 2
     88c:	59 f4       	brne	.+22     	; 0x8a4 <__stack+0x45>
     88e:	05 c0       	rjmp	.+10     	; 0x89a <__stack+0x3b>
					case DIO_u8_OUTPUT:
						DIO_u8_DDRD_REG = 0xff;
     890:	8f ef       	ldi	r24, 0xFF	; 255
     892:	81 bb       	out	0x11, r24	; 17
     894:	05 c0       	rjmp	.+10     	; 0x8a0 <__stack+0x41>
						break;
					case DIO_u8_INPUT_FLOATING:
						DIO_u8_DDRD_REG = 0;
     896:	11 ba       	out	0x11, r1	; 17
     898:	03 c0       	rjmp	.+6      	; 0x8a0 <__stack+0x41>
						break;
					case DIO_u8_INPUT_PULLED_UP:
						DIO_u8_DDRD_REG = 0;
     89a:	11 ba       	out	0x11, r1	; 17
						DIO_u8_PORTD_REG = 0xff;
     89c:	8f ef       	ldi	r24, 0xFF	; 255
     89e:	82 bb       	out	0x12, r24	; 18
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	08 95       	ret
						break;/* Activate Pull up resistor */
     8a4:	80 e0       	ldi	r24, 0x00	; 0
					break;
					default:
						Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
     8a6:	08 95       	ret

000008a8 <DIO_u8SetPortValue>:

u8 DIO_u8SetPortValue(u8 Copy_u8PortId, u8 Copy_u8PortValue){
	u8 Local_u8ErrorState = STD_TYPES_OK;
	switch (Copy_u8PortId){
     8a8:	81 30       	cpi	r24, 0x01	; 1
     8aa:	51 f0       	breq	.+20     	; 0x8c0 <DIO_u8SetPortValue+0x18>
     8ac:	81 30       	cpi	r24, 0x01	; 1
     8ae:	30 f0       	brcs	.+12     	; 0x8bc <DIO_u8SetPortValue+0x14>
     8b0:	82 30       	cpi	r24, 0x02	; 2
     8b2:	41 f0       	breq	.+16     	; 0x8c4 <DIO_u8SetPortValue+0x1c>
     8b4:	83 30       	cpi	r24, 0x03	; 3
     8b6:	49 f0       	breq	.+18     	; 0x8ca <DIO_u8SetPortValue+0x22>
     8b8:	80 e0       	ldi	r24, 0x00	; 0
     8ba:	08 95       	ret
	case DIO_u8_PORTA: DIO_u8_PORTA_REG = Copy_u8PortValue;break;
     8bc:	6b bb       	out	0x1b, r22	; 27
     8be:	03 c0       	rjmp	.+6      	; 0x8c6 <DIO_u8SetPortValue+0x1e>
	case DIO_u8_PORTB: DIO_u8_PORTB_REG = Copy_u8PortValue;break;
     8c0:	68 bb       	out	0x18, r22	; 24
     8c2:	01 c0       	rjmp	.+2      	; 0x8c6 <DIO_u8SetPortValue+0x1e>
	case DIO_u8_PORTC: DIO_u8_PORTC_REG = Copy_u8PortValue;break;
     8c4:	65 bb       	out	0x15, r22	; 21
     8c6:	81 e0       	ldi	r24, 0x01	; 1
     8c8:	08 95       	ret
	case DIO_u8_PORTD: DIO_u8_PORTD_REG = Copy_u8PortValue;break;
     8ca:	62 bb       	out	0x12, r22	; 18
     8cc:	81 e0       	ldi	r24, 0x01	; 1
	default          : Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
     8ce:	08 95       	ret

000008d0 <DIO_u8GetPortValue>:

u8 DIO_u8GetPortValue(u8 Copy_u8PortId, u8 * Copy_Pu8ReturnedPortValue){
     8d0:	fb 01       	movw	r30, r22
	u8 Local_u8ErrorState = STD_TYPES_OK;
	if(Copy_Pu8ReturnedPortValue != NULL){
     8d2:	61 15       	cp	r22, r1
     8d4:	71 05       	cpc	r23, r1
     8d6:	99 f0       	breq	.+38     	; 0x8fe <DIO_u8GetPortValue+0x2e>
		switch (Copy_u8PortId){
     8d8:	81 30       	cpi	r24, 0x01	; 1
     8da:	49 f0       	breq	.+18     	; 0x8ee <DIO_u8GetPortValue+0x1e>
     8dc:	81 30       	cpi	r24, 0x01	; 1
     8de:	28 f0       	brcs	.+10     	; 0x8ea <DIO_u8GetPortValue+0x1a>
     8e0:	82 30       	cpi	r24, 0x02	; 2
     8e2:	39 f0       	breq	.+14     	; 0x8f2 <DIO_u8GetPortValue+0x22>
     8e4:	83 30       	cpi	r24, 0x03	; 3
     8e6:	59 f4       	brne	.+22     	; 0x8fe <DIO_u8GetPortValue+0x2e>
     8e8:	06 c0       	rjmp	.+12     	; 0x8f6 <DIO_u8GetPortValue+0x26>
		case DIO_u8_PORTA: *Copy_Pu8ReturnedPortValue = DIO_u8_PINA_REG;break;
     8ea:	89 b3       	in	r24, 0x19	; 25
     8ec:	05 c0       	rjmp	.+10     	; 0x8f8 <DIO_u8GetPortValue+0x28>
		case DIO_u8_PORTB: *Copy_Pu8ReturnedPortValue = DIO_u8_PINB_REG;break;
     8ee:	86 b3       	in	r24, 0x16	; 22
     8f0:	03 c0       	rjmp	.+6      	; 0x8f8 <DIO_u8GetPortValue+0x28>
		case DIO_u8_PORTC: *Copy_Pu8ReturnedPortValue = DIO_u8_PINC_REG;break;
     8f2:	83 b3       	in	r24, 0x13	; 19
     8f4:	01 c0       	rjmp	.+2      	; 0x8f8 <DIO_u8GetPortValue+0x28>
		case DIO_u8_PORTD: *Copy_Pu8ReturnedPortValue = DIO_u8_PIND_REG;break;
     8f6:	80 b3       	in	r24, 0x10	; 16
     8f8:	80 83       	st	Z, r24
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	08 95       	ret
     8fe:	80 e0       	ldi	r24, 0x00	; 0
	}
	else{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
     900:	08 95       	ret

00000902 <DIO_void_Set4Bits_Value>:
void DIO_void_Set4Bits_Value(u8 Copy_u8PortId, u8 Copy_u8PortValue)
{
	switch(Copy_u8PortId)
     902:	81 30       	cpi	r24, 0x01	; 1
     904:	79 f0       	breq	.+30     	; 0x924 <DIO_void_Set4Bits_Value+0x22>
     906:	81 30       	cpi	r24, 0x01	; 1
     908:	28 f0       	brcs	.+10     	; 0x914 <DIO_void_Set4Bits_Value+0x12>
     90a:	82 30       	cpi	r24, 0x02	; 2
     90c:	99 f0       	breq	.+38     	; 0x934 <DIO_void_Set4Bits_Value+0x32>
     90e:	83 30       	cpi	r24, 0x03	; 3
     910:	01 f5       	brne	.+64     	; 0x952 <DIO_void_Set4Bits_Value+0x50>
     912:	18 c0       	rjmp	.+48     	; 0x944 <DIO_void_Set4Bits_Value+0x42>
		{
		case DIO_u8_PORTA:
			DIO_u8_PORTA_REG &= 0b10000111;
     914:	8b b3       	in	r24, 0x1b	; 27
     916:	87 78       	andi	r24, 0x87	; 135
     918:	8b bb       	out	0x1b, r24	; 27
			DIO_u8_PORTA_REG |= (Copy_u8PortValue>> 1);
     91a:	8b b3       	in	r24, 0x1b	; 27
     91c:	66 95       	lsr	r22
     91e:	86 2b       	or	r24, r22
     920:	8b bb       	out	0x1b, r24	; 27
     922:	08 95       	ret
			break;
		case DIO_u8_PORTB:
			DIO_u8_PORTB_REG &= 0b10000111;
     924:	88 b3       	in	r24, 0x18	; 24
     926:	87 78       	andi	r24, 0x87	; 135
     928:	88 bb       	out	0x18, r24	; 24
			DIO_u8_PORTB_REG |= (Copy_u8PortValue>> 1);
     92a:	88 b3       	in	r24, 0x18	; 24
     92c:	66 95       	lsr	r22
     92e:	86 2b       	or	r24, r22
     930:	88 bb       	out	0x18, r24	; 24
     932:	08 95       	ret
			break;
		case DIO_u8_PORTC:
			DIO_u8_PORTC_REG &=0b10000111;
     934:	85 b3       	in	r24, 0x15	; 21
     936:	87 78       	andi	r24, 0x87	; 135
     938:	85 bb       	out	0x15, r24	; 21
			DIO_u8_PORTC_REG |= (Copy_u8PortValue>> 1);
     93a:	85 b3       	in	r24, 0x15	; 21
     93c:	66 95       	lsr	r22
     93e:	86 2b       	or	r24, r22
     940:	85 bb       	out	0x15, r24	; 21
     942:	08 95       	ret
			break;
		case DIO_u8_PORTD:
			DIO_u8_PORTD_REG &= 0b10000111;
     944:	82 b3       	in	r24, 0x12	; 18
     946:	87 78       	andi	r24, 0x87	; 135
     948:	82 bb       	out	0x12, r24	; 18
			DIO_u8_PORTD_REG |= (Copy_u8PortValue>> 1);
     94a:	82 b3       	in	r24, 0x12	; 18
     94c:	66 95       	lsr	r22
     94e:	86 2b       	or	r24, r22
     950:	82 bb       	out	0x12, r24	; 18
     952:	08 95       	ret

00000954 <HSSD_BCD_voidSetNumber>:
		break;
	}
}

void HSSD_BCD_voidSetNumber(u8 copy_u8Number,u8 copy_u8Port)
{
     954:	98 2f       	mov	r25, r24
	switch(copy_u8Port)
     956:	61 30       	cpi	r22, 0x01	; 1
     958:	49 f0       	breq	.+18     	; 0x96c <HSSD_BCD_voidSetNumber+0x18>
     95a:	61 30       	cpi	r22, 0x01	; 1
     95c:	28 f0       	brcs	.+10     	; 0x968 <HSSD_BCD_voidSetNumber+0x14>
     95e:	62 30       	cpi	r22, 0x02	; 2
     960:	39 f0       	breq	.+14     	; 0x970 <HSSD_BCD_voidSetNumber+0x1c>
     962:	63 30       	cpi	r22, 0x03	; 3
     964:	71 f4       	brne	.+28     	; 0x982 <HSSD_BCD_voidSetNumber+0x2e>
     966:	09 c0       	rjmp	.+18     	; 0x97a <HSSD_BCD_voidSetNumber+0x26>
	{
	case DIO_u8_PORTA:DIO_u8SetPortValue(DIO_u8_PORTA,copy_u8Number);break;
     968:	80 e0       	ldi	r24, 0x00	; 0
     96a:	03 c0       	rjmp	.+6      	; 0x972 <HSSD_BCD_voidSetNumber+0x1e>
	case DIO_u8_PORTB:DIO_u8SetPortValue(DIO_u8_PORTB,copy_u8Number);break;
     96c:	81 e0       	ldi	r24, 0x01	; 1
     96e:	01 c0       	rjmp	.+2      	; 0x972 <HSSD_BCD_voidSetNumber+0x1e>
	case DIO_u8_PORTC:DIO_u8SetPortValue(DIO_u8_PORTC,copy_u8Number);break;
     970:	82 e0       	ldi	r24, 0x02	; 2
     972:	69 2f       	mov	r22, r25
     974:	0e 94 54 04 	call	0x8a8	; 0x8a8 <DIO_u8SetPortValue>
     978:	08 95       	ret
	case DIO_u8_PORTD:DIO_u8SetPortValue(DIO_u8_PORTD,copy_u8Number);break;
     97a:	83 e0       	ldi	r24, 0x03	; 3
     97c:	69 2f       	mov	r22, r25
     97e:	0e 94 54 04 	call	0x8a8	; 0x8a8 <DIO_u8SetPortValue>
     982:	08 95       	ret

00000984 <HSSD_voidSetNumber>:
#include "HSSD_interface.h"
#include "HSSD_private.h"

void HSSD_voidSetNumber(u8 copy_u8Number,u8 copy_u8Port,u8 copy_u8Type)
{
	switch(copy_u8Type)
     984:	44 23       	and	r20, r20
     986:	21 f0       	breq	.+8      	; 0x990 <HSSD_voidSetNumber+0xc>
     988:	41 30       	cpi	r20, 0x01	; 1
     98a:	09 f0       	breq	.+2      	; 0x98e <HSSD_voidSetNumber+0xa>
     98c:	54 c0       	rjmp	.+168    	; 0xa36 <HSSD_voidSetNumber+0xb2>
     98e:	23 c0       	rjmp	.+70     	; 0x9d6 <HSSD_voidSetNumber+0x52>
	{
	case HSSD_CA_TYPE:
		switch(copy_u8Port)
     990:	61 30       	cpi	r22, 0x01	; 1
     992:	71 f0       	breq	.+28     	; 0x9b0 <HSSD_voidSetNumber+0x2c>
     994:	61 30       	cpi	r22, 0x01	; 1
     996:	30 f0       	brcs	.+12     	; 0x9a4 <HSSD_voidSetNumber+0x20>
     998:	62 30       	cpi	r22, 0x02	; 2
     99a:	81 f0       	breq	.+32     	; 0x9bc <HSSD_voidSetNumber+0x38>
     99c:	63 30       	cpi	r22, 0x03	; 3
     99e:	09 f0       	breq	.+2      	; 0x9a2 <HSSD_voidSetNumber+0x1e>
     9a0:	4a c0       	rjmp	.+148    	; 0xa36 <HSSD_voidSetNumber+0xb2>
     9a2:	13 c0       	rjmp	.+38     	; 0x9ca <HSSD_voidSetNumber+0x46>
		{
		case DIO_u8_PORTA:DIO_u8SetPortValue(DIO_u8_PORTA,CA_ptterns[copy_u8Number]);break;
     9a4:	e8 2f       	mov	r30, r24
     9a6:	f0 e0       	ldi	r31, 0x00	; 0
     9a8:	e7 52       	subi	r30, 0x27	; 39
     9aa:	ff 4f       	sbci	r31, 0xFF	; 255
     9ac:	80 e0       	ldi	r24, 0x00	; 0
     9ae:	0b c0       	rjmp	.+22     	; 0x9c6 <HSSD_voidSetNumber+0x42>
		case DIO_u8_PORTB:DIO_u8SetPortValue(DIO_u8_PORTB,CA_ptterns[copy_u8Number]);break;
     9b0:	e8 2f       	mov	r30, r24
     9b2:	f0 e0       	ldi	r31, 0x00	; 0
     9b4:	e7 52       	subi	r30, 0x27	; 39
     9b6:	ff 4f       	sbci	r31, 0xFF	; 255
     9b8:	81 e0       	ldi	r24, 0x01	; 1
     9ba:	05 c0       	rjmp	.+10     	; 0x9c6 <HSSD_voidSetNumber+0x42>
		case DIO_u8_PORTC:DIO_u8SetPortValue(DIO_u8_PORTC,CA_ptterns[copy_u8Number]);break;
     9bc:	e8 2f       	mov	r30, r24
     9be:	f0 e0       	ldi	r31, 0x00	; 0
     9c0:	e7 52       	subi	r30, 0x27	; 39
     9c2:	ff 4f       	sbci	r31, 0xFF	; 255
     9c4:	82 e0       	ldi	r24, 0x02	; 2
     9c6:	60 81       	ld	r22, Z
     9c8:	29 c0       	rjmp	.+82     	; 0xa1c <HSSD_voidSetNumber+0x98>
		case DIO_u8_PORTD:DIO_u8SetPortValue(DIO_u8_PORTD,CA_ptterns[copy_u8Number]);break;
     9ca:	e8 2f       	mov	r30, r24
     9cc:	f0 e0       	ldi	r31, 0x00	; 0
     9ce:	e7 52       	subi	r30, 0x27	; 39
     9d0:	ff 4f       	sbci	r31, 0xFF	; 255
     9d2:	83 e0       	ldi	r24, 0x03	; 3
     9d4:	f8 cf       	rjmp	.-16     	; 0x9c6 <HSSD_voidSetNumber+0x42>
		}
		break;
	case HSSD_CC_TYPE:
		switch(copy_u8Port)
     9d6:	61 30       	cpi	r22, 0x01	; 1
     9d8:	81 f0       	breq	.+32     	; 0x9fa <HSSD_voidSetNumber+0x76>
     9da:	61 30       	cpi	r22, 0x01	; 1
     9dc:	28 f0       	brcs	.+10     	; 0x9e8 <HSSD_voidSetNumber+0x64>
     9de:	62 30       	cpi	r22, 0x02	; 2
     9e0:	a9 f0       	breq	.+42     	; 0xa0c <HSSD_voidSetNumber+0x88>
     9e2:	63 30       	cpi	r22, 0x03	; 3
     9e4:	41 f5       	brne	.+80     	; 0xa36 <HSSD_voidSetNumber+0xb2>
     9e6:	1d c0       	rjmp	.+58     	; 0xa22 <HSSD_voidSetNumber+0x9e>
		{
		case DIO_u8_PORTA:DIO_u8SetPortValue(DIO_u8_PORTA,~CA_ptterns[copy_u8Number] << 1);break;
     9e8:	e8 2f       	mov	r30, r24
     9ea:	f0 e0       	ldi	r31, 0x00	; 0
     9ec:	e7 52       	subi	r30, 0x27	; 39
     9ee:	ff 4f       	sbci	r31, 0xFF	; 255
     9f0:	60 81       	ld	r22, Z
     9f2:	60 95       	com	r22
     9f4:	66 0f       	add	r22, r22
     9f6:	80 e0       	ldi	r24, 0x00	; 0
     9f8:	11 c0       	rjmp	.+34     	; 0xa1c <HSSD_voidSetNumber+0x98>
		case DIO_u8_PORTB:DIO_u8SetPortValue(DIO_u8_PORTB,~CA_ptterns[copy_u8Number] << 1);break;
     9fa:	e8 2f       	mov	r30, r24
     9fc:	f0 e0       	ldi	r31, 0x00	; 0
     9fe:	e7 52       	subi	r30, 0x27	; 39
     a00:	ff 4f       	sbci	r31, 0xFF	; 255
     a02:	60 81       	ld	r22, Z
     a04:	60 95       	com	r22
     a06:	66 0f       	add	r22, r22
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	08 c0       	rjmp	.+16     	; 0xa1c <HSSD_voidSetNumber+0x98>
		case DIO_u8_PORTC:DIO_u8SetPortValue(DIO_u8_PORTC,~CA_ptterns[copy_u8Number] << 1);break;
     a0c:	e8 2f       	mov	r30, r24
     a0e:	f0 e0       	ldi	r31, 0x00	; 0
     a10:	e7 52       	subi	r30, 0x27	; 39
     a12:	ff 4f       	sbci	r31, 0xFF	; 255
     a14:	60 81       	ld	r22, Z
     a16:	60 95       	com	r22
     a18:	66 0f       	add	r22, r22
     a1a:	82 e0       	ldi	r24, 0x02	; 2
     a1c:	0e 94 54 04 	call	0x8a8	; 0x8a8 <DIO_u8SetPortValue>
     a20:	08 95       	ret
		case DIO_u8_PORTD:DIO_u8SetPortValue(DIO_u8_PORTD,~CA_ptterns[copy_u8Number] << 1);break;
     a22:	e8 2f       	mov	r30, r24
     a24:	f0 e0       	ldi	r31, 0x00	; 0
     a26:	e7 52       	subi	r30, 0x27	; 39
     a28:	ff 4f       	sbci	r31, 0xFF	; 255
     a2a:	60 81       	ld	r22, Z
     a2c:	60 95       	com	r22
     a2e:	66 0f       	add	r22, r22
     a30:	83 e0       	ldi	r24, 0x03	; 3
     a32:	0e 94 54 04 	call	0x8a8	; 0x8a8 <DIO_u8SetPortValue>
     a36:	08 95       	ret

00000a38 <HLED_voidTogLed>:
	case LED2:DIO_u8SetPinValue(HLED_LED2,HLED_LED2_PIN,DIO_u8_LOW);break;
	}
}

void HLED_voidTogLed(u8 led_num){
	switch(led_num){
     a38:	81 30       	cpi	r24, 0x01	; 1
     a3a:	41 f0       	breq	.+16     	; 0xa4c <HLED_voidTogLed+0x14>
     a3c:	81 30       	cpi	r24, 0x01	; 1
     a3e:	18 f0       	brcs	.+6      	; 0xa46 <HLED_voidTogLed+0xe>
     a40:	82 30       	cpi	r24, 0x02	; 2
     a42:	69 f4       	brne	.+26     	; 0xa5e <HLED_voidTogLed+0x26>
     a44:	08 c0       	rjmp	.+16     	; 0xa56 <HLED_voidTogLed+0x1e>
	case LED0:DIO_u8TogPinValue(HLED_LED0,HLED_LED0_PIN);break;
     a46:	82 e0       	ldi	r24, 0x02	; 2
     a48:	60 e0       	ldi	r22, 0x00	; 0
     a4a:	02 c0       	rjmp	.+4      	; 0xa50 <HLED_voidTogLed+0x18>
	case LED1:DIO_u8TogPinValue(HLED_LED1,HLED_LED1_PIN);break;
     a4c:	82 e0       	ldi	r24, 0x02	; 2
     a4e:	61 e0       	ldi	r22, 0x01	; 1
     a50:	0e 94 cd 03 	call	0x79a	; 0x79a <DIO_u8TogPinValue>
     a54:	08 95       	ret
	case LED2:DIO_u8TogPinValue(HLED_LED2,HLED_LED2_PIN);break;
     a56:	82 e0       	ldi	r24, 0x02	; 2
     a58:	62 e0       	ldi	r22, 0x02	; 2
     a5a:	0e 94 cd 03 	call	0x79a	; 0x79a <DIO_u8TogPinValue>
     a5e:	08 95       	ret

00000a60 <HLED_voidTurnOFF>:
	case LED2:DIO_u8SetPinValue(HLED_LED2,HLED_LED2_PIN,DIO_u8_HIGH);break;
	}
}

void HLED_voidTurnOFF(u8 led_num){
	switch(led_num){
     a60:	81 30       	cpi	r24, 0x01	; 1
     a62:	41 f0       	breq	.+16     	; 0xa74 <HLED_voidTurnOFF+0x14>
     a64:	81 30       	cpi	r24, 0x01	; 1
     a66:	18 f0       	brcs	.+6      	; 0xa6e <HLED_voidTurnOFF+0xe>
     a68:	82 30       	cpi	r24, 0x02	; 2
     a6a:	79 f4       	brne	.+30     	; 0xa8a <HLED_voidTurnOFF+0x2a>
     a6c:	09 c0       	rjmp	.+18     	; 0xa80 <HLED_voidTurnOFF+0x20>
	case LED0:DIO_u8SetPinValue(HLED_LED0,HLED_LED0_PIN,DIO_u8_LOW);break;
     a6e:	82 e0       	ldi	r24, 0x02	; 2
     a70:	60 e0       	ldi	r22, 0x00	; 0
     a72:	02 c0       	rjmp	.+4      	; 0xa78 <HLED_voidTurnOFF+0x18>
	case LED1:DIO_u8SetPinValue(HLED_LED1,HLED_LED1_PIN,DIO_u8_LOW);break;
     a74:	82 e0       	ldi	r24, 0x02	; 2
     a76:	61 e0       	ldi	r22, 0x01	; 1
     a78:	40 e0       	ldi	r20, 0x00	; 0
     a7a:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
     a7e:	08 95       	ret
	case LED2:DIO_u8SetPinValue(HLED_LED2,HLED_LED2_PIN,DIO_u8_LOW);break;
     a80:	82 e0       	ldi	r24, 0x02	; 2
     a82:	62 e0       	ldi	r22, 0x02	; 2
     a84:	40 e0       	ldi	r20, 0x00	; 0
     a86:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
     a8a:	08 95       	ret

00000a8c <HLED_voidTurnON>:
	case LED2:DIO_u8SetPinDirection(HLED_LED2,HLED_LED2_PIN,DIO_u8_OUTPUT);break;
	}
}

void HLED_voidTurnON(u8 led_num){
	switch(led_num){
     a8c:	81 30       	cpi	r24, 0x01	; 1
     a8e:	41 f0       	breq	.+16     	; 0xaa0 <HLED_voidTurnON+0x14>
     a90:	81 30       	cpi	r24, 0x01	; 1
     a92:	18 f0       	brcs	.+6      	; 0xa9a <HLED_voidTurnON+0xe>
     a94:	82 30       	cpi	r24, 0x02	; 2
     a96:	79 f4       	brne	.+30     	; 0xab6 <HLED_voidTurnON+0x2a>
     a98:	09 c0       	rjmp	.+18     	; 0xaac <HLED_voidTurnON+0x20>
	case LED0:DIO_u8SetPinValue(HLED_LED0,HLED_LED0_PIN,DIO_u8_HIGH);break;
     a9a:	82 e0       	ldi	r24, 0x02	; 2
     a9c:	60 e0       	ldi	r22, 0x00	; 0
     a9e:	02 c0       	rjmp	.+4      	; 0xaa4 <HLED_voidTurnON+0x18>
	case LED1:DIO_u8SetPinValue(HLED_LED1,HLED_LED1_PIN,DIO_u8_HIGH);break;
     aa0:	82 e0       	ldi	r24, 0x02	; 2
     aa2:	61 e0       	ldi	r22, 0x01	; 1
     aa4:	41 e0       	ldi	r20, 0x01	; 1
     aa6:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
     aaa:	08 95       	ret
	case LED2:DIO_u8SetPinValue(HLED_LED2,HLED_LED2_PIN,DIO_u8_HIGH);break;
     aac:	82 e0       	ldi	r24, 0x02	; 2
     aae:	62 e0       	ldi	r22, 0x02	; 2
     ab0:	41 e0       	ldi	r20, 0x01	; 1
     ab2:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
     ab6:	08 95       	ret

00000ab8 <HLED_voidLedInit>:
#include "DIO_interface.h"
#include "HLED_config.h"
#include "HLED_interface.h"

void HLED_voidLedInit(u8 led_num){
	switch(led_num){
     ab8:	81 30       	cpi	r24, 0x01	; 1
     aba:	41 f0       	breq	.+16     	; 0xacc <HLED_voidLedInit+0x14>
     abc:	81 30       	cpi	r24, 0x01	; 1
     abe:	18 f0       	brcs	.+6      	; 0xac6 <HLED_voidLedInit+0xe>
     ac0:	82 30       	cpi	r24, 0x02	; 2
     ac2:	79 f4       	brne	.+30     	; 0xae2 <HLED_voidLedInit+0x2a>
     ac4:	09 c0       	rjmp	.+18     	; 0xad8 <HLED_voidLedInit+0x20>
	case LED0:DIO_u8SetPinDirection(HLED_LED0,HLED_LED0_PIN,DIO_u8_OUTPUT);break;
     ac6:	82 e0       	ldi	r24, 0x02	; 2
     ac8:	60 e0       	ldi	r22, 0x00	; 0
     aca:	02 c0       	rjmp	.+4      	; 0xad0 <HLED_voidLedInit+0x18>
	case LED1:DIO_u8SetPinDirection(HLED_LED1,HLED_LED1_PIN,DIO_u8_OUTPUT);break;
     acc:	82 e0       	ldi	r24, 0x02	; 2
     ace:	61 e0       	ldi	r22, 0x01	; 1
     ad0:	41 e0       	ldi	r20, 0x01	; 1
     ad2:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
     ad6:	08 95       	ret
	case LED2:DIO_u8SetPinDirection(HLED_LED2,HLED_LED2_PIN,DIO_u8_OUTPUT);break;
     ad8:	82 e0       	ldi	r24, 0x02	; 2
     ada:	62 e0       	ldi	r22, 0x02	; 2
     adc:	41 e0       	ldi	r20, 0x01	; 1
     ade:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
     ae2:	08 95       	ret

00000ae4 <HLCD_voidSendData>:
	_delay_ms(5);
	/*step 5 : Disable E pin */
	DIO_u8SetPinValue(PORT_CONTROL, HLCD_E_PIN, DIO_u8_LOW);

}
void HLCD_voidSendData(u8 copy_u8Data) {
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	08 2f       	mov	r16, r24
	/*step 1: select RS to be in data mode*/
	DIO_u8SetPinValue(PORT_CONTROL, HLCD_RS_PIN, DIO_u8_HIGH);
     aee:	80 e0       	ldi	r24, 0x00	; 0
     af0:	61 e0       	ldi	r22, 0x01	; 1
     af2:	41 e0       	ldi	r20, 0x01	; 1
     af4:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(PORT_CONTROL,HLCD_E_PIN,DIO_u8_LOW);
#elif(FUNCTION_SET == FUNCTION_SET_4BIT_MODE_2LINES || FUNCTION_SET ==  FUNCTION_SET_4BIT_MODE_1LINES)
	/*send high nibble*/
	u8 temp = copy_u8Data;
	temp = temp & 0xF0;
	DIO_void_Set4Bits_Value(PORT_DATA, temp); //HIGH
     af8:	60 2f       	mov	r22, r16
     afa:	60 7f       	andi	r22, 0xF0	; 240
     afc:	81 e0       	ldi	r24, 0x01	; 1
     afe:	0e 94 81 04 	call	0x902	; 0x902 <DIO_void_Set4Bits_Value>

	/*step 4: Enable E pin */
	DIO_u8SetPinValue(PORT_CONTROL, HLCD_E_PIN, DIO_u8_HIGH);
     b02:	80 e0       	ldi	r24, 0x00	; 0
     b04:	63 e0       	ldi	r22, 0x03	; 3
     b06:	41 e0       	ldi	r20, 0x01	; 1
     b08:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     b0c:	90 e1       	ldi	r25, 0x10	; 16
     b0e:	e9 2e       	mov	r14, r25
     b10:	97 e2       	ldi	r25, 0x27	; 39
     b12:	f9 2e       	mov	r15, r25
     b14:	c7 01       	movw	r24, r14
     b16:	01 97       	sbiw	r24, 0x01	; 1
     b18:	f1 f7       	brne	.-4      	; 0xb16 <HLCD_voidSendData+0x32>
	_delay_ms(5);
	/*step 5 : Disable E pin */
	DIO_u8SetPinValue(PORT_CONTROL, HLCD_E_PIN, DIO_u8_LOW);
     b1a:	80 e0       	ldi	r24, 0x00	; 0
     b1c:	63 e0       	ldi	r22, 0x03	; 3
     b1e:	40 e0       	ldi	r20, 0x00	; 0
     b20:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>

	/*send low nibble*/
	copy_u8Data = (copy_u8Data & 0x0F) << 4;
     b24:	10 e0       	ldi	r17, 0x00	; 0
     b26:	84 e0       	ldi	r24, 0x04	; 4
     b28:	00 0f       	add	r16, r16
     b2a:	11 1f       	adc	r17, r17
     b2c:	8a 95       	dec	r24
     b2e:	e1 f7       	brne	.-8      	; 0xb28 <HLCD_voidSendData+0x44>
	DIO_void_Set4Bits_Value(PORT_DATA, copy_u8Data); //Low
     b30:	81 e0       	ldi	r24, 0x01	; 1
     b32:	60 2f       	mov	r22, r16
     b34:	0e 94 81 04 	call	0x902	; 0x902 <DIO_void_Set4Bits_Value>

	/*step 4: Enable E pin */
	DIO_u8SetPinValue(PORT_CONTROL, HLCD_E_PIN, DIO_u8_HIGH);
     b38:	80 e0       	ldi	r24, 0x00	; 0
     b3a:	63 e0       	ldi	r22, 0x03	; 3
     b3c:	41 e0       	ldi	r20, 0x01	; 1
     b3e:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
     b42:	c7 01       	movw	r24, r14
     b44:	01 97       	sbiw	r24, 0x01	; 1
     b46:	f1 f7       	brne	.-4      	; 0xb44 <HLCD_voidSendData+0x60>
	_delay_ms(5);
	/*step 5 : Disable E pin */
	DIO_u8SetPinValue(PORT_CONTROL, HLCD_E_PIN, DIO_u8_LOW);
     b48:	80 e0       	ldi	r24, 0x00	; 0
     b4a:	63 e0       	ldi	r22, 0x03	; 3
     b4c:	40 e0       	ldi	r20, 0x00	; 0
     b4e:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
#endif
}
     b52:	1f 91       	pop	r17
     b54:	0f 91       	pop	r16
     b56:	ff 90       	pop	r15
     b58:	ef 90       	pop	r14
     b5a:	08 95       	ret

00000b5c <HLCD_voidPrintCustomized>:
	HLCD_voidSendCommand(SET_DDRAM_ADDRESS & 0xF0);
	HLCD_voidSendCommand(SET_DDRAM_ADDRESS << 4);
#endif
}
void HLCD_voidPrintCustomized(u8 copy_CharID) {
	HLCD_voidSendData(copy_CharID);
     b5c:	0e 94 72 05 	call	0xae4	; 0xae4 <HLCD_voidSendData>
}
     b60:	08 95       	ret

00000b62 <HLCD_voidSendNumber>:
		i++;
	}

}
void HLCD_voidSendNumber(u32 copy_u32Number) //decimal
{
     b62:	af 92       	push	r10
     b64:	bf 92       	push	r11
     b66:	cf 92       	push	r12
     b68:	df 92       	push	r13
     b6a:	ef 92       	push	r14
     b6c:	ff 92       	push	r15
     b6e:	0f 93       	push	r16
     b70:	1f 93       	push	r17
     b72:	df 93       	push	r29
     b74:	cf 93       	push	r28
     b76:	cd b7       	in	r28, 0x3d	; 61
     b78:	de b7       	in	r29, 0x3e	; 62
     b7a:	2c 97       	sbiw	r28, 0x0c	; 12
     b7c:	0f b6       	in	r0, 0x3f	; 63
     b7e:	f8 94       	cli
     b80:	de bf       	out	0x3e, r29	; 62
     b82:	0f be       	out	0x3f, r0	; 63
     b84:	cd bf       	out	0x3d, r28	; 61
     b86:	6b 01       	movw	r12, r22
     b88:	7c 01       	movw	r14, r24
     b8a:	10 e0       	ldi	r17, 0x00	; 0
	u8 LOC_NumStr[10];
	u8 i = 0, j;
	while (copy_u32Number != 0) {
		LOC_NumStr[i] = copy_u32Number % 10;
     b8c:	5e 01       	movw	r10, r28
     b8e:	08 94       	sec
     b90:	a1 1c       	adc	r10, r1
     b92:	b1 1c       	adc	r11, r1
     b94:	1d c0       	rjmp	.+58     	; 0xbd0 <HLCD_voidSendNumber+0x6e>
     b96:	c5 01       	movw	r24, r10
     b98:	81 0f       	add	r24, r17
     b9a:	91 1d       	adc	r25, r1
     b9c:	9c 87       	std	Y+12, r25	; 0x0c
     b9e:	8b 87       	std	Y+11, r24	; 0x0b
     ba0:	c7 01       	movw	r24, r14
     ba2:	b6 01       	movw	r22, r12
     ba4:	2a e0       	ldi	r18, 0x0A	; 10
     ba6:	30 e0       	ldi	r19, 0x00	; 0
     ba8:	40 e0       	ldi	r20, 0x00	; 0
     baa:	50 e0       	ldi	r21, 0x00	; 0
     bac:	0e 94 f5 23 	call	0x47ea	; 0x47ea <__udivmodsi4>
     bb0:	eb 85       	ldd	r30, Y+11	; 0x0b
     bb2:	fc 85       	ldd	r31, Y+12	; 0x0c
     bb4:	60 83       	st	Z, r22
		i++;
     bb6:	1f 5f       	subi	r17, 0xFF	; 255
		copy_u32Number /= 10;
     bb8:	c7 01       	movw	r24, r14
     bba:	b6 01       	movw	r22, r12
     bbc:	2a e0       	ldi	r18, 0x0A	; 10
     bbe:	30 e0       	ldi	r19, 0x00	; 0
     bc0:	40 e0       	ldi	r20, 0x00	; 0
     bc2:	50 e0       	ldi	r21, 0x00	; 0
     bc4:	0e 94 f5 23 	call	0x47ea	; 0x47ea <__udivmodsi4>
     bc8:	c9 01       	movw	r24, r18
     bca:	da 01       	movw	r26, r20
     bcc:	6c 01       	movw	r12, r24
     bce:	7d 01       	movw	r14, r26
}
void HLCD_voidSendNumber(u32 copy_u32Number) //decimal
{
	u8 LOC_NumStr[10];
	u8 i = 0, j;
	while (copy_u32Number != 0) {
     bd0:	c1 14       	cp	r12, r1
     bd2:	d1 04       	cpc	r13, r1
     bd4:	e1 04       	cpc	r14, r1
     bd6:	f1 04       	cpc	r15, r1
     bd8:	f1 f6       	brne	.-68     	; 0xb96 <HLCD_voidSendNumber+0x34>
		LOC_NumStr[i] = copy_u32Number % 10;
		i++;
		copy_u32Number /= 10;
	}
	for (j = i - 1; j >= 0; j--) {
     bda:	01 2f       	mov	r16, r17
     bdc:	01 50       	subi	r16, 0x01	; 1
		HLCD_voidSendData(LOC_NumStr[j] + '0');
     bde:	7e 01       	movw	r14, r28
     be0:	08 94       	sec
     be2:	e1 1c       	adc	r14, r1
     be4:	f1 1c       	adc	r15, r1
     be6:	f7 01       	movw	r30, r14
     be8:	e0 0f       	add	r30, r16
     bea:	f1 1d       	adc	r31, r1
     bec:	80 81       	ld	r24, Z
     bee:	80 5d       	subi	r24, 0xD0	; 208
     bf0:	0e 94 72 05 	call	0xae4	; 0xae4 <HLCD_voidSendData>
		if (j == 0)
     bf4:	00 23       	and	r16, r16
     bf6:	11 f0       	breq	.+4      	; 0xbfc <HLCD_voidSendNumber+0x9a>
	while (copy_u32Number != 0) {
		LOC_NumStr[i] = copy_u32Number % 10;
		i++;
		copy_u32Number /= 10;
	}
	for (j = i - 1; j >= 0; j--) {
     bf8:	01 50       	subi	r16, 0x01	; 1
     bfa:	f5 cf       	rjmp	.-22     	; 0xbe6 <HLCD_voidSendNumber+0x84>
		HLCD_voidSendData(LOC_NumStr[j] + '0');
		if (j == 0)
			break;
	}

}
     bfc:	2c 96       	adiw	r28, 0x0c	; 12
     bfe:	0f b6       	in	r0, 0x3f	; 63
     c00:	f8 94       	cli
     c02:	de bf       	out	0x3e, r29	; 62
     c04:	0f be       	out	0x3f, r0	; 63
     c06:	cd bf       	out	0x3d, r28	; 61
     c08:	cf 91       	pop	r28
     c0a:	df 91       	pop	r29
     c0c:	1f 91       	pop	r17
     c0e:	0f 91       	pop	r16
     c10:	ff 90       	pop	r15
     c12:	ef 90       	pop	r14
     c14:	df 90       	pop	r13
     c16:	cf 90       	pop	r12
     c18:	bf 90       	pop	r11
     c1a:	af 90       	pop	r10
     c1c:	08 95       	ret

00000c1e <HLCD_voidSendString>:
	_delay_ms(5);
	/*step 5 : Disable E pin */
	DIO_u8SetPinValue(PORT_CONTROL, HLCD_E_PIN, DIO_u8_LOW);
#endif
}
void HLCD_voidSendString(u8 *PtrToString) {
     c1e:	1f 93       	push	r17
     c20:	cf 93       	push	r28
     c22:	df 93       	push	r29
     c24:	ec 01       	movw	r28, r24
     c26:	10 e0       	ldi	r17, 0x00	; 0
     c28:	03 c0       	rjmp	.+6      	; 0xc30 <HLCD_voidSendString+0x12>
	u8 i = 0;
	while (PtrToString[i] != '\0') {
		HLCD_voidSendData(PtrToString[i]);
     c2a:	0e 94 72 05 	call	0xae4	; 0xae4 <HLCD_voidSendData>
		i++;
     c2e:	1f 5f       	subi	r17, 0xFF	; 255
	DIO_u8SetPinValue(PORT_CONTROL, HLCD_E_PIN, DIO_u8_LOW);
#endif
}
void HLCD_voidSendString(u8 *PtrToString) {
	u8 i = 0;
	while (PtrToString[i] != '\0') {
     c30:	fe 01       	movw	r30, r28
     c32:	e1 0f       	add	r30, r17
     c34:	f1 1d       	adc	r31, r1
     c36:	80 81       	ld	r24, Z
     c38:	88 23       	and	r24, r24
     c3a:	b9 f7       	brne	.-18     	; 0xc2a <HLCD_voidSendString+0xc>
		HLCD_voidSendData(PtrToString[i]);
		i++;
	}

}
     c3c:	df 91       	pop	r29
     c3e:	cf 91       	pop	r28
     c40:	1f 91       	pop	r17
     c42:	08 95       	ret

00000c44 <HLCD_voidSendCommand>:
	HLCD_voidSendCommand(ENTRY_MODE_SET & 0xF0);
	HLCD_voidSendCommand(ENTRY_MODE_SET << 4);
	_delay_ms(2);
#endif
}
void HLCD_voidSendCommand(u8 copy_u8Instruction) {
     c44:	1f 93       	push	r17
     c46:	18 2f       	mov	r17, r24
	/*step 1: select RS to be in command mode*/
	DIO_u8SetPinValue(PORT_CONTROL, HLCD_RS_PIN, DIO_u8_LOW);
     c48:	80 e0       	ldi	r24, 0x00	; 0
     c4a:	61 e0       	ldi	r22, 0x01	; 1
     c4c:	40 e0       	ldi	r20, 0x00	; 0
     c4e:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
	//	DIO_u8SetPinValue(PORT_CONTROL,HLCD_RW_PIN,DIO_u8_LOW);
	/*step 3 : send Instruction*/
#if(FUNCTION_SET == FUNCTION_SET_8BIT_MODE_2LINES || FUNCTION_SET == FUNCTION_SET_8BIT_MODE_1LINES)
	DIO_u8SetPortValue(PORT_DATA,copy_u8Instruction);
#elif(FUNCTION_SET == FUNCTION_SET_4BIT_MODE_2LINES || FUNCTION_SET ==  FUNCTION_SET_4BIT_MODE_1LINES)
	DIO_void_Set4Bits_Value(PORT_DATA, copy_u8Instruction);
     c52:	81 e0       	ldi	r24, 0x01	; 1
     c54:	61 2f       	mov	r22, r17
     c56:	0e 94 81 04 	call	0x902	; 0x902 <DIO_void_Set4Bits_Value>
#endif
	/*step 4: Enable E pin */
	DIO_u8SetPinValue(PORT_CONTROL, HLCD_E_PIN, DIO_u8_HIGH);
     c5a:	80 e0       	ldi	r24, 0x00	; 0
     c5c:	63 e0       	ldi	r22, 0x03	; 3
     c5e:	41 e0       	ldi	r20, 0x01	; 1
     c60:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
     c64:	80 e1       	ldi	r24, 0x10	; 16
     c66:	97 e2       	ldi	r25, 0x27	; 39
     c68:	01 97       	sbiw	r24, 0x01	; 1
     c6a:	f1 f7       	brne	.-4      	; 0xc68 <HLCD_voidSendCommand+0x24>
	_delay_ms(5);
	/*step 5 : Disable E pin */
	DIO_u8SetPinValue(PORT_CONTROL, HLCD_E_PIN, DIO_u8_LOW);
     c6c:	80 e0       	ldi	r24, 0x00	; 0
     c6e:	63 e0       	ldi	r22, 0x03	; 3
     c70:	40 e0       	ldi	r20, 0x00	; 0
     c72:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>

}
     c76:	1f 91       	pop	r17
     c78:	08 95       	ret

00000c7a <HLCD_voidSendCustomized>:
		}

	}
#endif
}
void HLCD_voidSendCustomized(u8 * PtrCustomChar, u8 copy_CharID) {
     c7a:	ef 92       	push	r14
     c7c:	ff 92       	push	r15
     c7e:	0f 93       	push	r16
     c80:	1f 93       	push	r17
     c82:	cf 93       	push	r28
     c84:	df 93       	push	r29
     c86:	7c 01       	movw	r14, r24
     c88:	06 2f       	mov	r16, r22
#elif(FUNCTION_SET == FUNCTION_SET_4BIT_MODE_2LINES || FUNCTION_SET ==  FUNCTION_SET_4BIT_MODE_1LINES)

	u8 i;

	/*set AC to point to CGRAM address*/
	HLCD_voidSendCommand((SET_CGRAM_ADDRESS + copy_CharID * 8) & 0xF0);
     c8a:	10 e0       	ldi	r17, 0x00	; 0
     c8c:	08 5f       	subi	r16, 0xF8	; 248
     c8e:	1f 4f       	sbci	r17, 0xFF	; 255
     c90:	23 e0       	ldi	r18, 0x03	; 3
     c92:	00 0f       	add	r16, r16
     c94:	11 1f       	adc	r17, r17
     c96:	2a 95       	dec	r18
     c98:	e1 f7       	brne	.-8      	; 0xc92 <HLCD_voidSendCustomized+0x18>
     c9a:	80 2f       	mov	r24, r16
     c9c:	80 7f       	andi	r24, 0xF0	; 240
     c9e:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
	HLCD_voidSendCommand((SET_CGRAM_ADDRESS + copy_CharID * 8) << 4);
     ca2:	80 2f       	mov	r24, r16
     ca4:	82 95       	swap	r24
     ca6:	80 7f       	andi	r24, 0xF0	; 240
     ca8:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
     cac:	c0 e0       	ldi	r28, 0x00	; 0
     cae:	d0 e0       	ldi	r29, 0x00	; 0
	/*send character pattern to be written in CGRAM */
	for (i = 0; i < 7; i++) {
		HLCD_voidSendData(PtrCustomChar[i]);
     cb0:	f7 01       	movw	r30, r14
     cb2:	ec 0f       	add	r30, r28
     cb4:	fd 1f       	adc	r31, r29
     cb6:	80 81       	ld	r24, Z
     cb8:	0e 94 72 05 	call	0xae4	; 0xae4 <HLCD_voidSendData>
     cbc:	21 96       	adiw	r28, 0x01	; 1

	/*set AC to point to CGRAM address*/
	HLCD_voidSendCommand((SET_CGRAM_ADDRESS + copy_CharID * 8) & 0xF0);
	HLCD_voidSendCommand((SET_CGRAM_ADDRESS + copy_CharID * 8) << 4);
	/*send character pattern to be written in CGRAM */
	for (i = 0; i < 7; i++) {
     cbe:	c7 30       	cpi	r28, 0x07	; 7
     cc0:	d1 05       	cpc	r29, r1
     cc2:	b1 f7       	brne	.-20     	; 0xcb0 <HLCD_voidSendCustomized+0x36>
		HLCD_voidSendData(PtrCustomChar[i]);
	}
	/*return AC to point to DDRAM address*/
	HLCD_voidSendCommand(SET_DDRAM_ADDRESS & 0xF0);
     cc4:	80 e8       	ldi	r24, 0x80	; 128
     cc6:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
	HLCD_voidSendCommand(SET_DDRAM_ADDRESS << 4);
     cca:	80 e0       	ldi	r24, 0x00	; 0
     ccc:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
#endif
}
     cd0:	df 91       	pop	r29
     cd2:	cf 91       	pop	r28
     cd4:	1f 91       	pop	r17
     cd6:	0f 91       	pop	r16
     cd8:	ff 90       	pop	r15
     cda:	ef 90       	pop	r14
     cdc:	08 95       	ret

00000cde <HLCD_voidSetPosition>:
#elif(FUNCTION_SET == FUNCTION_SET_4BIT_MODE_2LINES || FUNCTION_SET ==  FUNCTION_SET_4BIT_MODE_1LINES)
	HLCD_voidSendCommand(CLEAR_DISPLAY & 0xF0);
	HLCD_voidSendCommand(CLEAR_DISPLAY << 4);
#endif
}
void HLCD_voidSetPosition(u8 copy_rowIndx, u8 copy_colIndx) {
     cde:	1f 93       	push	r17

		}

	}
#elif(FUNCTION_SET == FUNCTION_SET_4BIT_MODE_2LINES || FUNCTION_SET ==  FUNCTION_SET_4BIT_MODE_1LINES)
	if (copy_colIndx >= 0 && copy_colIndx <= 15) {
     ce0:	60 31       	cpi	r22, 0x10	; 16
     ce2:	98 f4       	brcc	.+38     	; 0xd0a <HLCD_voidSetPosition+0x2c>
		switch (copy_rowIndx) {
     ce4:	88 23       	and	r24, r24
     ce6:	19 f0       	breq	.+6      	; 0xcee <HLCD_voidSetPosition+0x10>
     ce8:	81 30       	cpi	r24, 0x01	; 1
     cea:	79 f4       	brne	.+30     	; 0xd0a <HLCD_voidSetPosition+0x2c>
     cec:	03 c0       	rjmp	.+6      	; 0xcf4 <HLCD_voidSetPosition+0x16>
		case 0:
			HLCD_voidSendCommand((SET_DDRAM_ADDRESS + copy_colIndx) & 0xF0);
     cee:	16 2f       	mov	r17, r22
     cf0:	10 58       	subi	r17, 0x80	; 128
     cf2:	02 c0       	rjmp	.+4      	; 0xcf8 <HLCD_voidSetPosition+0x1a>
			HLCD_voidSendCommand((SET_DDRAM_ADDRESS + copy_colIndx) << 4);
			break;
		case 1:
			HLCD_voidSendCommand(
     cf4:	16 2f       	mov	r17, r22
     cf6:	10 54       	subi	r17, 0x40	; 64
     cf8:	81 2f       	mov	r24, r17
     cfa:	80 7f       	andi	r24, 0xF0	; 240
     cfc:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
					(SET_DDRAM_ADDRESS + HLCD_SECOND_ROW_ADDRESS_OFFSET
							+ copy_colIndx) & 0xF0);
			HLCD_voidSendCommand(
     d00:	81 2f       	mov	r24, r17
     d02:	82 95       	swap	r24
     d04:	80 7f       	andi	r24, 0xF0	; 240
     d06:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>

		}

	}
#endif
}
     d0a:	1f 91       	pop	r17
     d0c:	08 95       	ret

00000d0e <HLCD_voidClearDisplay>:
}
void HLCD_voidClearDisplay() {
#if(FUNCTION_SET == FUNCTION_SET_8BIT_MODE_2LINES || FUNCTION_SET == FUNCTION_SET_8BIT_MODE_1LINES)
	HLCD_voidSendCommand(CLEAR_DISPLAY);
#elif(FUNCTION_SET == FUNCTION_SET_4BIT_MODE_2LINES || FUNCTION_SET ==  FUNCTION_SET_4BIT_MODE_1LINES)
	HLCD_voidSendCommand(CLEAR_DISPLAY & 0xF0);
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
	HLCD_voidSendCommand(CLEAR_DISPLAY << 4);
     d14:	80 e1       	ldi	r24, 0x10	; 16
     d16:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
#endif
}
     d1a:	08 95       	ret

00000d1c <HLCD_voidInit>:
#include "HLCD_config.h"
#include "HLCD_interface.h"
#include "HLCD_private.h"
#include <util/delay.h>

void HLCD_voidInit(void) {
     d1c:	0f 93       	push	r16
     d1e:	1f 93       	push	r17
	/*step 1 : config data port*/
#if(FUNCTION_SET == FUNCTION_SET_8BIT_MODE_2LINES || FUNCTION_SET == FUNCTION_SET_8BIT_MODE_1LINES)
	DIO_u8SetPortDirection(PORT_DATA,DIO_u8_OUTPUT);
#elif(FUNCTION_SET == FUNCTION_SET_4BIT_MODE_2LINES || FUNCTION_SET ==  FUNCTION_SET_4BIT_MODE_1LINES)
	DIO_u8SetPinDirection(PORT_DATA, HLCD_D4_PIN, DIO_u8_OUTPUT);
     d20:	81 e0       	ldi	r24, 0x01	; 1
     d22:	63 e0       	ldi	r22, 0x03	; 3
     d24:	41 e0       	ldi	r20, 0x01	; 1
     d26:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(PORT_DATA, HLCD_D5_PIN, DIO_u8_OUTPUT);
     d2a:	81 e0       	ldi	r24, 0x01	; 1
     d2c:	64 e0       	ldi	r22, 0x04	; 4
     d2e:	41 e0       	ldi	r20, 0x01	; 1
     d30:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(PORT_DATA, HLCD_D6_PIN, DIO_u8_OUTPUT);
     d34:	81 e0       	ldi	r24, 0x01	; 1
     d36:	65 e0       	ldi	r22, 0x05	; 5
     d38:	41 e0       	ldi	r20, 0x01	; 1
     d3a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(PORT_DATA, HLCD_D7_PIN, DIO_u8_OUTPUT);
     d3e:	81 e0       	ldi	r24, 0x01	; 1
     d40:	66 e0       	ldi	r22, 0x06	; 6
     d42:	41 e0       	ldi	r20, 0x01	; 1
     d44:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
#endif
	/*step : config PORT CONTROL*/
	DIO_u8SetPinDirection(PORT_CONTROL, HLCD_RS_PIN, DIO_u8_OUTPUT);
     d48:	80 e0       	ldi	r24, 0x00	; 0
     d4a:	61 e0       	ldi	r22, 0x01	; 1
     d4c:	41 e0       	ldi	r20, 0x01	; 1
     d4e:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>

	DIO_u8SetPinDirection(PORT_CONTROL, HLCD_RW_PIN, DIO_u8_OUTPUT);
     d52:	80 e0       	ldi	r24, 0x00	; 0
     d54:	62 e0       	ldi	r22, 0x02	; 2
     d56:	41 e0       	ldi	r20, 0x01	; 1
     d58:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
	//	DIO_u8SetPinDirection(PORT_CONTROL,HLCD_RW_PIN,DIO_u8_OUTPUT);
	DIO_u8SetPinDirection(PORT_CONTROL, HLCD_E_PIN, DIO_u8_OUTPUT);
     d5c:	80 e0       	ldi	r24, 0x00	; 0
     d5e:	63 e0       	ldi	r22, 0x03	; 3
     d60:	41 e0       	ldi	r20, 0x01	; 1
     d62:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
     d66:	80 e6       	ldi	r24, 0x60	; 96
     d68:	9a ee       	ldi	r25, 0xEA	; 234
     d6a:	01 97       	sbiw	r24, 0x01	; 1
     d6c:	f1 f7       	brne	.-4      	; 0xd6a <HLCD_voidInit+0x4e>
	_delay_ms(2);
	HLCD_voidSendCommand(ENTRY_MODE_SET);
	_delay_ms(2);
#elif(FUNCTION_SET == FUNCTION_SET_4BIT_MODE_2LINES || FUNCTION_SET ==  FUNCTION_SET_4BIT_MODE_1LINES)
	_delay_ms(30);
	HLCD_voidSendCommand(FUNCTION_SET & 0xF0);
     d6e:	80 e2       	ldi	r24, 0x20	; 32
     d70:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
	HLCD_voidSendCommand(FUNCTION_SET & 0xF0);
     d74:	80 e2       	ldi	r24, 0x20	; 32
     d76:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
	HLCD_voidSendCommand(FUNCTION_SET << 4);
     d7a:	80 e8       	ldi	r24, 0x80	; 128
     d7c:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
     d80:	00 ea       	ldi	r16, 0xA0	; 160
     d82:	1f e0       	ldi	r17, 0x0F	; 15
     d84:	c8 01       	movw	r24, r16
     d86:	01 97       	sbiw	r24, 0x01	; 1
     d88:	f1 f7       	brne	.-4      	; 0xd86 <HLCD_voidInit+0x6a>
	_delay_ms(2);
	HLCD_voidSendCommand(DISPLAY_ON_OFF & 0xF0);
     d8a:	80 e0       	ldi	r24, 0x00	; 0
     d8c:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
	HLCD_voidSendCommand(DISPLAY_ON_OFF << 4);
     d90:	80 ee       	ldi	r24, 0xE0	; 224
     d92:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
     d96:	c8 01       	movw	r24, r16
     d98:	01 97       	sbiw	r24, 0x01	; 1
     d9a:	f1 f7       	brne	.-4      	; 0xd98 <HLCD_voidInit+0x7c>
	_delay_ms(2);
	HLCD_voidSendCommand(CLEAR_DISPLAY & 0xF0);
     d9c:	80 e0       	ldi	r24, 0x00	; 0
     d9e:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
	HLCD_voidSendCommand(CLEAR_DISPLAY << 4);
     da2:	80 e1       	ldi	r24, 0x10	; 16
     da4:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
     da8:	c8 01       	movw	r24, r16
     daa:	01 97       	sbiw	r24, 0x01	; 1
     dac:	f1 f7       	brne	.-4      	; 0xdaa <HLCD_voidInit+0x8e>
	_delay_ms(2);
	HLCD_voidSendCommand(ENTRY_MODE_SET & 0xF0);
     dae:	80 e0       	ldi	r24, 0x00	; 0
     db0:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
	HLCD_voidSendCommand(ENTRY_MODE_SET << 4);
     db4:	80 e6       	ldi	r24, 0x60	; 96
     db6:	0e 94 22 06 	call	0xc44	; 0xc44 <HLCD_voidSendCommand>
     dba:	c8 01       	movw	r24, r16
     dbc:	01 97       	sbiw	r24, 0x01	; 1
     dbe:	f1 f7       	brne	.-4      	; 0xdbc <HLCD_voidInit+0xa0>
	_delay_ms(2);
#endif
}
     dc0:	1f 91       	pop	r17
     dc2:	0f 91       	pop	r16
     dc4:	08 95       	ret

00000dc6 <HKEYPAD_u8GetPressedKey>:
	DIO_u8SetPinValue(COL_PORT,COL_PIN1,DIO_u8_HIGH);
	DIO_u8SetPinValue(COL_PORT,COL_PIN2,DIO_u8_HIGH);
	DIO_u8SetPinValue(COL_PORT,COL_PIN3,DIO_u8_HIGH);
}
u8 HKEYPAD_u8GetPressedKey(void)
{
     dc6:	4f 92       	push	r4
     dc8:	5f 92       	push	r5
     dca:	6f 92       	push	r6
     dcc:	7f 92       	push	r7
     dce:	9f 92       	push	r9
     dd0:	af 92       	push	r10
     dd2:	bf 92       	push	r11
     dd4:	cf 92       	push	r12
     dd6:	df 92       	push	r13
     dd8:	ef 92       	push	r14
     dda:	ff 92       	push	r15
     ddc:	0f 93       	push	r16
     dde:	1f 93       	push	r17
     de0:	df 93       	push	r29
     de2:	cf 93       	push	r28
     de4:	cd b7       	in	r28, 0x3d	; 61
     de6:	de b7       	in	r29, 0x3e	; 62
     de8:	61 97       	sbiw	r28, 0x11	; 17
     dea:	0f b6       	in	r0, 0x3f	; 63
     dec:	f8 94       	cli
     dee:	de bf       	out	0x3e, r29	; 62
     df0:	0f be       	out	0x3f, r0	; 63
     df2:	cd bf       	out	0x3d, r28	; 61
	u8 LOC_u8ReturnVal = HKEYPAD_NO_PRESSED_KEY;
	u8 col_indx;
	u8 row_indx;
	u8 Pin_State;
	u8 LOC_u8HKEYPAD_Arr[HKEYPAD_ROWS][HKEYPAD_COL]=  HKEYPAD_VALUES;
     df4:	de 01       	movw	r26, r28
     df6:	12 96       	adiw	r26, 0x02	; 2
     df8:	e2 e1       	ldi	r30, 0x12	; 18
     dfa:	f1 e0       	ldi	r31, 0x01	; 1
     dfc:	80 e1       	ldi	r24, 0x10	; 16
     dfe:	01 90       	ld	r0, Z+
     e00:	0d 92       	st	X+, r0
     e02:	81 50       	subi	r24, 0x01	; 1
     e04:	e1 f7       	brne	.-8      	; 0xdfe <HKEYPAD_u8GetPressedKey+0x38>
     e06:	99 24       	eor	r9, r9
     e08:	9a 94       	dec	r9
     e0a:	ee 24       	eor	r14, r14
     e0c:	ff 24       	eor	r15, r15
   for(col_indx=COL_S;col_indx<COL_MAX;col_indx++ )
   {
	   /*select column and output low*/
	   DIO_u8SetPinValue(COL_PORT,col_indx,DIO_u8_LOW);
     e0e:	32 e0       	ldi	r19, 0x02	; 2
     e10:	43 2e       	mov	r4, r19
     e12:	51 2c       	mov	r5, r1
     e14:	4c 0e       	add	r4, r28
     e16:	5d 1e       	adc	r5, r29
	   for(row_indx = ROW_S;row_indx<ROW_MAX;row_indx++)
	   {
           DIO_u8GetPinValue( ROW_PORT,row_indx,&Pin_State);
     e18:	5e 01       	movw	r10, r28
     e1a:	08 94       	sec
     e1c:	a1 1c       	adc	r10, r1
     e1e:	b1 1c       	adc	r11, r1
     e20:	20 e2       	ldi	r18, 0x20	; 32
     e22:	62 2e       	mov	r6, r18
     e24:	2e e4       	ldi	r18, 0x4E	; 78
     e26:	72 2e       	mov	r7, r18
{
	u8 LOC_u8ReturnVal = HKEYPAD_NO_PRESSED_KEY;
	u8 col_indx;
	u8 row_indx;
	u8 Pin_State;
	u8 LOC_u8HKEYPAD_Arr[HKEYPAD_ROWS][HKEYPAD_COL]=  HKEYPAD_VALUES;
     e28:	92 e0       	ldi	r25, 0x02	; 2
     e2a:	c9 2e       	mov	r12, r25
     e2c:	ce 0c       	add	r12, r14
   for(col_indx=COL_S;col_indx<COL_MAX;col_indx++ )
   {
	   /*select column and output low*/
	   DIO_u8SetPinValue(COL_PORT,col_indx,DIO_u8_LOW);
     e2e:	83 e0       	ldi	r24, 0x03	; 3
     e30:	6c 2d       	mov	r22, r12
     e32:	40 e0       	ldi	r20, 0x00	; 0
     e34:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
     e38:	82 01       	movw	r16, r4
     e3a:	0e 0d       	add	r16, r14
     e3c:	1f 1d       	adc	r17, r15
     e3e:	84 e0       	ldi	r24, 0x04	; 4
     e40:	d8 2e       	mov	r13, r24
	   for(row_indx = ROW_S;row_indx<ROW_MAX;row_indx++)
	   {
           DIO_u8GetPinValue( ROW_PORT,row_indx,&Pin_State);
     e42:	82 e0       	ldi	r24, 0x02	; 2
     e44:	6d 2d       	mov	r22, r13
     e46:	a5 01       	movw	r20, r10
     e48:	0e 94 ab 03 	call	0x756	; 0x756 <DIO_u8GetPinValue>
           if(Pin_State == 0) /*if true -> PB is pressed*/
     e4c:	89 81       	ldd	r24, Y+1	; 0x01
     e4e:	88 23       	and	r24, r24
     e50:	71 f4       	brne	.+28     	; 0xe6e <HKEYPAD_u8GetPressedKey+0xa8>
           {
        	   LOC_u8ReturnVal =  LOC_u8HKEYPAD_Arr[row_indx-ROW_S][col_indx-COL_S];
     e52:	f8 01       	movw	r30, r16
     e54:	90 80       	ld	r9, Z
     e56:	05 c0       	rjmp	.+10     	; 0xe62 <HKEYPAD_u8GetPressedKey+0x9c>
        	   /*busy waiting loop*/
        	   while(Pin_State == 0)
        	   {
        		   DIO_u8GetPinValue( ROW_PORT,row_indx,&Pin_State);
     e58:	82 e0       	ldi	r24, 0x02	; 2
     e5a:	6d 2d       	mov	r22, r13
     e5c:	a5 01       	movw	r20, r10
     e5e:	0e 94 ab 03 	call	0x756	; 0x756 <DIO_u8GetPinValue>
           DIO_u8GetPinValue( ROW_PORT,row_indx,&Pin_State);
           if(Pin_State == 0) /*if true -> PB is pressed*/
           {
        	   LOC_u8ReturnVal =  LOC_u8HKEYPAD_Arr[row_indx-ROW_S][col_indx-COL_S];
        	   /*busy waiting loop*/
        	   while(Pin_State == 0)
     e62:	89 81       	ldd	r24, Y+1	; 0x01
     e64:	88 23       	and	r24, r24
     e66:	c1 f3       	breq	.-16     	; 0xe58 <HKEYPAD_u8GetPressedKey+0x92>
     e68:	c3 01       	movw	r24, r6
     e6a:	01 97       	sbiw	r24, 0x01	; 1
     e6c:	f1 f7       	brne	.-4      	; 0xe6a <HKEYPAD_u8GetPressedKey+0xa4>
	u8 LOC_u8HKEYPAD_Arr[HKEYPAD_ROWS][HKEYPAD_COL]=  HKEYPAD_VALUES;
   for(col_indx=COL_S;col_indx<COL_MAX;col_indx++ )
   {
	   /*select column and output low*/
	   DIO_u8SetPinValue(COL_PORT,col_indx,DIO_u8_LOW);
	   for(row_indx = ROW_S;row_indx<ROW_MAX;row_indx++)
     e6e:	d3 94       	inc	r13
     e70:	0c 5f       	subi	r16, 0xFC	; 252
     e72:	1f 4f       	sbci	r17, 0xFF	; 255
     e74:	f8 e0       	ldi	r31, 0x08	; 8
     e76:	df 16       	cp	r13, r31
     e78:	21 f7       	brne	.-56     	; 0xe42 <HKEYPAD_u8GetPressedKey+0x7c>
        	   }
        	   /*debouncing button */
        	   _delay_ms(10);
           }
	   }
	   DIO_u8SetPinValue(COL_PORT,col_indx,DIO_u8_HIGH);
     e7a:	83 e0       	ldi	r24, 0x03	; 3
     e7c:	6c 2d       	mov	r22, r12
     e7e:	41 e0       	ldi	r20, 0x01	; 1
     e80:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
     e84:	08 94       	sec
     e86:	e1 1c       	adc	r14, r1
     e88:	f1 1c       	adc	r15, r1
	u8 LOC_u8ReturnVal = HKEYPAD_NO_PRESSED_KEY;
	u8 col_indx;
	u8 row_indx;
	u8 Pin_State;
	u8 LOC_u8HKEYPAD_Arr[HKEYPAD_ROWS][HKEYPAD_COL]=  HKEYPAD_VALUES;
   for(col_indx=COL_S;col_indx<COL_MAX;col_indx++ )
     e8a:	84 e0       	ldi	r24, 0x04	; 4
     e8c:	e8 16       	cp	r14, r24
     e8e:	f1 04       	cpc	r15, r1
     e90:	59 f6       	brne	.-106    	; 0xe28 <HKEYPAD_u8GetPressedKey+0x62>
           }
	   }
	   DIO_u8SetPinValue(COL_PORT,col_indx,DIO_u8_HIGH);
   }
   return LOC_u8ReturnVal;
}
     e92:	89 2d       	mov	r24, r9
     e94:	61 96       	adiw	r28, 0x11	; 17
     e96:	0f b6       	in	r0, 0x3f	; 63
     e98:	f8 94       	cli
     e9a:	de bf       	out	0x3e, r29	; 62
     e9c:	0f be       	out	0x3f, r0	; 63
     e9e:	cd bf       	out	0x3d, r28	; 61
     ea0:	cf 91       	pop	r28
     ea2:	df 91       	pop	r29
     ea4:	1f 91       	pop	r17
     ea6:	0f 91       	pop	r16
     ea8:	ff 90       	pop	r15
     eaa:	ef 90       	pop	r14
     eac:	df 90       	pop	r13
     eae:	cf 90       	pop	r12
     eb0:	bf 90       	pop	r11
     eb2:	af 90       	pop	r10
     eb4:	9f 90       	pop	r9
     eb6:	7f 90       	pop	r7
     eb8:	6f 90       	pop	r6
     eba:	5f 90       	pop	r5
     ebc:	4f 90       	pop	r4
     ebe:	08 95       	ret

00000ec0 <HKEYPAD_voidInit>:
#include "HKEYPAD_interface.h"

void HKEYPAD_voidInit(void)
{
   /*step 1 : config Col pins as output*/
	DIO_u8SetPinDirection(COL_PORT,COL_PIN0,DIO_u8_OUTPUT);
     ec0:	83 e0       	ldi	r24, 0x03	; 3
     ec2:	62 e0       	ldi	r22, 0x02	; 2
     ec4:	41 e0       	ldi	r20, 0x01	; 1
     ec6:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(COL_PORT,COL_PIN1,DIO_u8_OUTPUT);
     eca:	83 e0       	ldi	r24, 0x03	; 3
     ecc:	63 e0       	ldi	r22, 0x03	; 3
     ece:	41 e0       	ldi	r20, 0x01	; 1
     ed0:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(COL_PORT,COL_PIN2,DIO_u8_OUTPUT);
     ed4:	83 e0       	ldi	r24, 0x03	; 3
     ed6:	64 e0       	ldi	r22, 0x04	; 4
     ed8:	41 e0       	ldi	r20, 0x01	; 1
     eda:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(COL_PORT,COL_PIN3,DIO_u8_OUTPUT);
     ede:	83 e0       	ldi	r24, 0x03	; 3
     ee0:	65 e0       	ldi	r22, 0x05	; 5
     ee2:	41 e0       	ldi	r20, 0x01	; 1
     ee4:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
   /*step 2 : config Rows pins as inputs , pull ups*/
	DIO_u8SetPinDirection(ROW_PORT,ROW_PIN0,DIO_u8_INPUT_PULLED_UP);
     ee8:	82 e0       	ldi	r24, 0x02	; 2
     eea:	64 e0       	ldi	r22, 0x04	; 4
     eec:	42 e0       	ldi	r20, 0x02	; 2
     eee:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(ROW_PORT,ROW_PIN1,DIO_u8_INPUT_PULLED_UP);
     ef2:	82 e0       	ldi	r24, 0x02	; 2
     ef4:	65 e0       	ldi	r22, 0x05	; 5
     ef6:	42 e0       	ldi	r20, 0x02	; 2
     ef8:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(ROW_PORT,ROW_PIN2,DIO_u8_INPUT_PULLED_UP);
     efc:	82 e0       	ldi	r24, 0x02	; 2
     efe:	66 e0       	ldi	r22, 0x06	; 6
     f00:	42 e0       	ldi	r20, 0x02	; 2
     f02:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(ROW_PORT,ROW_PIN3,DIO_u8_INPUT_PULLED_UP);
     f06:	82 e0       	ldi	r24, 0x02	; 2
     f08:	67 e0       	ldi	r22, 0x07	; 7
     f0a:	42 e0       	ldi	r20, 0x02	; 2
     f0c:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>
   /*step 3 : Initialize Col pins -> HIGH*/
	DIO_u8SetPinValue(COL_PORT,COL_PIN0,DIO_u8_HIGH);
     f10:	83 e0       	ldi	r24, 0x03	; 3
     f12:	62 e0       	ldi	r22, 0x02	; 2
     f14:	41 e0       	ldi	r20, 0x01	; 1
     f16:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(COL_PORT,COL_PIN1,DIO_u8_HIGH);
     f1a:	83 e0       	ldi	r24, 0x03	; 3
     f1c:	63 e0       	ldi	r22, 0x03	; 3
     f1e:	41 e0       	ldi	r20, 0x01	; 1
     f20:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(COL_PORT,COL_PIN2,DIO_u8_HIGH);
     f24:	83 e0       	ldi	r24, 0x03	; 3
     f26:	64 e0       	ldi	r22, 0x04	; 4
     f28:	41 e0       	ldi	r20, 0x01	; 1
     f2a:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(COL_PORT,COL_PIN3,DIO_u8_HIGH);
     f2e:	83 e0       	ldi	r24, 0x03	; 3
     f30:	65 e0       	ldi	r22, 0x05	; 5
     f32:	41 e0       	ldi	r20, 0x01	; 1
     f34:	0e 94 28 03 	call	0x650	; 0x650 <DIO_u8SetPinValue>
}
     f38:	08 95       	ret

00000f3a <EEPROM_determine_size>:
	}
}


uint16_t EEPROM_determine_size(uint16_t Size, uint16_t Offset)
{
     f3a:	9c 01       	movw	r18, r24
	uint16_t Check_Size = Size + Offset;
	/*Check Size smaller than Size EEPROM*/
	(Check_Size < PAGE_SIZE)?(Check_Size = Size):(Check_Size = PAGE_SIZE-Offset);
     f3c:	cb 01       	movw	r24, r22
     f3e:	82 0f       	add	r24, r18
     f40:	93 1f       	adc	r25, r19
     f42:	80 97       	sbiw	r24, 0x20	; 32
     f44:	20 f0       	brcs	.+8      	; 0xf4e <EEPROM_determine_size+0x14>
     f46:	20 e2       	ldi	r18, 0x20	; 32
     f48:	30 e0       	ldi	r19, 0x00	; 0
     f4a:	26 1b       	sub	r18, r22
     f4c:	37 0b       	sbc	r19, r23
	return Check_Size;
}
     f4e:	c9 01       	movw	r24, r18
     f50:	08 95       	ret

00000f52 <EEPROM_read_data_byte>:
		EEPROM_write_data_byte (Address+i, Data[i]);
	}
}

uint8_t EEPROM_read_data_byte (uint16_t Address)
{
     f52:	0f 93       	push	r16
     f54:	1f 93       	push	r17
     f56:	8c 01       	movw	r16, r24
	uint8_t Data;
	TWI_StartM();
     f58:	0e 94 4f 00 	call	0x9e	; 0x9e <TWI_StartM>
	TMI_WriteA(EEPROM_ADDR, TW_MT_SLA_ACK);
     f5c:	80 ea       	ldi	r24, 0xA0	; 160
     f5e:	68 e1       	ldi	r22, 0x18	; 24
     f60:	0e 94 63 00 	call	0xc6	; 0xc6 <TMI_WriteA>
	TMI_WriteD(Address >> 8, TW_MT_DATA_ACK);
     f64:	81 2f       	mov	r24, r17
     f66:	68 e2       	ldi	r22, 0x28	; 40
     f68:	0e 94 72 00 	call	0xe4	; 0xe4 <TMI_WriteD>
	TMI_WriteD(Address, TW_MT_DATA_ACK);
     f6c:	80 2f       	mov	r24, r16
     f6e:	68 e2       	ldi	r22, 0x28	; 40
     f70:	0e 94 72 00 	call	0xe4	; 0xe4 <TMI_WriteD>
	TWI_REPStartM();
     f74:	0e 94 59 00 	call	0xb2	; 0xb2 <TWI_REPStartM>
	TMI_WriteA(EEPROM_ADDRead, TW_MR_SLA_ACK);
     f78:	81 ea       	ldi	r24, 0xA1	; 161
     f7a:	60 e4       	ldi	r22, 0x40	; 64
     f7c:	0e 94 63 00 	call	0xc6	; 0xc6 <TMI_WriteA>
	Data = TWI_Read(1);
     f80:	81 e0       	ldi	r24, 0x01	; 1
     f82:	0e 94 9c 00 	call	0x138	; 0x138 <TWI_Read>
     f86:	18 2f       	mov	r17, r24
	TWI_stop();							/*Withing Next Write*/
     f88:	0e 94 81 00 	call	0x102	; 0x102 <TWI_stop>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     f8c:	82 e0       	ldi	r24, 0x02	; 2
     f8e:	8a 95       	dec	r24
     f90:	f1 f7       	brne	.-4      	; 0xf8e <EEPROM_read_data_byte+0x3c>
	_delay_us(1);
	return Data;
}
     f92:	81 2f       	mov	r24, r17
     f94:	1f 91       	pop	r17
     f96:	0f 91       	pop	r16
     f98:	08 95       	ret

00000f9a <EEPROM_read_data_bytes_per_page>:

void EEPROM_read_data_bytes_per_page (uint16_t Page, uint8_t *Data, uint16_t Size)
{
     f9a:	af 92       	push	r10
     f9c:	bf 92       	push	r11
     f9e:	cf 92       	push	r12
     fa0:	df 92       	push	r13
     fa2:	ef 92       	push	r14
     fa4:	ff 92       	push	r15
     fa6:	1f 93       	push	r17
     fa8:	cf 93       	push	r28
     faa:	df 93       	push	r29
     fac:	5b 01       	movw	r10, r22
     fae:	6a 01       	movw	r12, r20
	uint16_t Address = Page * PAGE_SIZE;
     fb0:	7c 01       	movw	r14, r24
     fb2:	85 e0       	ldi	r24, 0x05	; 5
     fb4:	ee 0c       	add	r14, r14
     fb6:	ff 1c       	adc	r15, r15
     fb8:	8a 95       	dec	r24
     fba:	e1 f7       	brne	.-8      	; 0xfb4 <EEPROM_read_data_bytes_per_page+0x1a>
     fbc:	10 e0       	ldi	r17, 0x00	; 0
     fbe:	09 c0       	rjmp	.+18     	; 0xfd2 <EEPROM_read_data_bytes_per_page+0x38>
	for(uint8_t i = 0;i < Size;i++)
	{
		Data[i] = EEPROM_read_data_byte(Address+i);
     fc0:	ce 01       	movw	r24, r28
     fc2:	8e 0d       	add	r24, r14
     fc4:	9f 1d       	adc	r25, r15
     fc6:	0e 94 a9 07 	call	0xf52	; 0xf52 <EEPROM_read_data_byte>
     fca:	ca 0d       	add	r28, r10
     fcc:	db 1d       	adc	r29, r11
     fce:	88 83       	st	Y, r24
}

void EEPROM_read_data_bytes_per_page (uint16_t Page, uint8_t *Data, uint16_t Size)
{
	uint16_t Address = Page * PAGE_SIZE;
	for(uint8_t i = 0;i < Size;i++)
     fd0:	1f 5f       	subi	r17, 0xFF	; 255
     fd2:	c1 2f       	mov	r28, r17
     fd4:	d0 e0       	ldi	r29, 0x00	; 0
     fd6:	cc 15       	cp	r28, r12
     fd8:	dd 05       	cpc	r29, r13
     fda:	90 f3       	brcs	.-28     	; 0xfc0 <EEPROM_read_data_bytes_per_page+0x26>
	{
		Data[i] = EEPROM_read_data_byte(Address+i);
	}
}
     fdc:	df 91       	pop	r29
     fde:	cf 91       	pop	r28
     fe0:	1f 91       	pop	r17
     fe2:	ff 90       	pop	r15
     fe4:	ef 90       	pop	r14
     fe6:	df 90       	pop	r13
     fe8:	cf 90       	pop	r12
     fea:	bf 90       	pop	r11
     fec:	af 90       	pop	r10
     fee:	08 95       	ret

00000ff0 <EEPROM_read_DataBace>:
		EEPROM_write_data_byte (EepromCounterW++,Data[i].Balance);
	}
}

void EEPROM_read_DataBace (DataBase Data[])
{
     ff0:	8f 92       	push	r8
     ff2:	9f 92       	push	r9
     ff4:	af 92       	push	r10
     ff6:	bf 92       	push	r11
     ff8:	cf 92       	push	r12
     ffa:	df 92       	push	r13
     ffc:	ef 92       	push	r14
     ffe:	ff 92       	push	r15
    1000:	1f 93       	push	r17
    1002:	cf 93       	push	r28
    1004:	df 93       	push	r29
    1006:	4c 01       	movw	r8, r24
    1008:	ee 24       	eor	r14, r14
    100a:	ff 24       	eor	r15, r15
	uint16_t CounterR = 0;
	for(uint8_t i = 0;i < NO_OF_CUSTOMERS;i++)
	{
		/*Update IDs Customers*/
		CounterR+=1;
		Data[i].ID = (EEPROM_read_data_byte (CounterR) << 8) | EEPROM_read_data_byte (CounterR+1);
    100c:	c7 01       	movw	r24, r14
    100e:	01 96       	adiw	r24, 0x01	; 1
    1010:	0e 94 a9 07 	call	0xf52	; 0xf52 <EEPROM_read_data_byte>
    1014:	18 2f       	mov	r17, r24
    1016:	c7 01       	movw	r24, r14
    1018:	02 96       	adiw	r24, 0x02	; 2
    101a:	0e 94 a9 07 	call	0xf52	; 0xf52 <EEPROM_read_data_byte>
    101e:	b1 2e       	mov	r11, r17
    1020:	aa 24       	eor	r10, r10
    1022:	90 e0       	ldi	r25, 0x00	; 0
    1024:	8a 29       	or	r24, r10
    1026:	9b 29       	or	r25, r11
    1028:	f4 01       	movw	r30, r8
    102a:	91 83       	std	Z+1, r25	; 0x01
    102c:	80 83       	st	Z, r24
		/*Update Passwords Customers*/
		CounterR+=2;
		Data[i].Password = (EEPROM_read_data_byte (CounterR) << 8) | EEPROM_read_data_byte (CounterR+1);
    102e:	c7 01       	movw	r24, r14
    1030:	03 96       	adiw	r24, 0x03	; 3
    1032:	0e 94 a9 07 	call	0xf52	; 0xf52 <EEPROM_read_data_byte>
    1036:	18 2f       	mov	r17, r24
    1038:	c7 01       	movw	r24, r14
    103a:	04 96       	adiw	r24, 0x04	; 4
    103c:	0e 94 a9 07 	call	0xf52	; 0xf52 <EEPROM_read_data_byte>
    1040:	d1 2e       	mov	r13, r17
    1042:	cc 24       	eor	r12, r12
    1044:	90 e0       	ldi	r25, 0x00	; 0
    1046:	8c 29       	or	r24, r12
    1048:	9d 29       	or	r25, r13
    104a:	f4 01       	movw	r30, r8
    104c:	93 83       	std	Z+3, r25	; 0x03
    104e:	82 83       	std	Z+2, r24	; 0x02
    1050:	86 e0       	ldi	r24, 0x06	; 6
    1052:	90 e0       	ldi	r25, 0x00	; 0
    1054:	e8 0e       	add	r14, r24
    1056:	f9 1e       	adc	r15, r25
		/*Update Balance Customers*/
		CounterR+=3;
		Data[i].Balance = (EEPROM_read_data_byte (CounterR) << 8) | EEPROM_read_data_byte (CounterR+1);
    1058:	c7 01       	movw	r24, r14
    105a:	0e 94 a9 07 	call	0xf52	; 0xf52 <EEPROM_read_data_byte>
    105e:	18 2f       	mov	r17, r24
    1060:	c7 01       	movw	r24, r14
    1062:	01 96       	adiw	r24, 0x01	; 1
    1064:	0e 94 a9 07 	call	0xf52	; 0xf52 <EEPROM_read_data_byte>
    1068:	d1 2f       	mov	r29, r17
    106a:	c0 e0       	ldi	r28, 0x00	; 0
    106c:	90 e0       	ldi	r25, 0x00	; 0
    106e:	8c 2b       	or	r24, r28
    1070:	9d 2b       	or	r25, r29
    1072:	aa 27       	eor	r26, r26
    1074:	97 fd       	sbrc	r25, 7
    1076:	a0 95       	com	r26
    1078:	ba 2f       	mov	r27, r26
    107a:	f4 01       	movw	r30, r8
    107c:	84 83       	std	Z+4, r24	; 0x04
    107e:	95 83       	std	Z+5, r25	; 0x05
    1080:	a6 83       	std	Z+6, r26	; 0x06
    1082:	b7 83       	std	Z+7, r27	; 0x07
    1084:	88 e0       	ldi	r24, 0x08	; 8
    1086:	90 e0       	ldi	r25, 0x00	; 0
    1088:	88 0e       	add	r8, r24
    108a:	99 1e       	adc	r9, r25
}

void EEPROM_read_DataBace (DataBase Data[])
{
	uint16_t CounterR = 0;
	for(uint8_t i = 0;i < NO_OF_CUSTOMERS;i++)
    108c:	9e e1       	ldi	r25, 0x1E	; 30
    108e:	e9 16       	cp	r14, r25
    1090:	f1 04       	cpc	r15, r1
    1092:	09 f0       	breq	.+2      	; 0x1096 <EEPROM_read_DataBace+0xa6>
    1094:	bb cf       	rjmp	.-138    	; 0x100c <EEPROM_read_DataBace+0x1c>
		Data[i].Password = (EEPROM_read_data_byte (CounterR) << 8) | EEPROM_read_data_byte (CounterR+1);
		/*Update Balance Customers*/
		CounterR+=3;
		Data[i].Balance = (EEPROM_read_data_byte (CounterR) << 8) | EEPROM_read_data_byte (CounterR+1);
	}
}
    1096:	df 91       	pop	r29
    1098:	cf 91       	pop	r28
    109a:	1f 91       	pop	r17
    109c:	ff 90       	pop	r15
    109e:	ef 90       	pop	r14
    10a0:	df 90       	pop	r13
    10a2:	cf 90       	pop	r12
    10a4:	bf 90       	pop	r11
    10a6:	af 90       	pop	r10
    10a8:	9f 90       	pop	r9
    10aa:	8f 90       	pop	r8
    10ac:	08 95       	ret

000010ae <EEPROM_write_data_byte>:
	(Check_Size < PAGE_SIZE)?(Check_Size = Size):(Check_Size = PAGE_SIZE-Offset);
	return Check_Size;
}

void EEPROM_write_data_byte (uint16_t Address, uint8_t Data)
{
    10ae:	ff 92       	push	r15
    10b0:	0f 93       	push	r16
    10b2:	1f 93       	push	r17
    10b4:	18 2f       	mov	r17, r24
    10b6:	09 2f       	mov	r16, r25
    10b8:	f6 2e       	mov	r15, r22
	TWI_StartM();
    10ba:	0e 94 4f 00 	call	0x9e	; 0x9e <TWI_StartM>
	TMI_WriteA(EEPROM_ADDR, 	TW_MT_SLA_ACK);
    10be:	80 ea       	ldi	r24, 0xA0	; 160
    10c0:	68 e1       	ldi	r22, 0x18	; 24
    10c2:	0e 94 63 00 	call	0xc6	; 0xc6 <TMI_WriteA>
	TMI_WriteD(Address >> 8,    TW_MT_DATA_ACK);
    10c6:	80 2f       	mov	r24, r16
    10c8:	68 e2       	ldi	r22, 0x28	; 40
    10ca:	0e 94 72 00 	call	0xe4	; 0xe4 <TMI_WriteD>
	TMI_WriteD(Address, 		TW_MT_DATA_ACK);
    10ce:	81 2f       	mov	r24, r17
    10d0:	68 e2       	ldi	r22, 0x28	; 40
    10d2:	0e 94 72 00 	call	0xe4	; 0xe4 <TMI_WriteD>
	TMI_WriteD(Data, 	        TW_MT_DATA_ACK);
    10d6:	8f 2d       	mov	r24, r15
    10d8:	68 e2       	ldi	r22, 0x28	; 40
    10da:	0e 94 72 00 	call	0xe4	; 0xe4 <TMI_WriteD>
	TWI_stop();							/*Withing Next Write*/
    10de:	0e 94 81 00 	call	0x102	; 0x102 <TWI_stop>
    10e2:	82 e0       	ldi	r24, 0x02	; 2
    10e4:	8a 95       	dec	r24
    10e6:	f1 f7       	brne	.-4      	; 0x10e4 <EEPROM_write_data_byte+0x36>
	_delay_us(1);
}
    10e8:	1f 91       	pop	r17
    10ea:	0f 91       	pop	r16
    10ec:	ff 90       	pop	r15
    10ee:	08 95       	ret

000010f0 <EEPROM_write_data_bytes_per_page>:

void EEPROM_write_data_bytes_per_page (uint16_t Page, uint8_t *Data, uint16_t Size)
{
    10f0:	cf 92       	push	r12
    10f2:	df 92       	push	r13
    10f4:	ef 92       	push	r14
    10f6:	ff 92       	push	r15
    10f8:	1f 93       	push	r17
    10fa:	cf 93       	push	r28
    10fc:	df 93       	push	r29
    10fe:	6b 01       	movw	r12, r22
    1100:	7a 01       	movw	r14, r20
	uint16_t Address = Page * PAGE_SIZE;
    1102:	ec 01       	movw	r28, r24
    1104:	95 e0       	ldi	r25, 0x05	; 5
    1106:	cc 0f       	add	r28, r28
    1108:	dd 1f       	adc	r29, r29
    110a:	9a 95       	dec	r25
    110c:	e1 f7       	brne	.-8      	; 0x1106 <EEPROM_write_data_bytes_per_page+0x16>
    110e:	10 e0       	ldi	r17, 0x00	; 0
    1110:	09 c0       	rjmp	.+18     	; 0x1124 <EEPROM_write_data_bytes_per_page+0x34>
	for(uint8_t i = 0;i < Size;i++)
	{
		EEPROM_write_data_byte (Address+i, Data[i]);
    1112:	f6 01       	movw	r30, r12
    1114:	e8 0f       	add	r30, r24
    1116:	f9 1f       	adc	r31, r25
    1118:	8c 0f       	add	r24, r28
    111a:	9d 1f       	adc	r25, r29
    111c:	60 81       	ld	r22, Z
    111e:	0e 94 57 08 	call	0x10ae	; 0x10ae <EEPROM_write_data_byte>
}

void EEPROM_write_data_bytes_per_page (uint16_t Page, uint8_t *Data, uint16_t Size)
{
	uint16_t Address = Page * PAGE_SIZE;
	for(uint8_t i = 0;i < Size;i++)
    1122:	1f 5f       	subi	r17, 0xFF	; 255
    1124:	81 2f       	mov	r24, r17
    1126:	90 e0       	ldi	r25, 0x00	; 0
    1128:	8e 15       	cp	r24, r14
    112a:	9f 05       	cpc	r25, r15
    112c:	90 f3       	brcs	.-28     	; 0x1112 <EEPROM_write_data_bytes_per_page+0x22>
	{
		EEPROM_write_data_byte (Address+i, Data[i]);
	}
}
    112e:	df 91       	pop	r29
    1130:	cf 91       	pop	r28
    1132:	1f 91       	pop	r17
    1134:	ff 90       	pop	r15
    1136:	ef 90       	pop	r14
    1138:	df 90       	pop	r13
    113a:	cf 90       	pop	r12
    113c:	08 95       	ret

0000113e <EEPROM_erase_data_per_page>:
		Data[i] = EEPROM_read_data_byte(Address+i);
	}
}

void EEPROM_erase_data_per_page (uint16_t Page)
{
    113e:	ef 92       	push	r14
    1140:	ff 92       	push	r15
    1142:	0f 93       	push	r16
    1144:	1f 93       	push	r17
    1146:	df 93       	push	r29
    1148:	cf 93       	push	r28
    114a:	cd b7       	in	r28, 0x3d	; 61
    114c:	de b7       	in	r29, 0x3e	; 62
    114e:	a0 97       	sbiw	r28, 0x20	; 32
    1150:	0f b6       	in	r0, 0x3f	; 63
    1152:	f8 94       	cli
    1154:	de bf       	out	0x3e, r29	; 62
    1156:	0f be       	out	0x3f, r0	; 63
    1158:	cd bf       	out	0x3d, r28	; 61
    115a:	7c 01       	movw	r14, r24
	uint8_t data[PAGE_SIZE];
	memset(data,0xFF,PAGE_SIZE);	 /*Write the Data to Fills the Buffer*/
    115c:	8e 01       	movw	r16, r28
    115e:	0f 5f       	subi	r16, 0xFF	; 255
    1160:	1f 4f       	sbci	r17, 0xFF	; 255
    1162:	c8 01       	movw	r24, r16
    1164:	6f ef       	ldi	r22, 0xFF	; 255
    1166:	70 e0       	ldi	r23, 0x00	; 0
    1168:	40 e2       	ldi	r20, 0x20	; 32
    116a:	50 e0       	ldi	r21, 0x00	; 0
    116c:	0e 94 20 24 	call	0x4840	; 0x4840 <memset>
	/*I2C Write the Data to the EEPROM*/
	EEPROM_write_data_bytes_per_page (Page,data,PAGE_SIZE);
    1170:	c7 01       	movw	r24, r14
    1172:	b8 01       	movw	r22, r16
    1174:	40 e2       	ldi	r20, 0x20	; 32
    1176:	50 e0       	ldi	r21, 0x00	; 0
    1178:	0e 94 78 08 	call	0x10f0	; 0x10f0 <EEPROM_write_data_bytes_per_page>
}
    117c:	a0 96       	adiw	r28, 0x20	; 32
    117e:	0f b6       	in	r0, 0x3f	; 63
    1180:	f8 94       	cli
    1182:	de bf       	out	0x3e, r29	; 62
    1184:	0f be       	out	0x3f, r0	; 63
    1186:	cd bf       	out	0x3d, r28	; 61
    1188:	cf 91       	pop	r28
    118a:	df 91       	pop	r29
    118c:	1f 91       	pop	r17
    118e:	0f 91       	pop	r16
    1190:	ff 90       	pop	r15
    1192:	ef 90       	pop	r14
    1194:	08 95       	ret

00001196 <EEPROM_write_DataBace>:
{
	TWI_InitM();
}

void EEPROM_write_DataBace (DataBase Data[])
{
    1196:	ef 92       	push	r14
    1198:	ff 92       	push	r15
    119a:	0f 93       	push	r16
    119c:	1f 93       	push	r17
    119e:	cf 93       	push	r28
    11a0:	df 93       	push	r29
    11a2:	18 2f       	mov	r17, r24
    11a4:	09 2f       	mov	r16, r25
	uint16_t EepromCounterW = 0;
	EEPROM_write_data_byte (EepromCounterW++,NO_OF_CUSTOMERS);
    11a6:	80 e0       	ldi	r24, 0x00	; 0
    11a8:	90 e0       	ldi	r25, 0x00	; 0
    11aa:	65 e0       	ldi	r22, 0x05	; 5
    11ac:	0e 94 57 08 	call	0x10ae	; 0x10ae <EEPROM_write_data_byte>
    11b0:	21 2f       	mov	r18, r17
    11b2:	30 2f       	mov	r19, r16
    11b4:	c9 01       	movw	r24, r18
    11b6:	7c 01       	movw	r14, r24
    11b8:	c1 e0       	ldi	r28, 0x01	; 1
    11ba:	d0 e0       	ldi	r29, 0x00	; 0
	for(uint8_t i = 0;i < NO_OF_CUSTOMERS;i++)
	{
		/*Update IDs Customers*/
		EEPROM_write_data_byte (EepromCounterW++,Data[i].ID >> 8);
    11bc:	f7 01       	movw	r30, r14
    11be:	61 81       	ldd	r22, Z+1	; 0x01
    11c0:	ce 01       	movw	r24, r28
    11c2:	0e 94 57 08 	call	0x10ae	; 0x10ae <EEPROM_write_data_byte>
		EEPROM_write_data_byte (EepromCounterW++,Data[i].ID);
    11c6:	ce 01       	movw	r24, r28
    11c8:	01 96       	adiw	r24, 0x01	; 1
    11ca:	f7 01       	movw	r30, r14
    11cc:	60 81       	ld	r22, Z
    11ce:	0e 94 57 08 	call	0x10ae	; 0x10ae <EEPROM_write_data_byte>
		/*Update Passwords Customers*/
		EEPROM_write_data_byte (EepromCounterW++,Data[i].Password >> 8);
    11d2:	f7 01       	movw	r30, r14
    11d4:	63 81       	ldd	r22, Z+3	; 0x03
    11d6:	ce 01       	movw	r24, r28
    11d8:	02 96       	adiw	r24, 0x02	; 2
    11da:	0e 94 57 08 	call	0x10ae	; 0x10ae <EEPROM_write_data_byte>
		EEPROM_write_data_byte (EepromCounterW++,Data[i].Password);
    11de:	ce 01       	movw	r24, r28
    11e0:	03 96       	adiw	r24, 0x03	; 3
    11e2:	f7 01       	movw	r30, r14
    11e4:	62 81       	ldd	r22, Z+2	; 0x02
    11e6:	0e 94 57 08 	call	0x10ae	; 0x10ae <EEPROM_write_data_byte>
    11ea:	8e 01       	movw	r16, r28
    11ec:	0b 5f       	subi	r16, 0xFB	; 251
    11ee:	1f 4f       	sbci	r17, 0xFF	; 255
		/*Update Balance Customers*/
		EEPROM_write_data_byte (EepromCounterW++,Data[i].Balance >> 8);
    11f0:	f7 01       	movw	r30, r14
    11f2:	24 81       	ldd	r18, Z+4	; 0x04
    11f4:	35 81       	ldd	r19, Z+5	; 0x05
    11f6:	46 81       	ldd	r20, Z+6	; 0x06
    11f8:	57 81       	ldd	r21, Z+7	; 0x07
    11fa:	23 2f       	mov	r18, r19
    11fc:	34 2f       	mov	r19, r20
    11fe:	45 2f       	mov	r20, r21
    1200:	55 27       	eor	r21, r21
    1202:	ce 01       	movw	r24, r28
    1204:	04 96       	adiw	r24, 0x04	; 4
    1206:	62 2f       	mov	r22, r18
    1208:	0e 94 57 08 	call	0x10ae	; 0x10ae <EEPROM_write_data_byte>
    120c:	26 96       	adiw	r28, 0x06	; 6
		EEPROM_write_data_byte (EepromCounterW++,Data[i].Balance);
    120e:	c8 01       	movw	r24, r16
    1210:	f7 01       	movw	r30, r14
    1212:	64 81       	ldd	r22, Z+4	; 0x04
    1214:	0e 94 57 08 	call	0x10ae	; 0x10ae <EEPROM_write_data_byte>
    1218:	88 e0       	ldi	r24, 0x08	; 8
    121a:	90 e0       	ldi	r25, 0x00	; 0
    121c:	e8 0e       	add	r14, r24
    121e:	f9 1e       	adc	r15, r25

void EEPROM_write_DataBace (DataBase Data[])
{
	uint16_t EepromCounterW = 0;
	EEPROM_write_data_byte (EepromCounterW++,NO_OF_CUSTOMERS);
	for(uint8_t i = 0;i < NO_OF_CUSTOMERS;i++)
    1220:	cf 31       	cpi	r28, 0x1F	; 31
    1222:	d1 05       	cpc	r29, r1
    1224:	59 f6       	brne	.-106    	; 0x11bc <EEPROM_write_DataBace+0x26>
		EEPROM_write_data_byte (EepromCounterW++,Data[i].Password);
		/*Update Balance Customers*/
		EEPROM_write_data_byte (EepromCounterW++,Data[i].Balance >> 8);
		EEPROM_write_data_byte (EepromCounterW++,Data[i].Balance);
	}
}
    1226:	df 91       	pop	r29
    1228:	cf 91       	pop	r28
    122a:	1f 91       	pop	r17
    122c:	0f 91       	pop	r16
    122e:	ff 90       	pop	r15
    1230:	ef 90       	pop	r14
    1232:	08 95       	ret

00001234 <EEPROM_VidInit>:



void EEPROM_VidInit (void)
{
	TWI_InitM();
    1234:	0e 94 49 00 	call	0x92	; 0x92 <TWI_InitM>
}
    1238:	08 95       	ret

0000123a <xEventGroupClearBits>:
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    123a:	fc 01       	movw	r30, r24
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    123c:	0f b6       	in	r0, 0x3f	; 63
    123e:	f8 94       	cli
    1240:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    1242:	20 81       	ld	r18, Z
    1244:	31 81       	ldd	r19, Z+1	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1246:	60 95       	com	r22
    1248:	70 95       	com	r23
    124a:	62 23       	and	r22, r18
    124c:	73 23       	and	r23, r19
    124e:	71 83       	std	Z+1, r23	; 0x01
    1250:	60 83       	st	Z, r22
    }
    taskEXIT_CRITICAL();
    1252:	0f 90       	pop	r0
    1254:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
}
    1256:	c9 01       	movw	r24, r18
    1258:	08 95       	ret

0000125a <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    125a:	fc 01       	movw	r30, r24
        uxReturn = pxEventBits->uxEventBits;
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    125c:	80 81       	ld	r24, Z
    125e:	91 81       	ldd	r25, Z+1	; 0x01
    1260:	08 95       	ret

00001262 <vEventGroupClearBitsCallback>:
/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1262:	ba 01       	movw	r22, r20
    1264:	0e 94 1d 09 	call	0x123a	; 0x123a <xEventGroupClearBits>
}
    1268:	08 95       	ret

0000126a <vEventGroupDelete>:
    return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    126a:	cf 93       	push	r28
    126c:	df 93       	push	r29
    126e:	ec 01       	movw	r28, r24

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

    vTaskSuspendAll();
    1270:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <vTaskSuspendAll>
    1274:	06 c0       	rjmp	.+12     	; 0x1282 <vEventGroupDelete+0x18>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1276:	8f 81       	ldd	r24, Y+7	; 0x07
    1278:	98 85       	ldd	r25, Y+8	; 0x08
    127a:	60 e0       	ldi	r22, 0x00	; 0
    127c:	72 e0       	ldi	r23, 0x02	; 2
    127e:	0e 94 0a 18 	call	0x3014	; 0x3014 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1282:	8a 81       	ldd	r24, Y+2	; 0x02
    1284:	88 23       	and	r24, r24
    1286:	b9 f7       	brne	.-18     	; 0x1276 <vEventGroupDelete+0xc>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    1288:	ce 01       	movw	r24, r28
    128a:	0e 94 a5 0a 	call	0x154a	; 0x154a <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    128e:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
}
    1292:	df 91       	pop	r29
    1294:	cf 91       	pop	r28
    1296:	08 95       	ret

00001298 <xEventGroupSetBits>:
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1298:	cf 92       	push	r12
    129a:	df 92       	push	r13
    129c:	ef 92       	push	r14
    129e:	ff 92       	push	r15
    12a0:	0f 93       	push	r16
    12a2:	1f 93       	push	r17
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	ec 01       	movw	r28, r24
    12aa:	8b 01       	movw	r16, r22
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12ac:	85 e0       	ldi	r24, 0x05	; 5
    12ae:	e8 2e       	mov	r14, r24
    12b0:	f1 2c       	mov	r15, r1
    12b2:	ec 0e       	add	r14, r28
    12b4:	fd 1e       	adc	r15, r29
    vTaskSuspendAll();
    12b6:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    12ba:	ef 81       	ldd	r30, Y+7	; 0x07
    12bc:	f8 85       	ldd	r31, Y+8	; 0x08

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    12be:	88 81       	ld	r24, Y
    12c0:	99 81       	ldd	r25, Y+1	; 0x01
    12c2:	80 2b       	or	r24, r16
    12c4:	91 2b       	or	r25, r17
    12c6:	99 83       	std	Y+1, r25	; 0x01
    12c8:	88 83       	st	Y, r24
    12ca:	00 e0       	ldi	r16, 0x00	; 0
    12cc:	10 e0       	ldi	r17, 0x00	; 0
    12ce:	24 c0       	rjmp	.+72     	; 0x1318 <xEventGroupSetBits+0x80>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    12d0:	d2 80       	ldd	r13, Z+2	; 0x02
    12d2:	c3 80       	ldd	r12, Z+3	; 0x03
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    12d4:	80 81       	ld	r24, Z
    12d6:	91 81       	ldd	r25, Z+1	; 0x01
            xMatchFound = pdFALSE;

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    12d8:	bc 01       	movw	r22, r24
    12da:	60 70       	andi	r22, 0x00	; 0
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    12dc:	ac 01       	movw	r20, r24
    12de:	50 70       	andi	r21, 0x00	; 0
    12e0:	28 81       	ld	r18, Y
    12e2:	39 81       	ldd	r19, Y+1	; 0x01

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    12e4:	92 fd       	sbrc	r25, 2
    12e6:	05 c0       	rjmp	.+10     	; 0x12f2 <xEventGroupSetBits+0x5a>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    12e8:	24 23       	and	r18, r20
    12ea:	35 23       	and	r19, r21
    12ec:	23 2b       	or	r18, r19
    12ee:	31 f4       	brne	.+12     	; 0x12fc <xEventGroupSetBits+0x64>
    12f0:	0f c0       	rjmp	.+30     	; 0x1310 <xEventGroupSetBits+0x78>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    12f2:	24 23       	and	r18, r20
    12f4:	35 23       	and	r19, r21
    12f6:	24 17       	cp	r18, r20
    12f8:	35 07       	cpc	r19, r21
    12fa:	51 f4       	brne	.+20     	; 0x1310 <xEventGroupSetBits+0x78>
            }

            if( xMatchFound != pdFALSE )
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    12fc:	70 ff       	sbrs	r23, 0
    12fe:	02 c0       	rjmp	.+4      	; 0x1304 <xEventGroupSetBits+0x6c>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    1300:	04 2b       	or	r16, r20
    1302:	15 2b       	or	r17, r21
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1304:	68 81       	ld	r22, Y
    1306:	79 81       	ldd	r23, Y+1	; 0x01
    1308:	72 60       	ori	r23, 0x02	; 2
    130a:	cf 01       	movw	r24, r30
    130c:	0e 94 0a 18 	call	0x3014	; 0x3014 <vTaskRemoveFromUnorderedEventList>
    1310:	8d 2d       	mov	r24, r13
    1312:	9c 2d       	mov	r25, r12
    1314:	9c 01       	movw	r18, r24
    1316:	f9 01       	movw	r30, r18

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    1318:	ee 15       	cp	r30, r14
    131a:	ff 05       	cpc	r31, r15
    131c:	c9 f6       	brne	.-78     	; 0x12d0 <xEventGroupSetBits+0x38>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    131e:	00 95       	com	r16
    1320:	10 95       	com	r17
    1322:	88 81       	ld	r24, Y
    1324:	99 81       	ldd	r25, Y+1	; 0x01
    1326:	80 23       	and	r24, r16
    1328:	91 23       	and	r25, r17
    132a:	99 83       	std	Y+1, r25	; 0x01
    132c:	88 83       	st	Y, r24
    }
    ( void ) xTaskResumeAll();
    132e:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
}
    1332:	88 81       	ld	r24, Y
    1334:	99 81       	ldd	r25, Y+1	; 0x01
    1336:	df 91       	pop	r29
    1338:	cf 91       	pop	r28
    133a:	1f 91       	pop	r17
    133c:	0f 91       	pop	r16
    133e:	ff 90       	pop	r15
    1340:	ef 90       	pop	r14
    1342:	df 90       	pop	r13
    1344:	cf 90       	pop	r12
    1346:	08 95       	ret

00001348 <vEventGroupSetBitsCallback>:
/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1348:	ba 01       	movw	r22, r20
    134a:	0e 94 4c 09 	call	0x1298	; 0x1298 <xEventGroupSetBits>
}
    134e:	08 95       	ret

00001350 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1350:	af 92       	push	r10
    1352:	bf 92       	push	r11
    1354:	cf 92       	push	r12
    1356:	df 92       	push	r13
    1358:	ef 92       	push	r14
    135a:	ff 92       	push	r15
    135c:	0f 93       	push	r16
    135e:	1f 93       	push	r17
    1360:	cf 93       	push	r28
    1362:	df 93       	push	r29
    1364:	6c 01       	movw	r12, r24
    1366:	7b 01       	movw	r14, r22
    1368:	a4 2e       	mov	r10, r20
    136a:	b2 2e       	mov	r11, r18
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    136c:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1370:	f6 01       	movw	r30, r12
    1372:	20 81       	ld	r18, Z
    1374:	31 81       	ldd	r19, Z+1	; 0x01
    1376:	c7 01       	movw	r24, r14
    1378:	82 23       	and	r24, r18
    137a:	93 23       	and	r25, r19
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    BaseType_t xWaitConditionMet = pdFALSE;

    if( xWaitForAllBits == pdFALSE )
    137c:	bb 20       	and	r11, r11
    137e:	21 f4       	brne	.+8      	; 0x1388 <xEventGroupWaitBits+0x38>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1380:	89 2b       	or	r24, r25
    1382:	09 f0       	breq	.+2      	; 0x1386 <xEventGroupWaitBits+0x36>
    1384:	5a c0       	rjmp	.+180    	; 0x143a <xEventGroupWaitBits+0xea>
    1386:	04 c0       	rjmp	.+8      	; 0x1390 <xEventGroupWaitBits+0x40>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1388:	8e 15       	cp	r24, r14
    138a:	9f 05       	cpc	r25, r15
    138c:	09 f4       	brne	.+2      	; 0x1390 <xEventGroupWaitBits+0x40>
    138e:	55 c0       	rjmp	.+170    	; 0x143a <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    1390:	01 15       	cp	r16, r1
    1392:	11 05       	cpc	r17, r1
    1394:	59 f4       	brne	.+22     	; 0x13ac <xEventGroupWaitBits+0x5c>
    1396:	e9 01       	movw	r28, r18
    1398:	1b c0       	rjmp	.+54     	; 0x13d0 <xEventGroupWaitBits+0x80>
            xTicksToWait = ( TickType_t ) 0;

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    139a:	c7 01       	movw	r24, r14
    139c:	80 95       	com	r24
    139e:	90 95       	com	r25
    13a0:	82 23       	and	r24, r18
    13a2:	93 23       	and	r25, r19
    13a4:	f6 01       	movw	r30, r12
    13a6:	91 83       	std	Z+1, r25	; 0x01
    13a8:	80 83       	st	Z, r24
    13aa:	4a c0       	rjmp	.+148    	; 0x1440 <xEventGroupWaitBits+0xf0>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    13ac:	aa 20       	and	r10, r10
    13ae:	19 f0       	breq	.+6      	; 0x13b6 <xEventGroupWaitBits+0x66>
    13b0:	60 e0       	ldi	r22, 0x00	; 0
    13b2:	71 e0       	ldi	r23, 0x01	; 1
    13b4:	02 c0       	rjmp	.+4      	; 0x13ba <xEventGroupWaitBits+0x6a>
    13b6:	60 e0       	ldi	r22, 0x00	; 0
    13b8:	70 e0       	ldi	r23, 0x00	; 0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    13ba:	b1 10       	cpse	r11, r1
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    13bc:	74 60       	ori	r23, 0x04	; 4
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    13be:	6e 29       	or	r22, r14
    13c0:	7f 29       	or	r23, r15
    13c2:	c6 01       	movw	r24, r12
    13c4:	02 96       	adiw	r24, 0x02	; 2
    13c6:	a8 01       	movw	r20, r16
    13c8:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <vTaskPlaceOnUnorderedEventList>
    13cc:	c0 e0       	ldi	r28, 0x00	; 0
    13ce:	d0 e0       	ldi	r29, 0x00	; 0
            uxReturn = 0;

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    13d0:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>

    if( xTicksToWait != ( TickType_t ) 0 )
    13d4:	01 2b       	or	r16, r17
    13d6:	29 f1       	breq	.+74     	; 0x1422 <xEventGroupWaitBits+0xd2>
    {
        if( xAlreadyYielded == pdFALSE )
    13d8:	88 23       	and	r24, r24
    13da:	11 f4       	brne	.+4      	; 0x13e0 <xEventGroupWaitBits+0x90>
        {
            portYIELD_WITHIN_API();
    13dc:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    13e0:	0e 94 fe 18 	call	0x31fc	; 0x31fc <uxTaskResetEventItemValue>

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    13e4:	91 fd       	sbrc	r25, 1
    13e6:	1b c0       	rjmp	.+54     	; 0x141e <xEventGroupWaitBits+0xce>
        {
            taskENTER_CRITICAL();
    13e8:	0f b6       	in	r0, 0x3f	; 63
    13ea:	f8 94       	cli
    13ec:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    13ee:	f6 01       	movw	r30, r12
    13f0:	80 81       	ld	r24, Z
    13f2:	91 81       	ldd	r25, Z+1	; 0x01
    13f4:	97 01       	movw	r18, r14
    13f6:	28 23       	and	r18, r24
    13f8:	39 23       	and	r19, r25
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    BaseType_t xWaitConditionMet = pdFALSE;

    if( xWaitForAllBits == pdFALSE )
    13fa:	bb 20       	and	r11, r11
    13fc:	19 f4       	brne	.+6      	; 0x1404 <xEventGroupWaitBits+0xb4>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    13fe:	23 2b       	or	r18, r19
    1400:	19 f5       	brne	.+70     	; 0x1448 <xEventGroupWaitBits+0xf8>
    1402:	0b c0       	rjmp	.+22     	; 0x141a <xEventGroupWaitBits+0xca>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1404:	2e 15       	cp	r18, r14
    1406:	3f 05       	cpc	r19, r15
    1408:	41 f4       	brne	.+16     	; 0x141a <xEventGroupWaitBits+0xca>
    140a:	1e c0       	rjmp	.+60     	; 0x1448 <xEventGroupWaitBits+0xf8>
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
                {
                    if( xClearOnExit != pdFALSE )
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    140c:	e0 94       	com	r14
    140e:	f0 94       	com	r15
    1410:	e8 22       	and	r14, r24
    1412:	f9 22       	and	r15, r25
    1414:	f6 01       	movw	r30, r12
    1416:	f1 82       	std	Z+1, r15	; 0x01
    1418:	e0 82       	st	Z, r14
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
            }
            taskEXIT_CRITICAL();
    141a:	0f 90       	pop	r0
    141c:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    141e:	ec 01       	movw	r28, r24
    1420:	d0 70       	andi	r29, 0x00	; 0

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
}
    1422:	ce 01       	movw	r24, r28
    1424:	df 91       	pop	r29
    1426:	cf 91       	pop	r28
    1428:	1f 91       	pop	r17
    142a:	0f 91       	pop	r16
    142c:	ff 90       	pop	r15
    142e:	ef 90       	pop	r14
    1430:	df 90       	pop	r13
    1432:	cf 90       	pop	r12
    1434:	bf 90       	pop	r11
    1436:	af 90       	pop	r10
    1438:	08 95       	ret
             * block. */
            uxReturn = uxCurrentEventBits;
            xTicksToWait = ( TickType_t ) 0;

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    143a:	aa 20       	and	r10, r10
    143c:	09 f0       	breq	.+2      	; 0x1440 <xEventGroupWaitBits+0xf0>
    143e:	ad cf       	rjmp	.-166    	; 0x139a <xEventGroupWaitBits+0x4a>
    1440:	e9 01       	movw	r28, r18
    1442:	00 e0       	ldi	r16, 0x00	; 0
    1444:	10 e0       	ldi	r17, 0x00	; 0
    1446:	c4 cf       	rjmp	.-120    	; 0x13d0 <xEventGroupWaitBits+0x80>

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
                {
                    if( xClearOnExit != pdFALSE )
    1448:	aa 20       	and	r10, r10
    144a:	01 f7       	brne	.-64     	; 0x140c <xEventGroupWaitBits+0xbc>
    144c:	e6 cf       	rjmp	.-52     	; 0x141a <xEventGroupWaitBits+0xca>

0000144e <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    144e:	af 92       	push	r10
    1450:	bf 92       	push	r11
    1452:	cf 92       	push	r12
    1454:	df 92       	push	r13
    1456:	ef 92       	push	r14
    1458:	ff 92       	push	r15
    145a:	0f 93       	push	r16
    145c:	1f 93       	push	r17
    145e:	cf 93       	push	r28
    1460:	df 93       	push	r29
    1462:	6c 01       	movw	r12, r24
    1464:	8b 01       	movw	r16, r22
    1466:	7a 01       	movw	r14, r20
    1468:	59 01       	movw	r10, r18
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    146a:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    146e:	f6 01       	movw	r30, r12
    1470:	c0 81       	ld	r28, Z
    1472:	d1 81       	ldd	r29, Z+1	; 0x01

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1474:	c6 01       	movw	r24, r12
    1476:	b8 01       	movw	r22, r16
    1478:	0e 94 4c 09 	call	0x1298	; 0x1298 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    147c:	c0 2b       	or	r28, r16
    147e:	d1 2b       	or	r29, r17
    1480:	c7 01       	movw	r24, r14
    1482:	8c 23       	and	r24, r28
    1484:	9d 23       	and	r25, r29
    1486:	8e 15       	cp	r24, r14
    1488:	9f 05       	cpc	r25, r15
    148a:	69 f4       	brne	.+26     	; 0x14a6 <xEventGroupSync+0x58>
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    148c:	97 01       	movw	r18, r14
    148e:	20 95       	com	r18
    1490:	30 95       	com	r19
    1492:	f6 01       	movw	r30, r12
    1494:	80 81       	ld	r24, Z
    1496:	91 81       	ldd	r25, Z+1	; 0x01
    1498:	82 23       	and	r24, r18
    149a:	93 23       	and	r25, r19
    149c:	91 83       	std	Z+1, r25	; 0x01
    149e:	80 83       	st	Z, r24
    14a0:	aa 24       	eor	r10, r10
    14a2:	bb 24       	eor	r11, r11
    14a4:	10 c0       	rjmp	.+32     	; 0x14c6 <xEventGroupSync+0x78>

            xTicksToWait = 0;
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    14a6:	a1 14       	cp	r10, r1
    14a8:	b1 04       	cpc	r11, r1
    14aa:	51 f0       	breq	.+20     	; 0x14c0 <xEventGroupSync+0x72>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    14ac:	b7 01       	movw	r22, r14
    14ae:	75 60       	ori	r23, 0x05	; 5
    14b0:	c6 01       	movw	r24, r12
    14b2:	02 96       	adiw	r24, 0x02	; 2
    14b4:	a5 01       	movw	r20, r10
    14b6:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <vTaskPlaceOnUnorderedEventList>
    14ba:	c0 e0       	ldi	r28, 0x00	; 0
    14bc:	d0 e0       	ldi	r29, 0x00	; 0
    14be:	03 c0       	rjmp	.+6      	; 0x14c6 <xEventGroupSync+0x78>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    14c0:	f6 01       	movw	r30, r12
    14c2:	c0 81       	ld	r28, Z
    14c4:	d1 81       	ldd	r29, Z+1	; 0x01
                xTimeoutOccurred = pdTRUE;
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    14c6:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>

    if( xTicksToWait != ( TickType_t ) 0 )
    14ca:	ab 28       	or	r10, r11
    14cc:	f9 f0       	breq	.+62     	; 0x150c <xEventGroupSync+0xbe>
    {
        if( xAlreadyYielded == pdFALSE )
    14ce:	88 23       	and	r24, r24
    14d0:	11 f4       	brne	.+4      	; 0x14d6 <xEventGroupSync+0x88>
        {
            portYIELD_WITHIN_API();
    14d2:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    14d6:	0e 94 fe 18 	call	0x31fc	; 0x31fc <uxTaskResetEventItemValue>
    14da:	9c 01       	movw	r18, r24

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    14dc:	91 fd       	sbrc	r25, 1
    14de:	14 c0       	rjmp	.+40     	; 0x1508 <xEventGroupSync+0xba>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    14e0:	0f b6       	in	r0, 0x3f	; 63
    14e2:	f8 94       	cli
    14e4:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    14e6:	f6 01       	movw	r30, r12
    14e8:	20 81       	ld	r18, Z
    14ea:	31 81       	ldd	r19, Z+1	; 0x01

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    14ec:	c7 01       	movw	r24, r14
    14ee:	82 23       	and	r24, r18
    14f0:	93 23       	and	r25, r19
    14f2:	8e 15       	cp	r24, r14
    14f4:	9f 05       	cpc	r25, r15
    14f6:	31 f4       	brne	.+12     	; 0x1504 <xEventGroupSync+0xb6>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    14f8:	e0 94       	com	r14
    14fa:	f0 94       	com	r15
    14fc:	e2 22       	and	r14, r18
    14fe:	f3 22       	and	r15, r19
    1500:	f1 82       	std	Z+1, r15	; 0x01
    1502:	e0 82       	st	Z, r14
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    1504:	0f 90       	pop	r0
    1506:	0f be       	out	0x3f, r0	; 63
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1508:	e9 01       	movw	r28, r18
    150a:	d0 70       	andi	r29, 0x00	; 0

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
}
    150c:	ce 01       	movw	r24, r28
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	1f 91       	pop	r17
    1514:	0f 91       	pop	r16
    1516:	ff 90       	pop	r15
    1518:	ef 90       	pop	r14
    151a:	df 90       	pop	r13
    151c:	cf 90       	pop	r12
    151e:	bf 90       	pop	r11
    1520:	af 90       	pop	r10
    1522:	08 95       	ret

00001524 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1524:	cf 93       	push	r28
    1526:	df 93       	push	r29
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1528:	8b e0       	ldi	r24, 0x0B	; 11
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	0e 94 b5 0a 	call	0x156a	; 0x156a <pvPortMalloc>
    1530:	ec 01       	movw	r28, r24

        if( pxEventBits != NULL )
    1532:	00 97       	sbiw	r24, 0x00	; 0
    1534:	31 f0       	breq	.+12     	; 0x1542 <xEventGroupCreate+0x1e>
        {
            pxEventBits->uxEventBits = 0;
    1536:	fc 01       	movw	r30, r24
    1538:	11 92       	st	Z+, r1
    153a:	11 92       	st	Z+, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    153c:	cf 01       	movw	r24, r30
    153e:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInitialise>
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    }
    1542:	ce 01       	movw	r24, r28
    1544:	df 91       	pop	r29
    1546:	cf 91       	pop	r28
    1548:	08 95       	ret

0000154a <vPortFree>:
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
    154a:	08 95       	ret

0000154c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
    154c:	10 92 27 01 	sts	0x0127, r1
    1550:	10 92 26 01 	sts	0x0126, r1
}
    1554:	08 95       	ret

00001556 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1556:	27 e7       	ldi	r18, 0x77	; 119
    1558:	35 e0       	ldi	r19, 0x05	; 5
    155a:	80 91 26 01 	lds	r24, 0x0126
    155e:	90 91 27 01 	lds	r25, 0x0127
    1562:	28 1b       	sub	r18, r24
    1564:	39 0b       	sbc	r19, r25
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
    1566:	c9 01       	movw	r24, r18
    1568:	08 95       	ret

0000156a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    156a:	cf 93       	push	r28
    156c:	df 93       	push	r29
    156e:	ec 01       	movw	r28, r24
                }
            }
        }
    #endif

    vTaskSuspendAll();
    1570:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    1574:	80 91 28 01 	lds	r24, 0x0128
    1578:	90 91 29 01 	lds	r25, 0x0129
    157c:	89 2b       	or	r24, r25
    157e:	31 f4       	brne	.+12     	; 0x158c <pvPortMalloc+0x22>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1580:	8a e2       	ldi	r24, 0x2A	; 42
    1582:	91 e0       	ldi	r25, 0x01	; 1
    1584:	90 93 29 01 	sts	0x0129, r25
    1588:	80 93 28 01 	sts	0x0128, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
    158c:	20 97       	sbiw	r28, 0x00	; 0
    158e:	c9 f0       	breq	.+50     	; 0x15c2 <pvPortMalloc+0x58>
    1590:	20 91 26 01 	lds	r18, 0x0126
    1594:	30 91 27 01 	lds	r19, 0x0127
    1598:	ce 01       	movw	r24, r28
    159a:	82 0f       	add	r24, r18
    159c:	93 1f       	adc	r25, r19
    159e:	45 e0       	ldi	r20, 0x05	; 5
    15a0:	87 37       	cpi	r24, 0x77	; 119
    15a2:	94 07       	cpc	r25, r20
    15a4:	70 f4       	brcc	.+28     	; 0x15c2 <pvPortMalloc+0x58>
    15a6:	28 17       	cp	r18, r24
    15a8:	39 07       	cpc	r19, r25
    15aa:	58 f4       	brcc	.+22     	; 0x15c2 <pvPortMalloc+0x58>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    15ac:	c0 91 28 01 	lds	r28, 0x0128
    15b0:	d0 91 29 01 	lds	r29, 0x0129
    15b4:	c2 0f       	add	r28, r18
    15b6:	d3 1f       	adc	r29, r19
            xNextFreeByte += xWantedSize;
    15b8:	90 93 27 01 	sts	0x0127, r25
    15bc:	80 93 26 01 	sts	0x0126, r24
    15c0:	02 c0       	rjmp	.+4      	; 0x15c6 <pvPortMalloc+0x5c>
    15c2:	c0 e0       	ldi	r28, 0x00	; 0
    15c4:	d0 e0       	ldi	r29, 0x00	; 0
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    15c6:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
            }
        }
    #endif

    return pvReturn;
}
    15ca:	ce 01       	movw	r24, r28
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	08 95       	ret

000015d2 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    15d2:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15d4:	9c 01       	movw	r18, r24
    15d6:	2d 5f       	subi	r18, 0xFD	; 253
    15d8:	3f 4f       	sbci	r19, 0xFF	; 255
    15da:	32 83       	std	Z+2, r19	; 0x02
    15dc:	21 83       	std	Z+1, r18	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    15de:	8f ef       	ldi	r24, 0xFF	; 255
    15e0:	9f ef       	ldi	r25, 0xFF	; 255
    15e2:	94 83       	std	Z+4, r25	; 0x04
    15e4:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15e6:	36 83       	std	Z+6, r19	; 0x06
    15e8:	25 83       	std	Z+5, r18	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15ea:	30 87       	std	Z+8, r19	; 0x08
    15ec:	27 83       	std	Z+7, r18	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    15ee:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    15f0:	08 95       	ret

000015f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    15f2:	fc 01       	movw	r30, r24
    15f4:	11 86       	std	Z+9, r1	; 0x09
    15f6:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    15f8:	08 95       	ret

000015fa <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    15fa:	ac 01       	movw	r20, r24
    ListItem_t * const pxIndex = pxList->pxIndex;
    15fc:	fc 01       	movw	r30, r24
    15fe:	a1 81       	ldd	r26, Z+1	; 0x01
    1600:	b2 81       	ldd	r27, Z+2	; 0x02
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1602:	fb 01       	movw	r30, r22
    1604:	b3 83       	std	Z+3, r27	; 0x03
    1606:	a2 83       	std	Z+2, r26	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1608:	14 96       	adiw	r26, 0x04	; 4
    160a:	8d 91       	ld	r24, X+
    160c:	9c 91       	ld	r25, X
    160e:	15 97       	sbiw	r26, 0x05	; 5
    1610:	95 83       	std	Z+5, r25	; 0x05
    1612:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1614:	14 96       	adiw	r26, 0x04	; 4
    1616:	ed 91       	ld	r30, X+
    1618:	fc 91       	ld	r31, X
    161a:	15 97       	sbiw	r26, 0x05	; 5
    161c:	73 83       	std	Z+3, r23	; 0x03
    161e:	62 83       	std	Z+2, r22	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    1620:	15 96       	adiw	r26, 0x05	; 5
    1622:	7c 93       	st	X, r23
    1624:	6e 93       	st	-X, r22
    1626:	14 97       	sbiw	r26, 0x04	; 4

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1628:	fb 01       	movw	r30, r22
    162a:	51 87       	std	Z+9, r21	; 0x09
    162c:	40 87       	std	Z+8, r20	; 0x08

    ( pxList->uxNumberOfItems )++;
    162e:	fa 01       	movw	r30, r20
    1630:	80 81       	ld	r24, Z
    1632:	8f 5f       	subi	r24, 0xFF	; 255
    1634:	80 83       	st	Z, r24
}
    1636:	08 95       	ret

00001638 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1638:	cf 93       	push	r28
    163a:	df 93       	push	r29
    163c:	9c 01       	movw	r18, r24
    163e:	eb 01       	movw	r28, r22
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1640:	48 81       	ld	r20, Y
    1642:	59 81       	ldd	r21, Y+1	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1644:	8f ef       	ldi	r24, 0xFF	; 255
    1646:	4f 3f       	cpi	r20, 0xFF	; 255
    1648:	58 07       	cpc	r21, r24
    164a:	21 f4       	brne	.+8      	; 0x1654 <vListInsert+0x1c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    164c:	f9 01       	movw	r30, r18
    164e:	a7 81       	ldd	r26, Z+7	; 0x07
    1650:	b0 85       	ldd	r27, Z+8	; 0x08
    1652:	0d c0       	rjmp	.+26     	; 0x166e <vListInsert+0x36>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1654:	d9 01       	movw	r26, r18
    1656:	13 96       	adiw	r26, 0x03	; 3
    1658:	12 96       	adiw	r26, 0x02	; 2
    165a:	ed 91       	ld	r30, X+
    165c:	fc 91       	ld	r31, X
    165e:	13 97       	sbiw	r26, 0x03	; 3
    1660:	80 81       	ld	r24, Z
    1662:	91 81       	ldd	r25, Z+1	; 0x01
    1664:	48 17       	cp	r20, r24
    1666:	59 07       	cpc	r21, r25
    1668:	10 f0       	brcs	.+4      	; 0x166e <vListInsert+0x36>
    166a:	df 01       	movw	r26, r30
    166c:	f5 cf       	rjmp	.-22     	; 0x1658 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    166e:	12 96       	adiw	r26, 0x02	; 2
    1670:	ed 91       	ld	r30, X+
    1672:	fc 91       	ld	r31, X
    1674:	13 97       	sbiw	r26, 0x03	; 3
    1676:	fb 83       	std	Y+3, r31	; 0x03
    1678:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    167a:	d5 83       	std	Z+5, r29	; 0x05
    167c:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    167e:	bd 83       	std	Y+5, r27	; 0x05
    1680:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1682:	13 96       	adiw	r26, 0x03	; 3
    1684:	dc 93       	st	X, r29
    1686:	ce 93       	st	-X, r28
    1688:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    168a:	39 87       	std	Y+9, r19	; 0x09
    168c:	28 87       	std	Y+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    168e:	f9 01       	movw	r30, r18
    1690:	80 81       	ld	r24, Z
    1692:	8f 5f       	subi	r24, 0xFF	; 255
    1694:	80 83       	st	Z, r24
}
    1696:	df 91       	pop	r29
    1698:	cf 91       	pop	r28
    169a:	08 95       	ret

0000169c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    169c:	cf 93       	push	r28
    169e:	df 93       	push	r29
    16a0:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    16a2:	18 96       	adiw	r26, 0x08	; 8
    16a4:	cd 91       	ld	r28, X+
    16a6:	dc 91       	ld	r29, X
    16a8:	19 97       	sbiw	r26, 0x09	; 9

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    16aa:	12 96       	adiw	r26, 0x02	; 2
    16ac:	4d 91       	ld	r20, X+
    16ae:	5c 91       	ld	r21, X
    16b0:	13 97       	sbiw	r26, 0x03	; 3
    16b2:	14 96       	adiw	r26, 0x04	; 4
    16b4:	8d 91       	ld	r24, X+
    16b6:	9c 91       	ld	r25, X
    16b8:	15 97       	sbiw	r26, 0x05	; 5
    16ba:	fa 01       	movw	r30, r20
    16bc:	95 83       	std	Z+5, r25	; 0x05
    16be:	84 83       	std	Z+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    16c0:	14 96       	adiw	r26, 0x04	; 4
    16c2:	2d 91       	ld	r18, X+
    16c4:	3c 91       	ld	r19, X
    16c6:	15 97       	sbiw	r26, 0x05	; 5
    16c8:	f9 01       	movw	r30, r18
    16ca:	53 83       	std	Z+3, r21	; 0x03
    16cc:	42 83       	std	Z+2, r20	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    16ce:	89 81       	ldd	r24, Y+1	; 0x01
    16d0:	9a 81       	ldd	r25, Y+2	; 0x02
    16d2:	8a 17       	cp	r24, r26
    16d4:	9b 07       	cpc	r25, r27
    16d6:	11 f4       	brne	.+4      	; 0x16dc <uxListRemove+0x40>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    16d8:	3a 83       	std	Y+2, r19	; 0x02
    16da:	29 83       	std	Y+1, r18	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    16dc:	19 96       	adiw	r26, 0x09	; 9
    16de:	1c 92       	st	X, r1
    16e0:	1e 92       	st	-X, r1
    16e2:	18 97       	sbiw	r26, 0x08	; 8
    ( pxList->uxNumberOfItems )--;
    16e4:	88 81       	ld	r24, Y
    16e6:	81 50       	subi	r24, 0x01	; 1
    16e8:	88 83       	st	Y, r24

    return pxList->uxNumberOfItems;
    16ea:	88 81       	ld	r24, Y
}
    16ec:	df 91       	pop	r29
    16ee:	cf 91       	pop	r28
    16f0:	08 95       	ret

000016f2 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    16f2:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    16f4:	91 e1       	ldi	r25, 0x11	; 17
    16f6:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    16f8:	22 e2       	ldi	r18, 0x22	; 34
    16fa:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    16fc:	83 e3       	ldi	r24, 0x33	; 51
    16fe:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1700:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1702:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1704:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1706:	80 e8       	ldi	r24, 0x80	; 128
    1708:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    170a:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    170c:	82 e0       	ldi	r24, 0x02	; 2
    170e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1710:	83 e0       	ldi	r24, 0x03	; 3
    1712:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1714:	84 e0       	ldi	r24, 0x04	; 4
    1716:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1718:	85 e0       	ldi	r24, 0x05	; 5
    171a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    171c:	86 e0       	ldi	r24, 0x06	; 6
    171e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1720:	87 e0       	ldi	r24, 0x07	; 7
    1722:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1724:	88 e0       	ldi	r24, 0x08	; 8
    1726:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1728:	89 e0       	ldi	r24, 0x09	; 9
    172a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    172c:	80 e1       	ldi	r24, 0x10	; 16
    172e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1730:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1732:	82 e1       	ldi	r24, 0x12	; 18
    1734:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1736:	83 e1       	ldi	r24, 0x13	; 19
    1738:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    173a:	84 e1       	ldi	r24, 0x14	; 20
    173c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    173e:	85 e1       	ldi	r24, 0x15	; 21
    1740:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1742:	86 e1       	ldi	r24, 0x16	; 22
    1744:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1746:	87 e1       	ldi	r24, 0x17	; 23
    1748:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    174a:	88 e1       	ldi	r24, 0x18	; 24
    174c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    174e:	89 e1       	ldi	r24, 0x19	; 25
    1750:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1752:	80 e2       	ldi	r24, 0x20	; 32
    1754:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1756:	81 e2       	ldi	r24, 0x21	; 33
    1758:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    175a:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    175c:	83 e2       	ldi	r24, 0x23	; 35
    175e:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1760:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1762:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1764:	86 e2       	ldi	r24, 0x26	; 38
    1766:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1768:	87 e2       	ldi	r24, 0x27	; 39
    176a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    176c:	88 e2       	ldi	r24, 0x28	; 40
    176e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1770:	89 e2       	ldi	r24, 0x29	; 41
    1772:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1774:	80 e3       	ldi	r24, 0x30	; 48
    1776:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1778:	81 e3       	ldi	r24, 0x31	; 49
    177a:	82 93       	st	-Z, r24
    177c:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    177e:	cf 01       	movw	r24, r30
    1780:	08 95       	ret

00001782 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    1782:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    1784:	8c e7       	ldi	r24, 0x7C	; 124
    1786:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1788:	8b e0       	ldi	r24, 0x0B	; 11
    178a:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    178c:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    178e:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    1790:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1792:	a0 91 a2 06 	lds	r26, 0x06A2
    1796:	b0 91 a3 06 	lds	r27, 0x06A3
    179a:	cd 91       	ld	r28, X+
    179c:	cd bf       	out	0x3d, r28	; 61
    179e:	dd 91       	ld	r29, X+
    17a0:	de bf       	out	0x3e, r29	; 62
    17a2:	ff 91       	pop	r31
    17a4:	ef 91       	pop	r30
    17a6:	df 91       	pop	r29
    17a8:	cf 91       	pop	r28
    17aa:	bf 91       	pop	r27
    17ac:	af 91       	pop	r26
    17ae:	9f 91       	pop	r25
    17b0:	8f 91       	pop	r24
    17b2:	7f 91       	pop	r23
    17b4:	6f 91       	pop	r22
    17b6:	5f 91       	pop	r21
    17b8:	4f 91       	pop	r20
    17ba:	3f 91       	pop	r19
    17bc:	2f 91       	pop	r18
    17be:	1f 91       	pop	r17
    17c0:	0f 91       	pop	r16
    17c2:	ff 90       	pop	r15
    17c4:	ef 90       	pop	r14
    17c6:	df 90       	pop	r13
    17c8:	cf 90       	pop	r12
    17ca:	bf 90       	pop	r11
    17cc:	af 90       	pop	r10
    17ce:	9f 90       	pop	r9
    17d0:	8f 90       	pop	r8
    17d2:	7f 90       	pop	r7
    17d4:	6f 90       	pop	r6
    17d6:	5f 90       	pop	r5
    17d8:	4f 90       	pop	r4
    17da:	3f 90       	pop	r3
    17dc:	2f 90       	pop	r2
    17de:	1f 90       	pop	r1
    17e0:	0f 90       	pop	r0
    17e2:	0f be       	out	0x3f, r0	; 63
    17e4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    17e6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    17e8:	81 e0       	ldi	r24, 0x01	; 1
    17ea:	08 95       	ret

000017ec <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    17ec:	08 95       	ret

000017ee <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17ee:	0f 92       	push	r0
    17f0:	0f b6       	in	r0, 0x3f	; 63
    17f2:	f8 94       	cli
    17f4:	0f 92       	push	r0
    17f6:	1f 92       	push	r1
    17f8:	11 24       	eor	r1, r1
    17fa:	2f 92       	push	r2
    17fc:	3f 92       	push	r3
    17fe:	4f 92       	push	r4
    1800:	5f 92       	push	r5
    1802:	6f 92       	push	r6
    1804:	7f 92       	push	r7
    1806:	8f 92       	push	r8
    1808:	9f 92       	push	r9
    180a:	af 92       	push	r10
    180c:	bf 92       	push	r11
    180e:	cf 92       	push	r12
    1810:	df 92       	push	r13
    1812:	ef 92       	push	r14
    1814:	ff 92       	push	r15
    1816:	0f 93       	push	r16
    1818:	1f 93       	push	r17
    181a:	2f 93       	push	r18
    181c:	3f 93       	push	r19
    181e:	4f 93       	push	r20
    1820:	5f 93       	push	r21
    1822:	6f 93       	push	r22
    1824:	7f 93       	push	r23
    1826:	8f 93       	push	r24
    1828:	9f 93       	push	r25
    182a:	af 93       	push	r26
    182c:	bf 93       	push	r27
    182e:	cf 93       	push	r28
    1830:	df 93       	push	r29
    1832:	ef 93       	push	r30
    1834:	ff 93       	push	r31
    1836:	a0 91 a2 06 	lds	r26, 0x06A2
    183a:	b0 91 a3 06 	lds	r27, 0x06A3
    183e:	0d b6       	in	r0, 0x3d	; 61
    1840:	0d 92       	st	X+, r0
    1842:	0e b6       	in	r0, 0x3e	; 62
    1844:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1846:	0e 94 05 16 	call	0x2c0a	; 0x2c0a <xTaskIncrementTick>
    184a:	88 23       	and	r24, r24
    184c:	11 f0       	breq	.+4      	; 0x1852 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    184e:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1852:	a0 91 a2 06 	lds	r26, 0x06A2
    1856:	b0 91 a3 06 	lds	r27, 0x06A3
    185a:	cd 91       	ld	r28, X+
    185c:	cd bf       	out	0x3d, r28	; 61
    185e:	dd 91       	ld	r29, X+
    1860:	de bf       	out	0x3e, r29	; 62
    1862:	ff 91       	pop	r31
    1864:	ef 91       	pop	r30
    1866:	df 91       	pop	r29
    1868:	cf 91       	pop	r28
    186a:	bf 91       	pop	r27
    186c:	af 91       	pop	r26
    186e:	9f 91       	pop	r25
    1870:	8f 91       	pop	r24
    1872:	7f 91       	pop	r23
    1874:	6f 91       	pop	r22
    1876:	5f 91       	pop	r21
    1878:	4f 91       	pop	r20
    187a:	3f 91       	pop	r19
    187c:	2f 91       	pop	r18
    187e:	1f 91       	pop	r17
    1880:	0f 91       	pop	r16
    1882:	ff 90       	pop	r15
    1884:	ef 90       	pop	r14
    1886:	df 90       	pop	r13
    1888:	cf 90       	pop	r12
    188a:	bf 90       	pop	r11
    188c:	af 90       	pop	r10
    188e:	9f 90       	pop	r9
    1890:	8f 90       	pop	r8
    1892:	7f 90       	pop	r7
    1894:	6f 90       	pop	r6
    1896:	5f 90       	pop	r5
    1898:	4f 90       	pop	r4
    189a:	3f 90       	pop	r3
    189c:	2f 90       	pop	r2
    189e:	1f 90       	pop	r1
    18a0:	0f 90       	pop	r0
    18a2:	0f be       	out	0x3f, r0	; 63
    18a4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    18a6:	08 95       	ret

000018a8 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    18a8:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <vPortYieldFromTick>
		asm volatile ( "reti" );
    18ac:	18 95       	reti

000018ae <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    18ae:	0f 92       	push	r0
    18b0:	0f b6       	in	r0, 0x3f	; 63
    18b2:	f8 94       	cli
    18b4:	0f 92       	push	r0
    18b6:	1f 92       	push	r1
    18b8:	11 24       	eor	r1, r1
    18ba:	2f 92       	push	r2
    18bc:	3f 92       	push	r3
    18be:	4f 92       	push	r4
    18c0:	5f 92       	push	r5
    18c2:	6f 92       	push	r6
    18c4:	7f 92       	push	r7
    18c6:	8f 92       	push	r8
    18c8:	9f 92       	push	r9
    18ca:	af 92       	push	r10
    18cc:	bf 92       	push	r11
    18ce:	cf 92       	push	r12
    18d0:	df 92       	push	r13
    18d2:	ef 92       	push	r14
    18d4:	ff 92       	push	r15
    18d6:	0f 93       	push	r16
    18d8:	1f 93       	push	r17
    18da:	2f 93       	push	r18
    18dc:	3f 93       	push	r19
    18de:	4f 93       	push	r20
    18e0:	5f 93       	push	r21
    18e2:	6f 93       	push	r22
    18e4:	7f 93       	push	r23
    18e6:	8f 93       	push	r24
    18e8:	9f 93       	push	r25
    18ea:	af 93       	push	r26
    18ec:	bf 93       	push	r27
    18ee:	cf 93       	push	r28
    18f0:	df 93       	push	r29
    18f2:	ef 93       	push	r30
    18f4:	ff 93       	push	r31
    18f6:	a0 91 a2 06 	lds	r26, 0x06A2
    18fa:	b0 91 a3 06 	lds	r27, 0x06A3
    18fe:	0d b6       	in	r0, 0x3d	; 61
    1900:	0d 92       	st	X+, r0
    1902:	0e b6       	in	r0, 0x3e	; 62
    1904:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1906:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    190a:	a0 91 a2 06 	lds	r26, 0x06A2
    190e:	b0 91 a3 06 	lds	r27, 0x06A3
    1912:	cd 91       	ld	r28, X+
    1914:	cd bf       	out	0x3d, r28	; 61
    1916:	dd 91       	ld	r29, X+
    1918:	de bf       	out	0x3e, r29	; 62
    191a:	ff 91       	pop	r31
    191c:	ef 91       	pop	r30
    191e:	df 91       	pop	r29
    1920:	cf 91       	pop	r28
    1922:	bf 91       	pop	r27
    1924:	af 91       	pop	r26
    1926:	9f 91       	pop	r25
    1928:	8f 91       	pop	r24
    192a:	7f 91       	pop	r23
    192c:	6f 91       	pop	r22
    192e:	5f 91       	pop	r21
    1930:	4f 91       	pop	r20
    1932:	3f 91       	pop	r19
    1934:	2f 91       	pop	r18
    1936:	1f 91       	pop	r17
    1938:	0f 91       	pop	r16
    193a:	ff 90       	pop	r15
    193c:	ef 90       	pop	r14
    193e:	df 90       	pop	r13
    1940:	cf 90       	pop	r12
    1942:	bf 90       	pop	r11
    1944:	af 90       	pop	r10
    1946:	9f 90       	pop	r9
    1948:	8f 90       	pop	r8
    194a:	7f 90       	pop	r7
    194c:	6f 90       	pop	r6
    194e:	5f 90       	pop	r5
    1950:	4f 90       	pop	r4
    1952:	3f 90       	pop	r3
    1954:	2f 90       	pop	r2
    1956:	1f 90       	pop	r1
    1958:	0f 90       	pop	r0
    195a:	0f be       	out	0x3f, r0	; 63
    195c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    195e:	08 95       	ret

00001960 <uxQueueMessagesWaiting>:
    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1960:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    1962:	0f b6       	in	r0, 0x3f	; 63
    1964:	f8 94       	cli
    1966:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1968:	82 8d       	ldd	r24, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    196a:	0f 90       	pop	r0
    196c:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    196e:	08 95       	ret

00001970 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1970:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    1972:	0f b6       	in	r0, 0x3f	; 63
    1974:	f8 94       	cli
    1976:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1978:	92 8d       	ldd	r25, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    197a:	0f 90       	pop	r0
    197c:	0f be       	out	0x3f, r0	; 63
    197e:	83 8d       	ldd	r24, Z+27	; 0x1b

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1980:	89 1b       	sub	r24, r25
    1982:	08 95       	ret

00001984 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1984:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    1986:	82 8d       	ldd	r24, Z+26	; 0x1a

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1988:	08 95       	ret

0000198a <xQueueIsQueueEmptyFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    198a:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    198c:	82 8d       	ldd	r24, Z+26	; 0x1a
    198e:	90 e0       	ldi	r25, 0x00	; 0
    1990:	88 23       	and	r24, r24
    1992:	09 f4       	brne	.+2      	; 0x1996 <xQueueIsQueueEmptyFromISR+0xc>
    1994:	91 e0       	ldi	r25, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1996:	89 2f       	mov	r24, r25
    1998:	08 95       	ret

0000199a <xQueueIsQueueFullFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    199a:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    199c:	92 8d       	ldd	r25, Z+26	; 0x1a
    199e:	20 e0       	ldi	r18, 0x00	; 0
    19a0:	83 8d       	ldd	r24, Z+27	; 0x1b
    19a2:	98 17       	cp	r25, r24
    19a4:	09 f4       	brne	.+2      	; 0x19a8 <xQueueIsQueueFullFromISR+0xe>
    19a6:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19a8:	82 2f       	mov	r24, r18
    19aa:	08 95       	ret

000019ac <vQueueDelete>:

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    19ac:	0e 94 a5 0a 	call	0x154a	; 0x154a <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    19b0:	08 95       	ret

000019b2 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    19b2:	fc 01       	movw	r30, r24
    19b4:	56 2f       	mov	r21, r22
    19b6:	a7 2f       	mov	r26, r23
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    19b8:	24 8d       	ldd	r18, Z+28	; 0x1c
    19ba:	22 23       	and	r18, r18
    19bc:	b9 f0       	breq	.+46     	; 0x19ec <prvCopyDataFromQueue+0x3a>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    19be:	86 81       	ldd	r24, Z+6	; 0x06
    19c0:	97 81       	ldd	r25, Z+7	; 0x07
    19c2:	82 0f       	add	r24, r18
    19c4:	91 1d       	adc	r25, r1
    19c6:	97 83       	std	Z+7, r25	; 0x07
    19c8:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    19ca:	24 81       	ldd	r18, Z+4	; 0x04
    19cc:	35 81       	ldd	r19, Z+5	; 0x05
    19ce:	82 17       	cp	r24, r18
    19d0:	93 07       	cpc	r25, r19
    19d2:	20 f0       	brcs	.+8      	; 0x19dc <prvCopyDataFromQueue+0x2a>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    19d4:	80 81       	ld	r24, Z
    19d6:	91 81       	ldd	r25, Z+1	; 0x01
    19d8:	97 83       	std	Z+7, r25	; 0x07
    19da:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    19dc:	44 8d       	ldd	r20, Z+28	; 0x1c
    19de:	66 81       	ldd	r22, Z+6	; 0x06
    19e0:	77 81       	ldd	r23, Z+7	; 0x07
    19e2:	85 2f       	mov	r24, r21
    19e4:	9a 2f       	mov	r25, r26
    19e6:	50 e0       	ldi	r21, 0x00	; 0
    19e8:	0e 94 17 24 	call	0x482e	; 0x482e <memcpy>
    19ec:	08 95       	ret

000019ee <xQueuePeekFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    19ee:	0f 93       	push	r16
    19f0:	1f 93       	push	r17
    19f2:	cf 93       	push	r28
    19f4:	df 93       	push	r29
    19f6:	ec 01       	movw	r28, r24
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    19f8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19fa:	88 23       	and	r24, r24
    19fc:	41 f0       	breq	.+16     	; 0x1a0e <xQueuePeekFromISR+0x20>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    19fe:	0e 81       	ldd	r16, Y+6	; 0x06
    1a00:	1f 81       	ldd	r17, Y+7	; 0x07
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a02:	ce 01       	movw	r24, r28
    1a04:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1a08:	1f 83       	std	Y+7, r17	; 0x07
    1a0a:	0e 83       	std	Y+6, r16	; 0x06
    1a0c:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1a0e:	df 91       	pop	r29
    1a10:	cf 91       	pop	r28
    1a12:	1f 91       	pop	r17
    1a14:	0f 91       	pop	r16
    1a16:	08 95       	ret

00001a18 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    1a18:	0f 93       	push	r16
    1a1a:	1f 93       	push	r17
    1a1c:	cf 93       	push	r28
    1a1e:	df 93       	push	r29
    1a20:	ec 01       	movw	r28, r24
    1a22:	04 2f       	mov	r16, r20
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a24:	1a 8d       	ldd	r17, Y+26	; 0x1a

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1a26:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1a28:	44 23       	and	r20, r20
    1a2a:	c1 f1       	breq	.+112    	; 0x1a9c <prvCopyDataToQueue+0x84>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    1a2c:	00 23       	and	r16, r16
    1a2e:	b1 f4       	brne	.+44     	; 0x1a5c <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1a30:	8a 81       	ldd	r24, Y+2	; 0x02
    1a32:	9b 81       	ldd	r25, Y+3	; 0x03
    1a34:	50 e0       	ldi	r21, 0x00	; 0
    1a36:	0e 94 17 24 	call	0x482e	; 0x482e <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1a3a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1a3c:	2a 81       	ldd	r18, Y+2	; 0x02
    1a3e:	3b 81       	ldd	r19, Y+3	; 0x03
    1a40:	28 0f       	add	r18, r24
    1a42:	31 1d       	adc	r19, r1
    1a44:	3b 83       	std	Y+3, r19	; 0x03
    1a46:	2a 83       	std	Y+2, r18	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1a48:	8c 81       	ldd	r24, Y+4	; 0x04
    1a4a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a4c:	28 17       	cp	r18, r24
    1a4e:	39 07       	cpc	r19, r25
    1a50:	28 f1       	brcs	.+74     	; 0x1a9c <prvCopyDataToQueue+0x84>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1a52:	88 81       	ld	r24, Y
    1a54:	99 81       	ldd	r25, Y+1	; 0x01
    1a56:	9b 83       	std	Y+3, r25	; 0x03
    1a58:	8a 83       	std	Y+2, r24	; 0x02
    1a5a:	20 c0       	rjmp	.+64     	; 0x1a9c <prvCopyDataToQueue+0x84>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1a5c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a5e:	9f 81       	ldd	r25, Y+7	; 0x07
    1a60:	50 e0       	ldi	r21, 0x00	; 0
    1a62:	0e 94 17 24 	call	0x482e	; 0x482e <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1a66:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1a68:	90 e0       	ldi	r25, 0x00	; 0
    1a6a:	44 27       	eor	r20, r20
    1a6c:	55 27       	eor	r21, r21
    1a6e:	48 1b       	sub	r20, r24
    1a70:	59 0b       	sbc	r21, r25
    1a72:	8e 81       	ldd	r24, Y+6	; 0x06
    1a74:	9f 81       	ldd	r25, Y+7	; 0x07
    1a76:	84 0f       	add	r24, r20
    1a78:	95 1f       	adc	r25, r21
    1a7a:	9f 83       	std	Y+7, r25	; 0x07
    1a7c:	8e 83       	std	Y+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1a7e:	28 81       	ld	r18, Y
    1a80:	39 81       	ldd	r19, Y+1	; 0x01
    1a82:	82 17       	cp	r24, r18
    1a84:	93 07       	cpc	r25, r19
    1a86:	30 f4       	brcc	.+12     	; 0x1a94 <prvCopyDataToQueue+0x7c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1a88:	8c 81       	ldd	r24, Y+4	; 0x04
    1a8a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a8c:	84 0f       	add	r24, r20
    1a8e:	95 1f       	adc	r25, r21
    1a90:	9f 83       	std	Y+7, r25	; 0x07
    1a92:	8e 83       	std	Y+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    1a94:	02 30       	cpi	r16, 0x02	; 2
    1a96:	11 f4       	brne	.+4      	; 0x1a9c <prvCopyDataToQueue+0x84>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a98:	11 11       	cpse	r17, r1
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    1a9a:	11 50       	subi	r17, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1a9c:	1f 5f       	subi	r17, 0xFF	; 255
    1a9e:	1a 8f       	std	Y+26, r17	; 0x1a

    return xReturn;
}
    1aa0:	80 e0       	ldi	r24, 0x00	; 0
    1aa2:	df 91       	pop	r29
    1aa4:	cf 91       	pop	r28
    1aa6:	1f 91       	pop	r17
    1aa8:	0f 91       	pop	r16
    1aaa:	08 95       	ret

00001aac <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    1aac:	ef 92       	push	r14
    1aae:	ff 92       	push	r15
    1ab0:	0f 93       	push	r16
    1ab2:	1f 93       	push	r17
    1ab4:	cf 93       	push	r28
    1ab6:	df 93       	push	r29
    1ab8:	ec 01       	movw	r28, r24
    1aba:	7a 01       	movw	r14, r20
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1abc:	1a 8d       	ldd	r17, Y+26	; 0x1a

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1abe:	11 23       	and	r17, r17
    1ac0:	11 f4       	brne	.+4      	; 0x1ac6 <xQueueReceiveFromISR+0x1a>
    1ac2:	80 e0       	ldi	r24, 0x00	; 0
    1ac4:	1a c0       	rjmp	.+52     	; 0x1afa <xQueueReceiveFromISR+0x4e>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    1ac6:	0d 8d       	ldd	r16, Y+29	; 0x1d

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ac8:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1acc:	11 50       	subi	r17, 0x01	; 1
    1ace:	1a 8f       	std	Y+26, r17	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    1ad0:	0f 3f       	cpi	r16, 0xFF	; 255
    1ad2:	81 f4       	brne	.+32     	; 0x1af4 <xQueueReceiveFromISR+0x48>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ad4:	88 85       	ldd	r24, Y+8	; 0x08
    1ad6:	88 23       	and	r24, r24
    1ad8:	79 f0       	breq	.+30     	; 0x1af8 <xQueueReceiveFromISR+0x4c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ada:	ce 01       	movw	r24, r28
    1adc:	08 96       	adiw	r24, 0x08	; 8
    1ade:	0e 94 57 17 	call	0x2eae	; 0x2eae <xTaskRemoveFromEventList>
    1ae2:	88 23       	and	r24, r24
    1ae4:	49 f0       	breq	.+18     	; 0x1af8 <xQueueReceiveFromISR+0x4c>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    1ae6:	e1 14       	cp	r14, r1
    1ae8:	f1 04       	cpc	r15, r1
    1aea:	31 f0       	breq	.+12     	; 0x1af8 <xQueueReceiveFromISR+0x4c>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    1aec:	81 e0       	ldi	r24, 0x01	; 1
    1aee:	f7 01       	movw	r30, r14
    1af0:	80 83       	st	Z, r24
    1af2:	03 c0       	rjmp	.+6      	; 0x1afa <xQueueReceiveFromISR+0x4e>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1af4:	0f 5f       	subi	r16, 0xFF	; 255
    1af6:	0d 8f       	std	Y+29, r16	; 0x1d
    1af8:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1afa:	df 91       	pop	r29
    1afc:	cf 91       	pop	r28
    1afe:	1f 91       	pop	r17
    1b00:	0f 91       	pop	r16
    1b02:	ff 90       	pop	r15
    1b04:	ef 90       	pop	r14
    1b06:	08 95       	ret

00001b08 <xQueueGiveFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    1b08:	cf 93       	push	r28
    1b0a:	df 93       	push	r29
    1b0c:	fc 01       	movw	r30, r24
    1b0e:	eb 01       	movw	r28, r22
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b10:	92 8d       	ldd	r25, Z+26	; 0x1a

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    1b12:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b14:	98 17       	cp	r25, r24
    1b16:	10 f0       	brcs	.+4      	; 0x1b1c <xQueueGiveFromISR+0x14>
    1b18:	80 e0       	ldi	r24, 0x00	; 0
    1b1a:	16 c0       	rjmp	.+44     	; 0x1b48 <xQueueGiveFromISR+0x40>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    1b1c:	86 8d       	ldd	r24, Z+30	; 0x1e
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1b1e:	9f 5f       	subi	r25, 0xFF	; 255
    1b20:	92 8f       	std	Z+26, r25	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    1b22:	8f 3f       	cpi	r24, 0xFF	; 255
    1b24:	71 f4       	brne	.+28     	; 0x1b42 <xQueueGiveFromISR+0x3a>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b26:	81 89       	ldd	r24, Z+17	; 0x11
    1b28:	88 23       	and	r24, r24
    1b2a:	69 f0       	breq	.+26     	; 0x1b46 <xQueueGiveFromISR+0x3e>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b2c:	cf 01       	movw	r24, r30
    1b2e:	41 96       	adiw	r24, 0x11	; 17
    1b30:	0e 94 57 17 	call	0x2eae	; 0x2eae <xTaskRemoveFromEventList>
    1b34:	88 23       	and	r24, r24
    1b36:	39 f0       	breq	.+14     	; 0x1b46 <xQueueGiveFromISR+0x3e>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    1b38:	20 97       	sbiw	r28, 0x00	; 0
    1b3a:	29 f0       	breq	.+10     	; 0x1b46 <xQueueGiveFromISR+0x3e>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    1b3c:	81 e0       	ldi	r24, 0x01	; 1
    1b3e:	88 83       	st	Y, r24
    1b40:	03 c0       	rjmp	.+6      	; 0x1b48 <xQueueGiveFromISR+0x40>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1b42:	8f 5f       	subi	r24, 0xFF	; 255
    1b44:	86 8f       	std	Z+30, r24	; 0x1e
    1b46:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1b48:	df 91       	pop	r29
    1b4a:	cf 91       	pop	r28
    1b4c:	08 95       	ret

00001b4e <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    1b4e:	ef 92       	push	r14
    1b50:	ff 92       	push	r15
    1b52:	1f 93       	push	r17
    1b54:	cf 93       	push	r28
    1b56:	df 93       	push	r29
    1b58:	ec 01       	movw	r28, r24
    1b5a:	7a 01       	movw	r14, r20
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1b5c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b5e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b60:	98 17       	cp	r25, r24
    1b62:	20 f0       	brcs	.+8      	; 0x1b6c <xQueueGenericSendFromISR+0x1e>
    1b64:	22 30       	cpi	r18, 0x02	; 2
    1b66:	11 f0       	breq	.+4      	; 0x1b6c <xQueueGenericSendFromISR+0x1e>
    1b68:	80 e0       	ldi	r24, 0x00	; 0
    1b6a:	1b c0       	rjmp	.+54     	; 0x1ba2 <xQueueGenericSendFromISR+0x54>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    1b6c:	1e 8d       	ldd	r17, Y+30	; 0x1e
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b6e:	8a 8d       	ldd	r24, Y+26	; 0x1a
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b70:	ce 01       	movw	r24, r28
    1b72:	42 2f       	mov	r20, r18
    1b74:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    1b78:	1f 3f       	cpi	r17, 0xFF	; 255
    1b7a:	81 f4       	brne	.+32     	; 0x1b9c <xQueueGenericSendFromISR+0x4e>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b7c:	89 89       	ldd	r24, Y+17	; 0x11
    1b7e:	88 23       	and	r24, r24
    1b80:	79 f0       	breq	.+30     	; 0x1ba0 <xQueueGenericSendFromISR+0x52>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b82:	ce 01       	movw	r24, r28
    1b84:	41 96       	adiw	r24, 0x11	; 17
    1b86:	0e 94 57 17 	call	0x2eae	; 0x2eae <xTaskRemoveFromEventList>
    1b8a:	88 23       	and	r24, r24
    1b8c:	49 f0       	breq	.+18     	; 0x1ba0 <xQueueGenericSendFromISR+0x52>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    1b8e:	e1 14       	cp	r14, r1
    1b90:	f1 04       	cpc	r15, r1
    1b92:	31 f0       	breq	.+12     	; 0x1ba0 <xQueueGenericSendFromISR+0x52>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    1b94:	81 e0       	ldi	r24, 0x01	; 1
    1b96:	f7 01       	movw	r30, r14
    1b98:	80 83       	st	Z, r24
    1b9a:	03 c0       	rjmp	.+6      	; 0x1ba2 <xQueueGenericSendFromISR+0x54>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1b9c:	1f 5f       	subi	r17, 0xFF	; 255
    1b9e:	1e 8f       	std	Y+30, r17	; 0x1e
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1ba2:	df 91       	pop	r29
    1ba4:	cf 91       	pop	r28
    1ba6:	1f 91       	pop	r17
    1ba8:	ff 90       	pop	r15
    1baa:	ef 90       	pop	r14
    1bac:	08 95       	ret

00001bae <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1bae:	ef 92       	push	r14
    1bb0:	ff 92       	push	r15
    1bb2:	1f 93       	push	r17
    1bb4:	cf 93       	push	r28
    1bb6:	df 93       	push	r29
    1bb8:	ec 01       	movw	r28, r24

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    1bba:	0f b6       	in	r0, 0x3f	; 63
    1bbc:	f8 94       	cli
    1bbe:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    1bc0:	1e 8d       	ldd	r17, Y+30	; 0x1e
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bc2:	91 e1       	ldi	r25, 0x11	; 17
    1bc4:	e9 2e       	mov	r14, r25
    1bc6:	f1 2c       	mov	r15, r1
    1bc8:	ec 0e       	add	r14, r28
    1bca:	fd 1e       	adc	r15, r29
    1bcc:	0b c0       	rjmp	.+22     	; 0x1be4 <prvUnlockQueue+0x36>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bce:	89 89       	ldd	r24, Y+17	; 0x11
    1bd0:	88 23       	and	r24, r24
    1bd2:	51 f0       	breq	.+20     	; 0x1be8 <prvUnlockQueue+0x3a>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bd4:	c7 01       	movw	r24, r14
    1bd6:	0e 94 57 17 	call	0x2eae	; 0x2eae <xTaskRemoveFromEventList>
    1bda:	88 23       	and	r24, r24
    1bdc:	11 f0       	breq	.+4      	; 0x1be2 <prvUnlockQueue+0x34>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    1bde:	0e 94 f4 18 	call	0x31e8	; 0x31e8 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    1be2:	11 50       	subi	r17, 0x01	; 1
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    1be4:	11 16       	cp	r1, r17
    1be6:	9c f3       	brlt	.-26     	; 0x1bce <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    1be8:	8f ef       	ldi	r24, 0xFF	; 255
    1bea:	8e 8f       	std	Y+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    1bec:	0f 90       	pop	r0
    1bee:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    1bf0:	0f b6       	in	r0, 0x3f	; 63
    1bf2:	f8 94       	cli
    1bf4:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    1bf6:	1d 8d       	ldd	r17, Y+29	; 0x1d

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bf8:	88 e0       	ldi	r24, 0x08	; 8
    1bfa:	e8 2e       	mov	r14, r24
    1bfc:	f1 2c       	mov	r15, r1
    1bfe:	ec 0e       	add	r14, r28
    1c00:	fd 1e       	adc	r15, r29
    1c02:	0b c0       	rjmp	.+22     	; 0x1c1a <prvUnlockQueue+0x6c>
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c04:	88 85       	ldd	r24, Y+8	; 0x08
    1c06:	88 23       	and	r24, r24
    1c08:	51 f0       	breq	.+20     	; 0x1c1e <prvUnlockQueue+0x70>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c0a:	c7 01       	movw	r24, r14
    1c0c:	0e 94 57 17 	call	0x2eae	; 0x2eae <xTaskRemoveFromEventList>
    1c10:	88 23       	and	r24, r24
    1c12:	11 f0       	breq	.+4      	; 0x1c18 <prvUnlockQueue+0x6a>
                {
                    vTaskMissedYield();
    1c14:	0e 94 f4 18 	call	0x31e8	; 0x31e8 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    1c18:	11 50       	subi	r17, 0x01	; 1
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    1c1a:	11 16       	cp	r1, r17
    1c1c:	9c f3       	brlt	.-26     	; 0x1c04 <prvUnlockQueue+0x56>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    1c1e:	8f ef       	ldi	r24, 0xFF	; 255
    1c20:	8d 8f       	std	Y+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    1c22:	0f 90       	pop	r0
    1c24:	0f be       	out	0x3f, r0	; 63
}
    1c26:	df 91       	pop	r29
    1c28:	cf 91       	pop	r28
    1c2a:	1f 91       	pop	r17
    1c2c:	ff 90       	pop	r15
    1c2e:	ef 90       	pop	r14
    1c30:	08 95       	ret

00001c32 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    1c32:	8f 92       	push	r8
    1c34:	9f 92       	push	r9
    1c36:	af 92       	push	r10
    1c38:	bf 92       	push	r11
    1c3a:	cf 92       	push	r12
    1c3c:	df 92       	push	r13
    1c3e:	ef 92       	push	r14
    1c40:	ff 92       	push	r15
    1c42:	0f 93       	push	r16
    1c44:	1f 93       	push	r17
    1c46:	df 93       	push	r29
    1c48:	cf 93       	push	r28
    1c4a:	00 d0       	rcall	.+0      	; 0x1c4c <xQueuePeek+0x1a>
    1c4c:	00 d0       	rcall	.+0      	; 0x1c4e <xQueuePeek+0x1c>
    1c4e:	0f 92       	push	r0
    1c50:	cd b7       	in	r28, 0x3d	; 61
    1c52:	de b7       	in	r29, 0x3e	; 62
    1c54:	7c 01       	movw	r14, r24
    1c56:	5b 01       	movw	r10, r22
    1c58:	5d 83       	std	Y+5, r21	; 0x05
    1c5a:	4c 83       	std	Y+4, r20	; 0x04
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c5c:	41 e1       	ldi	r20, 0x11	; 17
    1c5e:	c4 2e       	mov	r12, r20
    1c60:	d1 2c       	mov	r13, r1
    1c62:	c8 0e       	add	r12, r24
    1c64:	d9 1e       	adc	r13, r25
    1c66:	20 e0       	ldi	r18, 0x00	; 0
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1c68:	8e 01       	movw	r16, r28
    1c6a:	0f 5f       	subi	r16, 0xFF	; 255
    1c6c:	1f 4f       	sbci	r17, 0xFF	; 255

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c6e:	34 e0       	ldi	r19, 0x04	; 4
    1c70:	83 2e       	mov	r8, r19
    1c72:	91 2c       	mov	r9, r1
    1c74:	8c 0e       	add	r8, r28
    1c76:	9d 1e       	adc	r9, r29
    1c78:	01 c0       	rjmp	.+2      	; 0x1c7c <xQueuePeek+0x4a>
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c7a:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1c7c:	0f b6       	in	r0, 0x3f	; 63
    1c7e:	f8 94       	cli
    1c80:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1c82:	f7 01       	movw	r30, r14
    1c84:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c86:	88 23       	and	r24, r24
    1c88:	b9 f0       	breq	.+46     	; 0x1cb8 <xQueuePeek+0x86>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1c8a:	06 81       	ldd	r16, Z+6	; 0x06
    1c8c:	17 81       	ldd	r17, Z+7	; 0x07

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c8e:	c7 01       	movw	r24, r14
    1c90:	b5 01       	movw	r22, r10
    1c92:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1c96:	f7 01       	movw	r30, r14
    1c98:	17 83       	std	Z+7, r17	; 0x07
    1c9a:	06 83       	std	Z+6, r16	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c9c:	81 89       	ldd	r24, Z+17	; 0x11
    1c9e:	88 23       	and	r24, r24
    1ca0:	39 f0       	breq	.+14     	; 0x1cb0 <xQueuePeek+0x7e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ca2:	c6 01       	movw	r24, r12
    1ca4:	0e 94 57 17 	call	0x2eae	; 0x2eae <xTaskRemoveFromEventList>
    1ca8:	88 23       	and	r24, r24
    1caa:	11 f0       	breq	.+4      	; 0x1cb0 <xQueuePeek+0x7e>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    1cac:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1cb0:	0f 90       	pop	r0
    1cb2:	0f be       	out	0x3f, r0	; 63
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	54 c0       	rjmp	.+168    	; 0x1d60 <xQueuePeek+0x12e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1cb8:	8c 81       	ldd	r24, Y+4	; 0x04
    1cba:	9d 81       	ldd	r25, Y+5	; 0x05
    1cbc:	89 2b       	or	r24, r25
    1cbe:	21 f4       	brne	.+8      	; 0x1cc8 <xQueuePeek+0x96>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1cc0:	0f 90       	pop	r0
    1cc2:	0f be       	out	0x3f, r0	; 63
    1cc4:	80 e0       	ldi	r24, 0x00	; 0
    1cc6:	4c c0       	rjmp	.+152    	; 0x1d60 <xQueuePeek+0x12e>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    1cc8:	22 23       	and	r18, r18
    1cca:	19 f4       	brne	.+6      	; 0x1cd2 <xQueuePeek+0xa0>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1ccc:	c8 01       	movw	r24, r16
    1cce:	0e 94 b4 18 	call	0x3168	; 0x3168 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1cd2:	0f 90       	pop	r0
    1cd4:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    1cd6:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1cda:	0f b6       	in	r0, 0x3f	; 63
    1cdc:	f8 94       	cli
    1cde:	0f 92       	push	r0
    1ce0:	f7 01       	movw	r30, r14
    1ce2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ce4:	8f 3f       	cpi	r24, 0xFF	; 255
    1ce6:	09 f4       	brne	.+2      	; 0x1cea <xQueuePeek+0xb8>
    1ce8:	15 8e       	std	Z+29, r1	; 0x1d
    1cea:	f7 01       	movw	r30, r14
    1cec:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cee:	8f 3f       	cpi	r24, 0xFF	; 255
    1cf0:	09 f4       	brne	.+2      	; 0x1cf4 <xQueuePeek+0xc2>
    1cf2:	16 8e       	std	Z+30, r1	; 0x1e
    1cf4:	0f 90       	pop	r0
    1cf6:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1cf8:	c8 01       	movw	r24, r16
    1cfa:	b4 01       	movw	r22, r8
    1cfc:	0e 94 bf 18 	call	0x317e	; 0x317e <xTaskCheckForTimeOut>
    1d00:	88 23       	and	r24, r24
    1d02:	f9 f4       	brne	.+62     	; 0x1d42 <xQueuePeek+0x110>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1d04:	0f b6       	in	r0, 0x3f	; 63
    1d06:	f8 94       	cli
    1d08:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1d0a:	f7 01       	movw	r30, r14
    1d0c:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1d0e:	0f 90       	pop	r0
    1d10:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d12:	88 23       	and	r24, r24
    1d14:	81 f4       	brne	.+32     	; 0x1d36 <xQueuePeek+0x104>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d16:	6c 81       	ldd	r22, Y+4	; 0x04
    1d18:	7d 81       	ldd	r23, Y+5	; 0x05
    1d1a:	c6 01       	movw	r24, r12
    1d1c:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1d20:	c7 01       	movw	r24, r14
    1d22:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1d26:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
    1d2a:	88 23       	and	r24, r24
    1d2c:	09 f0       	breq	.+2      	; 0x1d30 <xQueuePeek+0xfe>
    1d2e:	a5 cf       	rjmp	.-182    	; 0x1c7a <xQueuePeek+0x48>
                {
                    portYIELD_WITHIN_API();
    1d30:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
    1d34:	a2 cf       	rjmp	.-188    	; 0x1c7a <xQueuePeek+0x48>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    1d36:	c7 01       	movw	r24, r14
    1d38:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1d3c:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
    1d40:	9c cf       	rjmp	.-200    	; 0x1c7a <xQueuePeek+0x48>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    1d42:	c7 01       	movw	r24, r14
    1d44:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1d48:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1d4c:	0f b6       	in	r0, 0x3f	; 63
    1d4e:	f8 94       	cli
    1d50:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1d52:	f7 01       	movw	r30, r14
    1d54:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1d56:	0f 90       	pop	r0
    1d58:	0f be       	out	0x3f, r0	; 63
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d5a:	88 23       	and	r24, r24
    1d5c:	09 f0       	breq	.+2      	; 0x1d60 <xQueuePeek+0x12e>
    1d5e:	8d cf       	rjmp	.-230    	; 0x1c7a <xQueuePeek+0x48>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    1d60:	0f 90       	pop	r0
    1d62:	0f 90       	pop	r0
    1d64:	0f 90       	pop	r0
    1d66:	0f 90       	pop	r0
    1d68:	0f 90       	pop	r0
    1d6a:	cf 91       	pop	r28
    1d6c:	df 91       	pop	r29
    1d6e:	1f 91       	pop	r17
    1d70:	0f 91       	pop	r16
    1d72:	ff 90       	pop	r15
    1d74:	ef 90       	pop	r14
    1d76:	df 90       	pop	r13
    1d78:	cf 90       	pop	r12
    1d7a:	bf 90       	pop	r11
    1d7c:	af 90       	pop	r10
    1d7e:	9f 90       	pop	r9
    1d80:	8f 90       	pop	r8
    1d82:	08 95       	ret

00001d84 <xQueueSemaphoreTake>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    1d84:	af 92       	push	r10
    1d86:	bf 92       	push	r11
    1d88:	cf 92       	push	r12
    1d8a:	df 92       	push	r13
    1d8c:	ef 92       	push	r14
    1d8e:	ff 92       	push	r15
    1d90:	0f 93       	push	r16
    1d92:	1f 93       	push	r17
    1d94:	df 93       	push	r29
    1d96:	cf 93       	push	r28
    1d98:	00 d0       	rcall	.+0      	; 0x1d9a <xQueueSemaphoreTake+0x16>
    1d9a:	00 d0       	rcall	.+0      	; 0x1d9c <xQueueSemaphoreTake+0x18>
    1d9c:	0f 92       	push	r0
    1d9e:	cd b7       	in	r28, 0x3d	; 61
    1da0:	de b7       	in	r29, 0x3e	; 62
    1da2:	8c 01       	movw	r16, r24
    1da4:	7d 83       	std	Y+5, r23	; 0x05
    1da6:	6c 83       	std	Y+4, r22	; 0x04
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1da8:	61 e1       	ldi	r22, 0x11	; 17
    1daa:	e6 2e       	mov	r14, r22
    1dac:	f1 2c       	mov	r15, r1
    1dae:	e8 0e       	add	r14, r24
    1db0:	f9 1e       	adc	r15, r25
    1db2:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1db4:	6e 01       	movw	r12, r28
    1db6:	08 94       	sec
    1db8:	c1 1c       	adc	r12, r1
    1dba:	d1 1c       	adc	r13, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1dbc:	54 e0       	ldi	r21, 0x04	; 4
    1dbe:	a5 2e       	mov	r10, r21
    1dc0:	b1 2c       	mov	r11, r1
    1dc2:	ac 0e       	add	r10, r28
    1dc4:	bd 1e       	adc	r11, r29
    1dc6:	01 c0       	rjmp	.+2      	; 0x1dca <xQueueSemaphoreTake+0x46>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1dc8:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1dca:	0f b6       	in	r0, 0x3f	; 63
    1dcc:	f8 94       	cli
    1dce:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1dd0:	f8 01       	movw	r30, r16
    1dd2:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1dd4:	88 23       	and	r24, r24
    1dd6:	89 f0       	breq	.+34     	; 0x1dfa <xQueueSemaphoreTake+0x76>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1dd8:	81 50       	subi	r24, 0x01	; 1
    1dda:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ddc:	80 85       	ldd	r24, Z+8	; 0x08
    1dde:	88 23       	and	r24, r24
    1de0:	41 f0       	breq	.+16     	; 0x1df2 <xQueueSemaphoreTake+0x6e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1de2:	c8 01       	movw	r24, r16
    1de4:	08 96       	adiw	r24, 0x08	; 8
    1de6:	0e 94 57 17 	call	0x2eae	; 0x2eae <xTaskRemoveFromEventList>
    1dea:	88 23       	and	r24, r24
    1dec:	11 f0       	breq	.+4      	; 0x1df2 <xQueueSemaphoreTake+0x6e>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1dee:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1df2:	0f 90       	pop	r0
    1df4:	0f be       	out	0x3f, r0	; 63
    1df6:	81 e0       	ldi	r24, 0x01	; 1
    1df8:	54 c0       	rjmp	.+168    	; 0x1ea2 <xQueueSemaphoreTake+0x11e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1dfa:	8c 81       	ldd	r24, Y+4	; 0x04
    1dfc:	9d 81       	ldd	r25, Y+5	; 0x05
    1dfe:	89 2b       	or	r24, r25
    1e00:	21 f4       	brne	.+8      	; 0x1e0a <xQueueSemaphoreTake+0x86>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    1e02:	0f 90       	pop	r0
    1e04:	0f be       	out	0x3f, r0	; 63
    1e06:	80 e0       	ldi	r24, 0x00	; 0
    1e08:	4c c0       	rjmp	.+152    	; 0x1ea2 <xQueueSemaphoreTake+0x11e>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    1e0a:	22 23       	and	r18, r18
    1e0c:	19 f4       	brne	.+6      	; 0x1e14 <xQueueSemaphoreTake+0x90>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1e0e:	c6 01       	movw	r24, r12
    1e10:	0e 94 b4 18 	call	0x3168	; 0x3168 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1e14:	0f 90       	pop	r0
    1e16:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1e18:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1e1c:	0f b6       	in	r0, 0x3f	; 63
    1e1e:	f8 94       	cli
    1e20:	0f 92       	push	r0
    1e22:	f8 01       	movw	r30, r16
    1e24:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e26:	8f 3f       	cpi	r24, 0xFF	; 255
    1e28:	09 f4       	brne	.+2      	; 0x1e2c <xQueueSemaphoreTake+0xa8>
    1e2a:	15 8e       	std	Z+29, r1	; 0x1d
    1e2c:	f8 01       	movw	r30, r16
    1e2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e30:	8f 3f       	cpi	r24, 0xFF	; 255
    1e32:	09 f4       	brne	.+2      	; 0x1e36 <xQueueSemaphoreTake+0xb2>
    1e34:	16 8e       	std	Z+30, r1	; 0x1e
    1e36:	0f 90       	pop	r0
    1e38:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e3a:	c6 01       	movw	r24, r12
    1e3c:	b5 01       	movw	r22, r10
    1e3e:	0e 94 bf 18 	call	0x317e	; 0x317e <xTaskCheckForTimeOut>
    1e42:	88 23       	and	r24, r24
    1e44:	f9 f4       	brne	.+62     	; 0x1e84 <xQueueSemaphoreTake+0x100>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1e46:	0f b6       	in	r0, 0x3f	; 63
    1e48:	f8 94       	cli
    1e4a:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1e4c:	f8 01       	movw	r30, r16
    1e4e:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1e50:	0f 90       	pop	r0
    1e52:	0f be       	out	0x3f, r0	; 63
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e54:	88 23       	and	r24, r24
    1e56:	81 f4       	brne	.+32     	; 0x1e78 <xQueueSemaphoreTake+0xf4>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e58:	6c 81       	ldd	r22, Y+4	; 0x04
    1e5a:	7d 81       	ldd	r23, Y+5	; 0x05
    1e5c:	c7 01       	movw	r24, r14
    1e5e:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1e62:	c8 01       	movw	r24, r16
    1e64:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1e68:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
    1e6c:	88 23       	and	r24, r24
    1e6e:	09 f0       	breq	.+2      	; 0x1e72 <xQueueSemaphoreTake+0xee>
    1e70:	ab cf       	rjmp	.-170    	; 0x1dc8 <xQueueSemaphoreTake+0x44>
                {
                    portYIELD_WITHIN_API();
    1e72:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
    1e76:	a8 cf       	rjmp	.-176    	; 0x1dc8 <xQueueSemaphoreTake+0x44>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    1e78:	c8 01       	movw	r24, r16
    1e7a:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1e7e:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
    1e82:	a2 cf       	rjmp	.-188    	; 0x1dc8 <xQueueSemaphoreTake+0x44>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    1e84:	c8 01       	movw	r24, r16
    1e86:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1e8a:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1e8e:	0f b6       	in	r0, 0x3f	; 63
    1e90:	f8 94       	cli
    1e92:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1e94:	f8 01       	movw	r30, r16
    1e96:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1e98:	0f 90       	pop	r0
    1e9a:	0f be       	out	0x3f, r0	; 63

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e9c:	88 23       	and	r24, r24
    1e9e:	09 f0       	breq	.+2      	; 0x1ea2 <xQueueSemaphoreTake+0x11e>
    1ea0:	93 cf       	rjmp	.-218    	; 0x1dc8 <xQueueSemaphoreTake+0x44>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    1ea2:	0f 90       	pop	r0
    1ea4:	0f 90       	pop	r0
    1ea6:	0f 90       	pop	r0
    1ea8:	0f 90       	pop	r0
    1eaa:	0f 90       	pop	r0
    1eac:	cf 91       	pop	r28
    1eae:	df 91       	pop	r29
    1eb0:	1f 91       	pop	r17
    1eb2:	0f 91       	pop	r16
    1eb4:	ff 90       	pop	r15
    1eb6:	ef 90       	pop	r14
    1eb8:	df 90       	pop	r13
    1eba:	cf 90       	pop	r12
    1ebc:	bf 90       	pop	r11
    1ebe:	af 90       	pop	r10
    1ec0:	08 95       	ret

00001ec2 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    1ec2:	6f 92       	push	r6
    1ec4:	7f 92       	push	r7
    1ec6:	8f 92       	push	r8
    1ec8:	9f 92       	push	r9
    1eca:	af 92       	push	r10
    1ecc:	bf 92       	push	r11
    1ece:	cf 92       	push	r12
    1ed0:	df 92       	push	r13
    1ed2:	ff 92       	push	r15
    1ed4:	0f 93       	push	r16
    1ed6:	1f 93       	push	r17
    1ed8:	df 93       	push	r29
    1eda:	cf 93       	push	r28
    1edc:	00 d0       	rcall	.+0      	; 0x1ede <xQueueReceive+0x1c>
    1ede:	00 d0       	rcall	.+0      	; 0x1ee0 <xQueueReceive+0x1e>
    1ee0:	0f 92       	push	r0
    1ee2:	cd b7       	in	r28, 0x3d	; 61
    1ee4:	de b7       	in	r29, 0x3e	; 62
    1ee6:	8c 01       	movw	r16, r24
    1ee8:	5b 01       	movw	r10, r22
    1eea:	5d 83       	std	Y+5, r21	; 0x05
    1eec:	4c 83       	std	Y+4, r20	; 0x04
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1eee:	e1 e1       	ldi	r30, 0x11	; 17
    1ef0:	ce 2e       	mov	r12, r30
    1ef2:	d1 2c       	mov	r13, r1
    1ef4:	c8 0e       	add	r12, r24
    1ef6:	d9 1e       	adc	r13, r25
    1ef8:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1efa:	4e 01       	movw	r8, r28
    1efc:	08 94       	sec
    1efe:	81 1c       	adc	r8, r1
    1f00:	91 1c       	adc	r9, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f02:	74 e0       	ldi	r23, 0x04	; 4
    1f04:	67 2e       	mov	r6, r23
    1f06:	71 2c       	mov	r7, r1
    1f08:	6c 0e       	add	r6, r28
    1f0a:	7d 1e       	adc	r7, r29
    1f0c:	01 c0       	rjmp	.+2      	; 0x1f10 <xQueueReceive+0x4e>
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f0e:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1f10:	0f b6       	in	r0, 0x3f	; 63
    1f12:	f8 94       	cli
    1f14:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1f16:	f8 01       	movw	r30, r16
    1f18:	f2 8c       	ldd	r15, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f1a:	ff 20       	and	r15, r15
    1f1c:	b1 f0       	breq	.+44     	; 0x1f4a <xQueueReceive+0x88>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f1e:	c8 01       	movw	r24, r16
    1f20:	b5 01       	movw	r22, r10
    1f22:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1f26:	fa 94       	dec	r15
    1f28:	f8 01       	movw	r30, r16
    1f2a:	f2 8e       	std	Z+26, r15	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f2c:	80 85       	ldd	r24, Z+8	; 0x08
    1f2e:	88 23       	and	r24, r24
    1f30:	41 f0       	breq	.+16     	; 0x1f42 <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f32:	c8 01       	movw	r24, r16
    1f34:	08 96       	adiw	r24, 0x08	; 8
    1f36:	0e 94 57 17 	call	0x2eae	; 0x2eae <xTaskRemoveFromEventList>
    1f3a:	88 23       	and	r24, r24
    1f3c:	11 f0       	breq	.+4      	; 0x1f42 <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1f3e:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1f42:	0f 90       	pop	r0
    1f44:	0f be       	out	0x3f, r0	; 63
    1f46:	81 e0       	ldi	r24, 0x01	; 1
    1f48:	54 c0       	rjmp	.+168    	; 0x1ff2 <xQueueReceive+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1f4a:	8c 81       	ldd	r24, Y+4	; 0x04
    1f4c:	9d 81       	ldd	r25, Y+5	; 0x05
    1f4e:	89 2b       	or	r24, r25
    1f50:	21 f4       	brne	.+8      	; 0x1f5a <xQueueReceive+0x98>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1f52:	0f 90       	pop	r0
    1f54:	0f be       	out	0x3f, r0	; 63
    1f56:	80 e0       	ldi	r24, 0x00	; 0
    1f58:	4c c0       	rjmp	.+152    	; 0x1ff2 <xQueueReceive+0x130>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    1f5a:	22 23       	and	r18, r18
    1f5c:	19 f4       	brne	.+6      	; 0x1f64 <xQueueReceive+0xa2>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1f5e:	c4 01       	movw	r24, r8
    1f60:	0e 94 b4 18 	call	0x3168	; 0x3168 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1f64:	0f 90       	pop	r0
    1f66:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1f68:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1f6c:	0f b6       	in	r0, 0x3f	; 63
    1f6e:	f8 94       	cli
    1f70:	0f 92       	push	r0
    1f72:	f8 01       	movw	r30, r16
    1f74:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f76:	8f 3f       	cpi	r24, 0xFF	; 255
    1f78:	09 f4       	brne	.+2      	; 0x1f7c <xQueueReceive+0xba>
    1f7a:	15 8e       	std	Z+29, r1	; 0x1d
    1f7c:	f8 01       	movw	r30, r16
    1f7e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f80:	8f 3f       	cpi	r24, 0xFF	; 255
    1f82:	09 f4       	brne	.+2      	; 0x1f86 <xQueueReceive+0xc4>
    1f84:	16 8e       	std	Z+30, r1	; 0x1e
    1f86:	0f 90       	pop	r0
    1f88:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f8a:	c4 01       	movw	r24, r8
    1f8c:	b3 01       	movw	r22, r6
    1f8e:	0e 94 bf 18 	call	0x317e	; 0x317e <xTaskCheckForTimeOut>
    1f92:	88 23       	and	r24, r24
    1f94:	f9 f4       	brne	.+62     	; 0x1fd4 <xQueueReceive+0x112>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1f96:	0f b6       	in	r0, 0x3f	; 63
    1f98:	f8 94       	cli
    1f9a:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1f9c:	f8 01       	movw	r30, r16
    1f9e:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1fa0:	0f 90       	pop	r0
    1fa2:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fa4:	88 23       	and	r24, r24
    1fa6:	81 f4       	brne	.+32     	; 0x1fc8 <xQueueReceive+0x106>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1fa8:	6c 81       	ldd	r22, Y+4	; 0x04
    1faa:	7d 81       	ldd	r23, Y+5	; 0x05
    1fac:	c6 01       	movw	r24, r12
    1fae:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1fb2:	c8 01       	movw	r24, r16
    1fb4:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1fb8:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
    1fbc:	88 23       	and	r24, r24
    1fbe:	09 f0       	breq	.+2      	; 0x1fc2 <xQueueReceive+0x100>
    1fc0:	a6 cf       	rjmp	.-180    	; 0x1f0e <xQueueReceive+0x4c>
                {
                    portYIELD_WITHIN_API();
    1fc2:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
    1fc6:	a3 cf       	rjmp	.-186    	; 0x1f0e <xQueueReceive+0x4c>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    1fc8:	c8 01       	movw	r24, r16
    1fca:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1fce:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
    1fd2:	9d cf       	rjmp	.-198    	; 0x1f0e <xQueueReceive+0x4c>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    1fd4:	c8 01       	movw	r24, r16
    1fd6:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1fda:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1fde:	0f b6       	in	r0, 0x3f	; 63
    1fe0:	f8 94       	cli
    1fe2:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1fe4:	f8 01       	movw	r30, r16
    1fe6:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1fe8:	0f 90       	pop	r0
    1fea:	0f be       	out	0x3f, r0	; 63
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fec:	88 23       	and	r24, r24
    1fee:	09 f0       	breq	.+2      	; 0x1ff2 <xQueueReceive+0x130>
    1ff0:	8e cf       	rjmp	.-228    	; 0x1f0e <xQueueReceive+0x4c>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    1ff2:	0f 90       	pop	r0
    1ff4:	0f 90       	pop	r0
    1ff6:	0f 90       	pop	r0
    1ff8:	0f 90       	pop	r0
    1ffa:	0f 90       	pop	r0
    1ffc:	cf 91       	pop	r28
    1ffe:	df 91       	pop	r29
    2000:	1f 91       	pop	r17
    2002:	0f 91       	pop	r16
    2004:	ff 90       	pop	r15
    2006:	df 90       	pop	r13
    2008:	cf 90       	pop	r12
    200a:	bf 90       	pop	r11
    200c:	af 90       	pop	r10
    200e:	9f 90       	pop	r9
    2010:	8f 90       	pop	r8
    2012:	7f 90       	pop	r7
    2014:	6f 90       	pop	r6
    2016:	08 95       	ret

00002018 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    2018:	6f 92       	push	r6
    201a:	7f 92       	push	r7
    201c:	9f 92       	push	r9
    201e:	af 92       	push	r10
    2020:	bf 92       	push	r11
    2022:	cf 92       	push	r12
    2024:	df 92       	push	r13
    2026:	ef 92       	push	r14
    2028:	ff 92       	push	r15
    202a:	0f 93       	push	r16
    202c:	1f 93       	push	r17
    202e:	df 93       	push	r29
    2030:	cf 93       	push	r28
    2032:	00 d0       	rcall	.+0      	; 0x2034 <xQueueGenericSend+0x1c>
    2034:	00 d0       	rcall	.+0      	; 0x2036 <xQueueGenericSend+0x1e>
    2036:	0f 92       	push	r0
    2038:	cd b7       	in	r28, 0x3d	; 61
    203a:	de b7       	in	r29, 0x3e	; 62
    203c:	8c 01       	movw	r16, r24
    203e:	6b 01       	movw	r12, r22
    2040:	5d 83       	std	Y+5, r21	; 0x05
    2042:	4c 83       	std	Y+4, r20	; 0x04
    2044:	92 2e       	mov	r9, r18
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2046:	a8 e0       	ldi	r26, 0x08	; 8
    2048:	ea 2e       	mov	r14, r26
    204a:	f1 2c       	mov	r15, r1
    204c:	e8 0e       	add	r14, r24
    204e:	f9 1e       	adc	r15, r25
    2050:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2052:	5e 01       	movw	r10, r28
    2054:	08 94       	sec
    2056:	a1 1c       	adc	r10, r1
    2058:	b1 1c       	adc	r11, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    205a:	f4 e0       	ldi	r31, 0x04	; 4
    205c:	6f 2e       	mov	r6, r31
    205e:	71 2c       	mov	r7, r1
    2060:	6c 0e       	add	r6, r28
    2062:	7d 1e       	adc	r7, r29
    2064:	01 c0       	rjmp	.+2      	; 0x2068 <xQueueGenericSend+0x50>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2066:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2068:	0f b6       	in	r0, 0x3f	; 63
    206a:	f8 94       	cli
    206c:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    206e:	f8 01       	movw	r30, r16
    2070:	92 8d       	ldd	r25, Z+26	; 0x1a
    2072:	83 8d       	ldd	r24, Z+27	; 0x1b
    2074:	98 17       	cp	r25, r24
    2076:	18 f0       	brcs	.+6      	; 0x207e <xQueueGenericSend+0x66>
    2078:	f2 e0       	ldi	r31, 0x02	; 2
    207a:	9f 16       	cp	r9, r31
    207c:	c9 f4       	brne	.+50     	; 0x20b0 <xQueueGenericSend+0x98>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    207e:	c8 01       	movw	r24, r16
    2080:	b6 01       	movw	r22, r12
    2082:	49 2d       	mov	r20, r9
    2084:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <prvCopyDataToQueue>
    2088:	98 2f       	mov	r25, r24

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    208a:	f8 01       	movw	r30, r16
    208c:	81 89       	ldd	r24, Z+17	; 0x11
    208e:	88 23       	and	r24, r24
    2090:	39 f0       	breq	.+14     	; 0x20a0 <xQueueGenericSend+0x88>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2092:	c8 01       	movw	r24, r16
    2094:	41 96       	adiw	r24, 0x11	; 17
    2096:	0e 94 57 17 	call	0x2eae	; 0x2eae <xTaskRemoveFromEventList>
    209a:	88 23       	and	r24, r24
    209c:	29 f0       	breq	.+10     	; 0x20a8 <xQueueGenericSend+0x90>
    209e:	02 c0       	rjmp	.+4      	; 0x20a4 <xQueueGenericSend+0x8c>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    20a0:	99 23       	and	r25, r25
    20a2:	11 f0       	breq	.+4      	; 0x20a8 <xQueueGenericSend+0x90>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    20a4:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    20a8:	0f 90       	pop	r0
    20aa:	0f be       	out	0x3f, r0	; 63
    20ac:	81 e0       	ldi	r24, 0x01	; 1
    20ae:	4c c0       	rjmp	.+152    	; 0x2148 <xQueueGenericSend+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    20b0:	8c 81       	ldd	r24, Y+4	; 0x04
    20b2:	9d 81       	ldd	r25, Y+5	; 0x05
    20b4:	89 2b       	or	r24, r25
    20b6:	19 f4       	brne	.+6      	; 0x20be <xQueueGenericSend+0xa6>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    20b8:	0f 90       	pop	r0
    20ba:	0f be       	out	0x3f, r0	; 63
    20bc:	44 c0       	rjmp	.+136    	; 0x2146 <xQueueGenericSend+0x12e>
                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
                }
                else if( xEntryTimeSet == pdFALSE )
    20be:	22 23       	and	r18, r18
    20c0:	19 f4       	brne	.+6      	; 0x20c8 <xQueueGenericSend+0xb0>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    20c2:	c5 01       	movw	r24, r10
    20c4:	0e 94 b4 18 	call	0x3168	; 0x3168 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    20c8:	0f 90       	pop	r0
    20ca:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    20cc:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    20d0:	0f b6       	in	r0, 0x3f	; 63
    20d2:	f8 94       	cli
    20d4:	0f 92       	push	r0
    20d6:	f8 01       	movw	r30, r16
    20d8:	85 8d       	ldd	r24, Z+29	; 0x1d
    20da:	8f 3f       	cpi	r24, 0xFF	; 255
    20dc:	09 f4       	brne	.+2      	; 0x20e0 <xQueueGenericSend+0xc8>
    20de:	15 8e       	std	Z+29, r1	; 0x1d
    20e0:	f8 01       	movw	r30, r16
    20e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    20e4:	8f 3f       	cpi	r24, 0xFF	; 255
    20e6:	09 f4       	brne	.+2      	; 0x20ea <xQueueGenericSend+0xd2>
    20e8:	16 8e       	std	Z+30, r1	; 0x1e
    20ea:	0f 90       	pop	r0
    20ec:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    20ee:	c5 01       	movw	r24, r10
    20f0:	b3 01       	movw	r22, r6
    20f2:	0e 94 bf 18 	call	0x317e	; 0x317e <xTaskCheckForTimeOut>
    20f6:	88 23       	and	r24, r24
    20f8:	09 f5       	brne	.+66     	; 0x213c <xQueueGenericSend+0x124>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    20fa:	0f b6       	in	r0, 0x3f	; 63
    20fc:	f8 94       	cli
    20fe:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2100:	f8 01       	movw	r30, r16
    2102:	92 8d       	ldd	r25, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    2104:	0f 90       	pop	r0
    2106:	0f be       	out	0x3f, r0	; 63
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2108:	f8 01       	movw	r30, r16
    210a:	83 8d       	ldd	r24, Z+27	; 0x1b
    210c:	98 17       	cp	r25, r24
    210e:	81 f4       	brne	.+32     	; 0x2130 <xQueueGenericSend+0x118>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2110:	6c 81       	ldd	r22, Y+4	; 0x04
    2112:	7d 81       	ldd	r23, Y+5	; 0x05
    2114:	c7 01       	movw	r24, r14
    2116:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    211a:	c8 01       	movw	r24, r16
    211c:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    2120:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
    2124:	88 23       	and	r24, r24
    2126:	09 f0       	breq	.+2      	; 0x212a <xQueueGenericSend+0x112>
    2128:	9e cf       	rjmp	.-196    	; 0x2066 <xQueueGenericSend+0x4e>
                {
                    portYIELD_WITHIN_API();
    212a:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
    212e:	9b cf       	rjmp	.-202    	; 0x2066 <xQueueGenericSend+0x4e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    2130:	c8 01       	movw	r24, r16
    2132:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2136:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
    213a:	95 cf       	rjmp	.-214    	; 0x2066 <xQueueGenericSend+0x4e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    213c:	c8 01       	movw	r24, r16
    213e:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2142:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
    2146:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
    2148:	0f 90       	pop	r0
    214a:	0f 90       	pop	r0
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	0f 90       	pop	r0
    2152:	cf 91       	pop	r28
    2154:	df 91       	pop	r29
    2156:	1f 91       	pop	r17
    2158:	0f 91       	pop	r16
    215a:	ff 90       	pop	r15
    215c:	ef 90       	pop	r14
    215e:	df 90       	pop	r13
    2160:	cf 90       	pop	r12
    2162:	bf 90       	pop	r11
    2164:	af 90       	pop	r10
    2166:	9f 90       	pop	r9
    2168:	7f 90       	pop	r7
    216a:	6f 90       	pop	r6
    216c:	08 95       	ret

0000216e <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    216e:	cf 93       	push	r28
    2170:	df 93       	push	r29
    2172:	ec 01       	movw	r28, r24
    2174:	e6 2f       	mov	r30, r22
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    2176:	00 97       	sbiw	r24, 0x00	; 0
    2178:	09 f4       	brne	.+2      	; 0x217c <xQueueGenericReset+0xe>
    217a:	4f c0       	rjmp	.+158    	; 0x221a <xQueueGenericReset+0xac>
    217c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    217e:	22 23       	and	r18, r18
    2180:	09 f4       	brne	.+2      	; 0x2184 <xQueueGenericReset+0x16>
    2182:	4b c0       	rjmp	.+150    	; 0x221a <xQueueGenericReset+0xac>
    2184:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2186:	8f ef       	ldi	r24, 0xFF	; 255
    2188:	9f e7       	ldi	r25, 0x7F	; 127
    218a:	62 2f       	mov	r22, r18
    218c:	70 e0       	ldi	r23, 0x00	; 0
    218e:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <__udivmodhi4>
    2192:	83 2f       	mov	r24, r19
    2194:	90 e0       	ldi	r25, 0x00	; 0
    2196:	68 17       	cp	r22, r24
    2198:	79 07       	cpc	r23, r25
    219a:	08 f4       	brcc	.+2      	; 0x219e <xQueueGenericReset+0x30>
    219c:	3e c0       	rjmp	.+124    	; 0x221a <xQueueGenericReset+0xac>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    219e:	0f b6       	in	r0, 0x3f	; 63
    21a0:	f8 94       	cli
    21a2:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    21a4:	32 9f       	mul	r19, r18
    21a6:	c0 01       	movw	r24, r0
    21a8:	11 24       	eor	r1, r1
    21aa:	48 81       	ld	r20, Y
    21ac:	59 81       	ldd	r21, Y+1	; 0x01
    21ae:	84 0f       	add	r24, r20
    21b0:	95 1f       	adc	r25, r21
    21b2:	9d 83       	std	Y+5, r25	; 0x05
    21b4:	8c 83       	std	Y+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    21b6:	1a 8e       	std	Y+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    21b8:	5b 83       	std	Y+3, r21	; 0x03
    21ba:	4a 83       	std	Y+2, r20	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    21bc:	2b 8d       	ldd	r18, Y+27	; 0x1b
    21be:	30 e0       	ldi	r19, 0x00	; 0
    21c0:	21 50       	subi	r18, 0x01	; 1
    21c2:	30 40       	sbci	r19, 0x00	; 0
    21c4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	bc 01       	movw	r22, r24
    21ca:	26 9f       	mul	r18, r22
    21cc:	c0 01       	movw	r24, r0
    21ce:	27 9f       	mul	r18, r23
    21d0:	90 0d       	add	r25, r0
    21d2:	36 9f       	mul	r19, r22
    21d4:	90 0d       	add	r25, r0
    21d6:	11 24       	eor	r1, r1
    21d8:	48 0f       	add	r20, r24
    21da:	59 1f       	adc	r21, r25
    21dc:	5f 83       	std	Y+7, r21	; 0x07
    21de:	4e 83       	std	Y+6, r20	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    21e0:	8f ef       	ldi	r24, 0xFF	; 255
    21e2:	8d 8f       	std	Y+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    21e4:	8e 8f       	std	Y+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    21e6:	ee 23       	and	r30, r30
    21e8:	61 f4       	brne	.+24     	; 0x2202 <xQueueGenericReset+0x94>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    21ea:	88 85       	ldd	r24, Y+8	; 0x08
    21ec:	88 23       	and	r24, r24
    21ee:	89 f0       	breq	.+34     	; 0x2212 <xQueueGenericReset+0xa4>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    21f0:	ce 01       	movw	r24, r28
    21f2:	08 96       	adiw	r24, 0x08	; 8
    21f4:	0e 94 57 17 	call	0x2eae	; 0x2eae <xTaskRemoveFromEventList>
    21f8:	88 23       	and	r24, r24
    21fa:	59 f0       	breq	.+22     	; 0x2212 <xQueueGenericReset+0xa4>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    21fc:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
    2200:	08 c0       	rjmp	.+16     	; 0x2212 <xQueueGenericReset+0xa4>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2202:	ce 01       	movw	r24, r28
    2204:	08 96       	adiw	r24, 0x08	; 8
    2206:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    220a:	ce 01       	movw	r24, r28
    220c:	41 96       	adiw	r24, 0x11	; 17
    220e:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    2212:	0f 90       	pop	r0
    2214:	0f be       	out	0x3f, r0	; 63
    2216:	81 e0       	ldi	r24, 0x01	; 1
    2218:	01 c0       	rjmp	.+2      	; 0x221c <xQueueGenericReset+0xae>
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    221a:	80 e0       	ldi	r24, 0x00	; 0
    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
}
    221c:	df 91       	pop	r29
    221e:	cf 91       	pop	r28
    2220:	08 95       	ret

00002222 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    2222:	0f 93       	push	r16
    2224:	1f 93       	push	r17
    2226:	cf 93       	push	r28
    2228:	df 93       	push	r29
    222a:	18 2f       	mov	r17, r24
    222c:	06 2f       	mov	r16, r22
        Queue_t * pxNewQueue = NULL;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    222e:	88 23       	and	r24, r24
    2230:	41 f1       	breq	.+80     	; 0x2282 <xQueueGenericCreate+0x60>
    2232:	8f ef       	ldi	r24, 0xFF	; 255
    2234:	9f e7       	ldi	r25, 0x7F	; 127
    2236:	61 2f       	mov	r22, r17
    2238:	70 e0       	ldi	r23, 0x00	; 0
    223a:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <__udivmodhi4>
    223e:	80 2f       	mov	r24, r16
    2240:	90 e0       	ldi	r25, 0x00	; 0
    2242:	68 17       	cp	r22, r24
    2244:	79 07       	cpc	r23, r25
    2246:	e8 f0       	brcs	.+58     	; 0x2282 <xQueueGenericCreate+0x60>
    2248:	01 9f       	mul	r16, r17
    224a:	c0 01       	movw	r24, r0
    224c:	11 24       	eor	r1, r1
    224e:	2f e7       	ldi	r18, 0x7F	; 127
    2250:	81 3e       	cpi	r24, 0xE1	; 225
    2252:	92 07       	cpc	r25, r18
    2254:	b0 f4       	brcc	.+44     	; 0x2282 <xQueueGenericCreate+0x60>
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2256:	4f 96       	adiw	r24, 0x1f	; 31
    2258:	0e 94 b5 0a 	call	0x156a	; 0x156a <pvPortMalloc>
    225c:	fc 01       	movw	r30, r24
    225e:	ec 01       	movw	r28, r24

            if( pxNewQueue != NULL )
    2260:	00 97       	sbiw	r24, 0x00	; 0
    2262:	89 f0       	breq	.+34     	; 0x2286 <xQueueGenericCreate+0x64>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    2264:	00 23       	and	r16, r16
    2266:	19 f4       	brne	.+6      	; 0x226e <xQueueGenericCreate+0x4c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2268:	91 83       	std	Z+1, r25	; 0x01
    226a:	80 83       	st	Z, r24
    226c:	03 c0       	rjmp	.+6      	; 0x2274 <xQueueGenericCreate+0x52>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    226e:	4f 96       	adiw	r24, 0x1f	; 31
    2270:	91 83       	std	Z+1, r25	; 0x01
    2272:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    2274:	13 8f       	std	Z+27, r17	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    2276:	04 8f       	std	Z+28, r16	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2278:	cf 01       	movw	r24, r30
    227a:	61 e0       	ldi	r22, 0x01	; 1
    227c:	0e 94 b7 10 	call	0x216e	; 0x216e <xQueueGenericReset>
    2280:	02 c0       	rjmp	.+4      	; 0x2286 <xQueueGenericCreate+0x64>
    2282:	c0 e0       	ldi	r28, 0x00	; 0
    2284:	d0 e0       	ldi	r29, 0x00	; 0
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
    2286:	ce 01       	movw	r24, r28
    2288:	df 91       	pop	r29
    228a:	cf 91       	pop	r28
    228c:	1f 91       	pop	r17
    228e:	0f 91       	pop	r16
    2290:	08 95       	ret

00002292 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
    2292:	1f 93       	push	r17
    2294:	16 2f       	mov	r17, r22
        QueueHandle_t xHandle = NULL;

        if( ( uxMaxCount != 0 ) &&
    2296:	88 23       	and	r24, r24
    2298:	59 f0       	breq	.+22     	; 0x22b0 <xQueueCreateCountingSemaphore+0x1e>
    229a:	86 17       	cp	r24, r22
    229c:	48 f0       	brcs	.+18     	; 0x22b0 <xQueueCreateCountingSemaphore+0x1e>
            ( uxInitialCount <= uxMaxCount ) )
        {
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    229e:	60 e0       	ldi	r22, 0x00	; 0
    22a0:	42 e0       	ldi	r20, 0x02	; 2
    22a2:	0e 94 11 11 	call	0x2222	; 0x2222 <xQueueGenericCreate>
    22a6:	fc 01       	movw	r30, r24

            if( xHandle != NULL )
    22a8:	00 97       	sbiw	r24, 0x00	; 0
    22aa:	21 f0       	breq	.+8      	; 0x22b4 <xQueueCreateCountingSemaphore+0x22>
            {
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    22ac:	12 8f       	std	Z+26, r17	; 0x1a
    22ae:	02 c0       	rjmp	.+4      	; 0x22b4 <xQueueCreateCountingSemaphore+0x22>
    22b0:	e0 e0       	ldi	r30, 0x00	; 0
    22b2:	f0 e0       	ldi	r31, 0x00	; 0
            configASSERT( xHandle );
            mtCOVERAGE_TEST_MARKER();
        }

        return xHandle;
    }
    22b4:	cf 01       	movw	r24, r30
    22b6:	1f 91       	pop	r17
    22b8:	08 95       	ret

000022ba <xStreamBufferSetTriggerLevel>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    22ba:	fc 01       	movw	r30, r24
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    22bc:	61 15       	cp	r22, r1
    22be:	71 05       	cpc	r23, r1
    22c0:	11 f4       	brne	.+4      	; 0x22c6 <xStreamBufferSetTriggerLevel+0xc>
    22c2:	61 e0       	ldi	r22, 0x01	; 1
    22c4:	70 e0       	ldi	r23, 0x00	; 0
        xTriggerLevel = ( size_t ) 1;
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    22c6:	84 81       	ldd	r24, Z+4	; 0x04
    22c8:	95 81       	ldd	r25, Z+5	; 0x05
    22ca:	68 17       	cp	r22, r24
    22cc:	79 07       	cpc	r23, r25
    22ce:	10 f0       	brcs	.+4      	; 0x22d4 <xStreamBufferSetTriggerLevel+0x1a>
    22d0:	80 e0       	ldi	r24, 0x00	; 0
    22d2:	08 95       	ret
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    22d4:	77 83       	std	Z+7, r23	; 0x07
    22d6:	66 83       	std	Z+6, r22	; 0x06
    22d8:	81 e0       	ldi	r24, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    22da:	08 95       	ret

000022dc <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    22dc:	fc 01       	movw	r30, r24
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    22de:	64 81       	ldd	r22, Z+4	; 0x04
    22e0:	75 81       	ldd	r23, Z+5	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    22e2:	20 81       	ld	r18, Z
    22e4:	31 81       	ldd	r19, Z+1	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    22e6:	40 81       	ld	r20, Z
    22e8:	51 81       	ldd	r21, Z+1	; 0x01
        xSpace -= pxStreamBuffer->xHead;
    22ea:	82 81       	ldd	r24, Z+2	; 0x02
    22ec:	93 81       	ldd	r25, Z+3	; 0x03
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    22ee:	46 0f       	add	r20, r22
    22f0:	57 1f       	adc	r21, r23
        xSpace -= pxStreamBuffer->xHead;
    22f2:	48 1b       	sub	r20, r24
    22f4:	59 0b       	sbc	r21, r25
    } while( xOriginalTail != pxStreamBuffer->xTail );
    22f6:	80 81       	ld	r24, Z
    22f8:	91 81       	ldd	r25, Z+1	; 0x01
    22fa:	28 17       	cp	r18, r24
    22fc:	39 07       	cpc	r19, r25
    22fe:	89 f7       	brne	.-30     	; 0x22e2 <xStreamBufferSpacesAvailable+0x6>

    xSpace -= ( size_t ) 1;
    2300:	9a 01       	movw	r18, r20
    2302:	21 50       	subi	r18, 0x01	; 1
    2304:	30 40       	sbci	r19, 0x00	; 0

    if( xSpace >= pxStreamBuffer->xLength )
    2306:	26 17       	cp	r18, r22
    2308:	37 07       	cpc	r19, r23
    230a:	10 f0       	brcs	.+4      	; 0x2310 <xStreamBufferSpacesAvailable+0x34>
    {
        xSpace -= pxStreamBuffer->xLength;
    230c:	26 1b       	sub	r18, r22
    230e:	37 0b       	sbc	r19, r23
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
}
    2310:	c9 01       	movw	r24, r18
    2312:	08 95       	ret

00002314 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2314:	fc 01       	movw	r30, r24
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2316:	44 81       	ldd	r20, Z+4	; 0x04
    2318:	55 81       	ldd	r21, Z+5	; 0x05
    231a:	22 81       	ldd	r18, Z+2	; 0x02
    231c:	33 81       	ldd	r19, Z+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    231e:	80 81       	ld	r24, Z
    2320:	91 81       	ldd	r25, Z+1	; 0x01
    2322:	24 0f       	add	r18, r20
    2324:	35 1f       	adc	r19, r21
    2326:	28 1b       	sub	r18, r24
    2328:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    232a:	24 17       	cp	r18, r20
    232c:	35 07       	cpc	r19, r21
    232e:	10 f0       	brcs	.+4      	; 0x2334 <xStreamBufferBytesAvailable+0x20>
    {
        xCount -= pxStreamBuffer->xLength;
    2330:	24 1b       	sub	r18, r20
    2332:	35 0b       	sbc	r19, r21

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    return xReturn;
}
    2334:	c9 01       	movw	r24, r18
    2336:	08 95       	ret

00002338 <xStreamBufferIsEmpty>:
    return xCount;
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    2338:	fc 01       	movw	r30, r24
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    233a:	20 81       	ld	r18, Z
    233c:	31 81       	ldd	r19, Z+1	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    233e:	82 81       	ldd	r24, Z+2	; 0x02
    2340:	93 81       	ldd	r25, Z+3	; 0x03
    2342:	40 e0       	ldi	r20, 0x00	; 0
    2344:	82 17       	cp	r24, r18
    2346:	93 07       	cpc	r25, r19
    2348:	09 f4       	brne	.+2      	; 0x234c <xStreamBufferIsEmpty+0x14>
    234a:	41 e0       	ldi	r20, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    234c:	84 2f       	mov	r24, r20
    234e:	08 95       	ret

00002350 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    2350:	cf 93       	push	r28
    2352:	df 93       	push	r29
    2354:	fc 01       	movw	r30, r24

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2356:	86 85       	ldd	r24, Z+14	; 0x0e
    2358:	80 fd       	sbrc	r24, 0
    235a:	03 c0       	rjmp	.+6      	; 0x2362 <xStreamBufferIsFull+0x12>
    235c:	c0 e0       	ldi	r28, 0x00	; 0
    235e:	d0 e0       	ldi	r29, 0x00	; 0
    2360:	02 c0       	rjmp	.+4      	; 0x2366 <xStreamBufferIsFull+0x16>
    2362:	c2 e0       	ldi	r28, 0x02	; 2
    2364:	d0 e0       	ldi	r29, 0x00	; 0
    {
        xBytesToStoreMessageLength = 0;
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    2366:	cf 01       	movw	r24, r30
    2368:	0e 94 6e 11 	call	0x22dc	; 0x22dc <xStreamBufferSpacesAvailable>
    236c:	20 e0       	ldi	r18, 0x00	; 0
    236e:	c8 17       	cp	r28, r24
    2370:	d9 07       	cpc	r29, r25
    2372:	08 f0       	brcs	.+2      	; 0x2376 <xStreamBufferIsFull+0x26>
    2374:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    2376:	82 2f       	mov	r24, r18
    2378:	df 91       	pop	r29
    237a:	cf 91       	pop	r28
    237c:	08 95       	ret

0000237e <xStreamBufferReceiveCompletedFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    237e:	cf 92       	push	r12
    2380:	df 92       	push	r13
    2382:	ef 92       	push	r14
    2384:	ff 92       	push	r15
    2386:	0f 93       	push	r16
    2388:	cf 93       	push	r28
    238a:	df 93       	push	r29
    238c:	ec 01       	movw	r28, r24
    238e:	6b 01       	movw	r12, r22

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    2390:	8a 85       	ldd	r24, Y+10	; 0x0a
    2392:	9b 85       	ldd	r25, Y+11	; 0x0b
    2394:	89 2b       	or	r24, r25
    2396:	11 f4       	brne	.+4      	; 0x239c <xStreamBufferReceiveCompletedFromISR+0x1e>
    2398:	80 e0       	ldi	r24, 0x00	; 0
    239a:	0f c0       	rjmp	.+30     	; 0x23ba <xStreamBufferReceiveCompletedFromISR+0x3c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    239c:	8a 85       	ldd	r24, Y+10	; 0x0a
    239e:	9b 85       	ldd	r25, Y+11	; 0x0b
    23a0:	60 e0       	ldi	r22, 0x00	; 0
    23a2:	20 e0       	ldi	r18, 0x00	; 0
    23a4:	30 e0       	ldi	r19, 0x00	; 0
    23a6:	40 e0       	ldi	r20, 0x00	; 0
    23a8:	50 e0       	ldi	r21, 0x00	; 0
    23aa:	00 e0       	ldi	r16, 0x00	; 0
    23ac:	ee 24       	eor	r14, r14
    23ae:	ff 24       	eor	r15, r15
    23b0:	0e 94 16 19 	call	0x322c	; 0x322c <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    23b4:	1b 86       	std	Y+11, r1	; 0x0b
    23b6:	1a 86       	std	Y+10, r1	; 0x0a
    23b8:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    23ba:	df 91       	pop	r29
    23bc:	cf 91       	pop	r28
    23be:	0f 91       	pop	r16
    23c0:	ff 90       	pop	r15
    23c2:	ef 90       	pop	r14
    23c4:	df 90       	pop	r13
    23c6:	cf 90       	pop	r12
    23c8:	08 95       	ret

000023ca <xStreamBufferSendCompletedFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    23ca:	cf 92       	push	r12
    23cc:	df 92       	push	r13
    23ce:	ef 92       	push	r14
    23d0:	ff 92       	push	r15
    23d2:	0f 93       	push	r16
    23d4:	cf 93       	push	r28
    23d6:	df 93       	push	r29
    23d8:	ec 01       	movw	r28, r24
    23da:	6b 01       	movw	r12, r22

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    23dc:	88 85       	ldd	r24, Y+8	; 0x08
    23de:	99 85       	ldd	r25, Y+9	; 0x09
    23e0:	89 2b       	or	r24, r25
    23e2:	11 f4       	brne	.+4      	; 0x23e8 <xStreamBufferSendCompletedFromISR+0x1e>
    23e4:	80 e0       	ldi	r24, 0x00	; 0
    23e6:	0f c0       	rjmp	.+30     	; 0x2406 <xStreamBufferSendCompletedFromISR+0x3c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    23e8:	88 85       	ldd	r24, Y+8	; 0x08
    23ea:	99 85       	ldd	r25, Y+9	; 0x09
    23ec:	60 e0       	ldi	r22, 0x00	; 0
    23ee:	20 e0       	ldi	r18, 0x00	; 0
    23f0:	30 e0       	ldi	r19, 0x00	; 0
    23f2:	40 e0       	ldi	r20, 0x00	; 0
    23f4:	50 e0       	ldi	r21, 0x00	; 0
    23f6:	00 e0       	ldi	r16, 0x00	; 0
    23f8:	ee 24       	eor	r14, r14
    23fa:	ff 24       	eor	r15, r15
    23fc:	0e 94 16 19 	call	0x322c	; 0x322c <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    2400:	19 86       	std	Y+9, r1	; 0x09
    2402:	18 86       	std	Y+8, r1	; 0x08
    2404:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2406:	df 91       	pop	r29
    2408:	cf 91       	pop	r28
    240a:	0f 91       	pop	r16
    240c:	ff 90       	pop	r15
    240e:	ef 90       	pop	r14
    2410:	df 90       	pop	r13
    2412:	cf 90       	pop	r12
    2414:	08 95       	ret

00002416 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    2416:	af 92       	push	r10
    2418:	bf 92       	push	r11
    241a:	cf 92       	push	r12
    241c:	df 92       	push	r13
    241e:	ef 92       	push	r14
    2420:	ff 92       	push	r15
    2422:	0f 93       	push	r16
    2424:	1f 93       	push	r17
    2426:	cf 93       	push	r28
    2428:	df 93       	push	r29
    242a:	6c 01       	movw	r12, r24
    242c:	8b 01       	movw	r16, r22
    242e:	7a 01       	movw	r14, r20
    2430:	59 01       	movw	r10, r18
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    2432:	dc 01       	movw	r26, r24
    2434:	14 96       	adiw	r26, 0x04	; 4
    2436:	cd 91       	ld	r28, X+
    2438:	dc 91       	ld	r29, X
    243a:	15 97       	sbiw	r26, 0x05	; 5
    243c:	c2 1b       	sub	r28, r18
    243e:	d3 0b       	sbc	r29, r19
    2440:	4c 17       	cp	r20, r28
    2442:	5d 07       	cpc	r21, r29
    2444:	08 f4       	brcc	.+2      	; 0x2448 <prvReadBytesFromBuffer+0x32>
    2446:	ea 01       	movw	r28, r20

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2448:	f6 01       	movw	r30, r12
    244a:	24 85       	ldd	r18, Z+12	; 0x0c
    244c:	35 85       	ldd	r19, Z+13	; 0x0d
    244e:	2a 0d       	add	r18, r10
    2450:	3b 1d       	adc	r19, r11
    2452:	c8 01       	movw	r24, r16
    2454:	b9 01       	movw	r22, r18
    2456:	ae 01       	movw	r20, r28
    2458:	0e 94 17 24 	call	0x482e	; 0x482e <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    245c:	ce 15       	cp	r28, r14
    245e:	df 05       	cpc	r29, r15
    2460:	80 f4       	brcc	.+32     	; 0x2482 <prvReadBytesFromBuffer+0x6c>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2462:	98 01       	movw	r18, r16
    2464:	2c 0f       	add	r18, r28
    2466:	3d 1f       	adc	r19, r29
    2468:	f7 01       	movw	r30, r14
    246a:	ec 1b       	sub	r30, r28
    246c:	fd 0b       	sbc	r31, r29
    246e:	d6 01       	movw	r26, r12
    2470:	1c 96       	adiw	r26, 0x0c	; 12
    2472:	6c 91       	ld	r22, X
    2474:	1c 97       	sbiw	r26, 0x0c	; 12
    2476:	1d 96       	adiw	r26, 0x0d	; 13
    2478:	7c 91       	ld	r23, X
    247a:	c9 01       	movw	r24, r18
    247c:	af 01       	movw	r20, r30
    247e:	0e 94 17 24 	call	0x482e	; 0x482e <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    2482:	95 01       	movw	r18, r10
    2484:	2e 0d       	add	r18, r14
    2486:	3f 1d       	adc	r19, r15

    if( xTail >= pxStreamBuffer->xLength )
    2488:	f6 01       	movw	r30, r12
    248a:	84 81       	ldd	r24, Z+4	; 0x04
    248c:	95 81       	ldd	r25, Z+5	; 0x05
    248e:	28 17       	cp	r18, r24
    2490:	39 07       	cpc	r19, r25
    2492:	10 f0       	brcs	.+4      	; 0x2498 <prvReadBytesFromBuffer+0x82>
    {
        xTail -= pxStreamBuffer->xLength;
    2494:	28 1b       	sub	r18, r24
    2496:	39 0b       	sbc	r19, r25
    }

    return xTail;
}
    2498:	c9 01       	movw	r24, r18
    249a:	df 91       	pop	r29
    249c:	cf 91       	pop	r28
    249e:	1f 91       	pop	r17
    24a0:	0f 91       	pop	r16
    24a2:	ff 90       	pop	r15
    24a4:	ef 90       	pop	r14
    24a6:	df 90       	pop	r13
    24a8:	cf 90       	pop	r12
    24aa:	bf 90       	pop	r11
    24ac:	af 90       	pop	r10
    24ae:	08 95       	ret

000024b0 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    24b0:	af 92       	push	r10
    24b2:	bf 92       	push	r11
    24b4:	cf 92       	push	r12
    24b6:	df 92       	push	r13
    24b8:	ef 92       	push	r14
    24ba:	ff 92       	push	r15
    24bc:	0f 93       	push	r16
    24be:	1f 93       	push	r17
    24c0:	df 93       	push	r29
    24c2:	cf 93       	push	r28
    24c4:	00 d0       	rcall	.+0      	; 0x24c6 <prvReadMessageFromBuffer+0x16>
    24c6:	cd b7       	in	r28, 0x3d	; 61
    24c8:	de b7       	in	r29, 0x3e	; 62
    24ca:	6c 01       	movw	r12, r24
    24cc:	5b 01       	movw	r10, r22
    24ce:	8a 01       	movw	r16, r20
    24d0:	79 01       	movw	r14, r18
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    24d2:	fc 01       	movw	r30, r24
    24d4:	20 81       	ld	r18, Z
    24d6:	31 81       	ldd	r19, Z+1	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    24d8:	86 85       	ldd	r24, Z+14	; 0x0e
    24da:	80 ff       	sbrs	r24, 0
    24dc:	14 c0       	rjmp	.+40     	; 0x2506 <prvReadMessageFromBuffer+0x56>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    24de:	c6 01       	movw	r24, r12
    24e0:	be 01       	movw	r22, r28
    24e2:	6f 5f       	subi	r22, 0xFF	; 255
    24e4:	7f 4f       	sbci	r23, 0xFF	; 255
    24e6:	42 e0       	ldi	r20, 0x02	; 2
    24e8:	50 e0       	ldi	r21, 0x00	; 0
    24ea:	0e 94 0b 12 	call	0x2416	; 0x2416 <prvReadBytesFromBuffer>
    24ee:	9c 01       	movw	r18, r24
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    24f0:	49 81       	ldd	r20, Y+1	; 0x01
    24f2:	5a 81       	ldd	r21, Y+2	; 0x02

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    24f4:	8e ef       	ldi	r24, 0xFE	; 254
    24f6:	9f ef       	ldi	r25, 0xFF	; 255
    24f8:	e8 0e       	add	r14, r24
    24fa:	f9 1e       	adc	r15, r25

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    24fc:	04 17       	cp	r16, r20
    24fe:	15 07       	cpc	r17, r21
    2500:	10 f4       	brcc	.+4      	; 0x2506 <prvReadMessageFromBuffer+0x56>
    2502:	40 e0       	ldi	r20, 0x00	; 0
    2504:	50 e0       	ldi	r21, 0x00	; 0
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    2506:	8a 01       	movw	r16, r20
    2508:	e4 16       	cp	r14, r20
    250a:	f5 06       	cpc	r15, r21
    250c:	08 f4       	brcc	.+2      	; 0x2510 <prvReadMessageFromBuffer+0x60>
    250e:	87 01       	movw	r16, r14

    if( xCount != ( size_t ) 0 )
    2510:	01 15       	cp	r16, r1
    2512:	11 05       	cpc	r17, r1
    2514:	41 f0       	breq	.+16     	; 0x2526 <prvReadMessageFromBuffer+0x76>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    2516:	c6 01       	movw	r24, r12
    2518:	b5 01       	movw	r22, r10
    251a:	a8 01       	movw	r20, r16
    251c:	0e 94 0b 12 	call	0x2416	; 0x2416 <prvReadBytesFromBuffer>
    2520:	f6 01       	movw	r30, r12
    2522:	91 83       	std	Z+1, r25	; 0x01
    2524:	80 83       	st	Z, r24
    }

    return xCount;
}
    2526:	c8 01       	movw	r24, r16
    2528:	0f 90       	pop	r0
    252a:	0f 90       	pop	r0
    252c:	cf 91       	pop	r28
    252e:	df 91       	pop	r29
    2530:	1f 91       	pop	r17
    2532:	0f 91       	pop	r16
    2534:	ff 90       	pop	r15
    2536:	ef 90       	pop	r14
    2538:	df 90       	pop	r13
    253a:	cf 90       	pop	r12
    253c:	bf 90       	pop	r11
    253e:	af 90       	pop	r10
    2540:	08 95       	ret

00002542 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    2542:	af 92       	push	r10
    2544:	bf 92       	push	r11
    2546:	cf 92       	push	r12
    2548:	df 92       	push	r13
    254a:	ef 92       	push	r14
    254c:	ff 92       	push	r15
    254e:	0f 93       	push	r16
    2550:	cf 93       	push	r28
    2552:	df 93       	push	r29
    2554:	ec 01       	movw	r28, r24
    2556:	69 01       	movw	r12, r18
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2558:	8e 85       	ldd	r24, Y+14	; 0x0e
    255a:	80 fd       	sbrc	r24, 0
    255c:	03 c0       	rjmp	.+6      	; 0x2564 <xStreamBufferReceiveFromISR+0x22>
    255e:	a0 e0       	ldi	r26, 0x00	; 0
    2560:	b0 e0       	ldi	r27, 0x00	; 0
    2562:	02 c0       	rjmp	.+4      	; 0x2568 <xStreamBufferReceiveFromISR+0x26>
    2564:	a2 e0       	ldi	r26, 0x02	; 2
    2566:	b0 e0       	ldi	r27, 0x00	; 0
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2568:	ec 81       	ldd	r30, Y+4	; 0x04
    256a:	fd 81       	ldd	r31, Y+5	; 0x05
    256c:	2a 81       	ldd	r18, Y+2	; 0x02
    256e:	3b 81       	ldd	r19, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2570:	88 81       	ld	r24, Y
    2572:	99 81       	ldd	r25, Y+1	; 0x01
    2574:	2e 0f       	add	r18, r30
    2576:	3f 1f       	adc	r19, r31
    2578:	28 1b       	sub	r18, r24
    257a:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    257c:	2e 17       	cp	r18, r30
    257e:	3f 07       	cpc	r19, r31
    2580:	10 f0       	brcs	.+4      	; 0x2586 <xStreamBufferReceiveFromISR+0x44>
    {
        xCount -= pxStreamBuffer->xLength;
    2582:	2e 1b       	sub	r18, r30
    2584:	3f 0b       	sbc	r19, r31
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    2586:	a2 17       	cp	r26, r18
    2588:	b3 07       	cpc	r27, r19
    258a:	18 f0       	brcs	.+6      	; 0x2592 <xStreamBufferReceiveFromISR+0x50>
    258c:	aa 24       	eor	r10, r10
    258e:	bb 24       	eor	r11, r11
    2590:	18 c0       	rjmp	.+48     	; 0x25c2 <xStreamBufferReceiveFromISR+0x80>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    2592:	ce 01       	movw	r24, r28
    2594:	0e 94 58 12 	call	0x24b0	; 0x24b0 <prvReadMessageFromBuffer>
    2598:	5c 01       	movw	r10, r24

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    259a:	00 97       	sbiw	r24, 0x00	; 0
    259c:	91 f0       	breq	.+36     	; 0x25c2 <xStreamBufferReceiveFromISR+0x80>
        {
            sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    259e:	8a 85       	ldd	r24, Y+10	; 0x0a
    25a0:	9b 85       	ldd	r25, Y+11	; 0x0b
    25a2:	89 2b       	or	r24, r25
    25a4:	71 f0       	breq	.+28     	; 0x25c2 <xStreamBufferReceiveFromISR+0x80>
    25a6:	8a 85       	ldd	r24, Y+10	; 0x0a
    25a8:	9b 85       	ldd	r25, Y+11	; 0x0b
    25aa:	60 e0       	ldi	r22, 0x00	; 0
    25ac:	20 e0       	ldi	r18, 0x00	; 0
    25ae:	30 e0       	ldi	r19, 0x00	; 0
    25b0:	40 e0       	ldi	r20, 0x00	; 0
    25b2:	50 e0       	ldi	r21, 0x00	; 0
    25b4:	00 e0       	ldi	r16, 0x00	; 0
    25b6:	ee 24       	eor	r14, r14
    25b8:	ff 24       	eor	r15, r15
    25ba:	0e 94 16 19 	call	0x322c	; 0x322c <xTaskGenericNotifyFromISR>
    25be:	1b 86       	std	Y+11, r1	; 0x0b
    25c0:	1a 86       	std	Y+10, r1	; 0x0a
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
}
    25c2:	c5 01       	movw	r24, r10
    25c4:	df 91       	pop	r29
    25c6:	cf 91       	pop	r28
    25c8:	0f 91       	pop	r16
    25ca:	ff 90       	pop	r15
    25cc:	ef 90       	pop	r14
    25ce:	df 90       	pop	r13
    25d0:	cf 90       	pop	r12
    25d2:	bf 90       	pop	r11
    25d4:	af 90       	pop	r10
    25d6:	08 95       	ret

000025d8 <xStreamBufferNextMessageLengthBytes>:
    return xReceivedLength;
}
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    25d8:	df 93       	push	r29
    25da:	cf 93       	push	r28
    25dc:	00 d0       	rcall	.+0      	; 0x25de <xStreamBufferNextMessageLengthBytes+0x6>
    25de:	cd b7       	in	r28, 0x3d	; 61
    25e0:	de b7       	in	r29, 0x3e	; 62
    25e2:	fc 01       	movw	r30, r24
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    25e4:	86 85       	ldd	r24, Z+14	; 0x0e
    25e6:	80 ff       	sbrs	r24, 0
    25e8:	1f c0       	rjmp	.+62     	; 0x2628 <xStreamBufferNextMessageLengthBytes+0x50>
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    25ea:	44 81       	ldd	r20, Z+4	; 0x04
    25ec:	55 81       	ldd	r21, Z+5	; 0x05
    25ee:	22 81       	ldd	r18, Z+2	; 0x02
    25f0:	33 81       	ldd	r19, Z+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    25f2:	80 81       	ld	r24, Z
    25f4:	91 81       	ldd	r25, Z+1	; 0x01
    25f6:	24 0f       	add	r18, r20
    25f8:	35 1f       	adc	r19, r21
    25fa:	28 1b       	sub	r18, r24
    25fc:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    25fe:	24 17       	cp	r18, r20
    2600:	35 07       	cpc	r19, r21
    2602:	10 f0       	brcs	.+4      	; 0x2608 <xStreamBufferNextMessageLengthBytes+0x30>
    {
        xCount -= pxStreamBuffer->xLength;
    2604:	24 1b       	sub	r18, r20
    2606:	35 0b       	sbc	r19, r21
    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    2608:	23 30       	cpi	r18, 0x03	; 3
    260a:	31 05       	cpc	r19, r1
    260c:	68 f0       	brcs	.+26     	; 0x2628 <xStreamBufferNextMessageLengthBytes+0x50>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    260e:	20 81       	ld	r18, Z
    2610:	31 81       	ldd	r19, Z+1	; 0x01
    2612:	cf 01       	movw	r24, r30
    2614:	be 01       	movw	r22, r28
    2616:	6f 5f       	subi	r22, 0xFF	; 255
    2618:	7f 4f       	sbci	r23, 0xFF	; 255
    261a:	42 e0       	ldi	r20, 0x02	; 2
    261c:	50 e0       	ldi	r21, 0x00	; 0
    261e:	0e 94 0b 12 	call	0x2416	; 0x2416 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    2622:	29 81       	ldd	r18, Y+1	; 0x01
    2624:	3a 81       	ldd	r19, Y+2	; 0x02
    2626:	02 c0       	rjmp	.+4      	; 0x262c <xStreamBufferNextMessageLengthBytes+0x54>
    2628:	20 e0       	ldi	r18, 0x00	; 0
    262a:	30 e0       	ldi	r19, 0x00	; 0
    {
        xReturn = 0;
    }

    return xReturn;
}
    262c:	c9 01       	movw	r24, r18
    262e:	0f 90       	pop	r0
    2630:	0f 90       	pop	r0
    2632:	cf 91       	pop	r28
    2634:	df 91       	pop	r29
    2636:	08 95       	ret

00002638 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    2638:	af 92       	push	r10
    263a:	bf 92       	push	r11
    263c:	cf 92       	push	r12
    263e:	df 92       	push	r13
    2640:	ef 92       	push	r14
    2642:	ff 92       	push	r15
    2644:	0f 93       	push	r16
    2646:	1f 93       	push	r17
    2648:	cf 93       	push	r28
    264a:	df 93       	push	r29
    264c:	7c 01       	movw	r14, r24
    264e:	6b 01       	movw	r12, r22
    2650:	8a 01       	movw	r16, r20
    2652:	59 01       	movw	r10, r18
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    2654:	dc 01       	movw	r26, r24
    2656:	14 96       	adiw	r26, 0x04	; 4
    2658:	cd 91       	ld	r28, X+
    265a:	dc 91       	ld	r29, X
    265c:	15 97       	sbiw	r26, 0x05	; 5
    265e:	c2 1b       	sub	r28, r18
    2660:	d3 0b       	sbc	r29, r19
    2662:	4c 17       	cp	r20, r28
    2664:	5d 07       	cpc	r21, r29
    2666:	08 f4       	brcc	.+2      	; 0x266a <prvWriteBytesToBuffer+0x32>
    2668:	ea 01       	movw	r28, r20

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    266a:	f7 01       	movw	r30, r14
    266c:	24 85       	ldd	r18, Z+12	; 0x0c
    266e:	35 85       	ldd	r19, Z+13	; 0x0d
    2670:	2a 0d       	add	r18, r10
    2672:	3b 1d       	adc	r19, r11
    2674:	c9 01       	movw	r24, r18
    2676:	b6 01       	movw	r22, r12
    2678:	ae 01       	movw	r20, r28
    267a:	0e 94 17 24 	call	0x482e	; 0x482e <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    267e:	c0 17       	cp	r28, r16
    2680:	d1 07       	cpc	r29, r17
    2682:	80 f4       	brcc	.+32     	; 0x26a4 <prvWriteBytesToBuffer+0x6c>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2684:	f8 01       	movw	r30, r16
    2686:	ec 1b       	sub	r30, r28
    2688:	fd 0b       	sbc	r31, r29
    268a:	96 01       	movw	r18, r12
    268c:	2c 0f       	add	r18, r28
    268e:	3d 1f       	adc	r19, r29
    2690:	d7 01       	movw	r26, r14
    2692:	1c 96       	adiw	r26, 0x0c	; 12
    2694:	8c 91       	ld	r24, X
    2696:	1c 97       	sbiw	r26, 0x0c	; 12
    2698:	1d 96       	adiw	r26, 0x0d	; 13
    269a:	9c 91       	ld	r25, X
    269c:	b9 01       	movw	r22, r18
    269e:	af 01       	movw	r20, r30
    26a0:	0e 94 17 24 	call	0x482e	; 0x482e <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    26a4:	95 01       	movw	r18, r10
    26a6:	20 0f       	add	r18, r16
    26a8:	31 1f       	adc	r19, r17

    if( xHead >= pxStreamBuffer->xLength )
    26aa:	f7 01       	movw	r30, r14
    26ac:	84 81       	ldd	r24, Z+4	; 0x04
    26ae:	95 81       	ldd	r25, Z+5	; 0x05
    26b0:	28 17       	cp	r18, r24
    26b2:	39 07       	cpc	r19, r25
    26b4:	10 f0       	brcs	.+4      	; 0x26ba <prvWriteBytesToBuffer+0x82>
    {
        xHead -= pxStreamBuffer->xLength;
    26b6:	28 1b       	sub	r18, r24
    26b8:	39 0b       	sbc	r19, r25
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
}
    26ba:	c9 01       	movw	r24, r18
    26bc:	df 91       	pop	r29
    26be:	cf 91       	pop	r28
    26c0:	1f 91       	pop	r17
    26c2:	0f 91       	pop	r16
    26c4:	ff 90       	pop	r15
    26c6:	ef 90       	pop	r14
    26c8:	df 90       	pop	r13
    26ca:	cf 90       	pop	r12
    26cc:	bf 90       	pop	r11
    26ce:	af 90       	pop	r10
    26d0:	08 95       	ret

000026d2 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    26d2:	cf 92       	push	r12
    26d4:	df 92       	push	r13
    26d6:	ef 92       	push	r14
    26d8:	ff 92       	push	r15
    26da:	0f 93       	push	r16
    26dc:	1f 93       	push	r17
    26de:	df 93       	push	r29
    26e0:	cf 93       	push	r28
    26e2:	00 d0       	rcall	.+0      	; 0x26e4 <prvWriteMessageToBuffer+0x12>
    26e4:	cd b7       	in	r28, 0x3d	; 61
    26e6:	de b7       	in	r29, 0x3e	; 62
    26e8:	7c 01       	movw	r14, r24
    26ea:	6b 01       	movw	r12, r22
    26ec:	5a 83       	std	Y+2, r21	; 0x02
    26ee:	49 83       	std	Y+1, r20	; 0x01
    size_t xNextHead = pxStreamBuffer->xHead;
    26f0:	dc 01       	movw	r26, r24
    26f2:	12 96       	adiw	r26, 0x02	; 2
    26f4:	ed 91       	ld	r30, X+
    26f6:	fc 91       	ld	r31, X
    26f8:	13 97       	sbiw	r26, 0x03	; 3

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    26fa:	1e 96       	adiw	r26, 0x0e	; 14
    26fc:	8c 91       	ld	r24, X
    26fe:	80 ff       	sbrs	r24, 0
    2700:	11 c0       	rjmp	.+34     	; 0x2724 <prvWriteMessageToBuffer+0x52>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        if( xSpace >= xRequiredSpace )
    2702:	20 17       	cp	r18, r16
    2704:	31 07       	cpc	r19, r17
    2706:	58 f0       	brcs	.+22     	; 0x271e <prvWriteMessageToBuffer+0x4c>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    2708:	c7 01       	movw	r24, r14
    270a:	be 01       	movw	r22, r28
    270c:	6f 5f       	subi	r22, 0xFF	; 255
    270e:	7f 4f       	sbci	r23, 0xFF	; 255
    2710:	42 e0       	ldi	r20, 0x02	; 2
    2712:	50 e0       	ldi	r21, 0x00	; 0
    2714:	9f 01       	movw	r18, r30
    2716:	0e 94 1c 13 	call	0x2638	; 0x2638 <prvWriteBytesToBuffer>
    271a:	fc 01       	movw	r30, r24
    271c:	0b c0       	rjmp	.+22     	; 0x2734 <prvWriteMessageToBuffer+0x62>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
    271e:	1a 82       	std	Y+2, r1	; 0x02
    2720:	19 82       	std	Y+1, r1	; 0x01
    2722:	08 c0       	rjmp	.+16     	; 0x2734 <prvWriteMessageToBuffer+0x62>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    2724:	89 81       	ldd	r24, Y+1	; 0x01
    2726:	9a 81       	ldd	r25, Y+2	; 0x02
    2728:	82 17       	cp	r24, r18
    272a:	93 07       	cpc	r25, r19
    272c:	08 f4       	brcc	.+2      	; 0x2730 <prvWriteMessageToBuffer+0x5e>
    272e:	9c 01       	movw	r18, r24
    2730:	3a 83       	std	Y+2, r19	; 0x02
    2732:	29 83       	std	Y+1, r18	; 0x01
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    2734:	49 81       	ldd	r20, Y+1	; 0x01
    2736:	5a 81       	ldd	r21, Y+2	; 0x02
    2738:	41 15       	cp	r20, r1
    273a:	51 05       	cpc	r21, r1
    273c:	41 f0       	breq	.+16     	; 0x274e <prvWriteMessageToBuffer+0x7c>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    273e:	c7 01       	movw	r24, r14
    2740:	b6 01       	movw	r22, r12
    2742:	9f 01       	movw	r18, r30
    2744:	0e 94 1c 13 	call	0x2638	; 0x2638 <prvWriteBytesToBuffer>
    2748:	f7 01       	movw	r30, r14
    274a:	93 83       	std	Z+3, r25	; 0x03
    274c:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
}
    274e:	89 81       	ldd	r24, Y+1	; 0x01
    2750:	9a 81       	ldd	r25, Y+2	; 0x02
    2752:	0f 90       	pop	r0
    2754:	0f 90       	pop	r0
    2756:	cf 91       	pop	r28
    2758:	df 91       	pop	r29
    275a:	1f 91       	pop	r17
    275c:	0f 91       	pop	r16
    275e:	ff 90       	pop	r15
    2760:	ef 90       	pop	r14
    2762:	df 90       	pop	r13
    2764:	cf 90       	pop	r12
    2766:	08 95       	ret

00002768 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2768:	af 92       	push	r10
    276a:	bf 92       	push	r11
    276c:	cf 92       	push	r12
    276e:	df 92       	push	r13
    2770:	ef 92       	push	r14
    2772:	ff 92       	push	r15
    2774:	0f 93       	push	r16
    2776:	1f 93       	push	r17
    2778:	cf 93       	push	r28
    277a:	df 93       	push	r29
    277c:	ec 01       	movw	r28, r24
    277e:	5b 01       	movw	r10, r22
    2780:	8a 01       	movw	r16, r20
    2782:	69 01       	movw	r12, r18

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2784:	8e 85       	ldd	r24, Y+14	; 0x0e
    2786:	80 fd       	sbrc	r24, 0
    2788:	02 c0       	rjmp	.+4      	; 0x278e <xStreamBufferSendFromISR+0x26>
    278a:	7a 01       	movw	r14, r20
    278c:	05 c0       	rjmp	.+10     	; 0x2798 <xStreamBufferSendFromISR+0x30>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    278e:	82 e0       	ldi	r24, 0x02	; 2
    2790:	e8 2e       	mov	r14, r24
    2792:	f1 2c       	mov	r15, r1
    2794:	e4 0e       	add	r14, r20
    2796:	f5 1e       	adc	r15, r21
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2798:	ce 01       	movw	r24, r28
    279a:	0e 94 6e 11 	call	0x22dc	; 0x22dc <xStreamBufferSpacesAvailable>
    279e:	9c 01       	movw	r18, r24
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    27a0:	ce 01       	movw	r24, r28
    27a2:	b5 01       	movw	r22, r10
    27a4:	a8 01       	movw	r20, r16
    27a6:	87 01       	movw	r16, r14
    27a8:	0e 94 69 13 	call	0x26d2	; 0x26d2 <prvWriteMessageToBuffer>
    27ac:	5c 01       	movw	r10, r24

    if( xReturn > ( size_t ) 0 )
    27ae:	00 97       	sbiw	r24, 0x00	; 0
    27b0:	31 f1       	breq	.+76     	; 0x27fe <xStreamBufferSendFromISR+0x96>
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    27b2:	4c 81       	ldd	r20, Y+4	; 0x04
    27b4:	5d 81       	ldd	r21, Y+5	; 0x05
    27b6:	2a 81       	ldd	r18, Y+2	; 0x02
    27b8:	3b 81       	ldd	r19, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    27ba:	88 81       	ld	r24, Y
    27bc:	99 81       	ldd	r25, Y+1	; 0x01
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    27be:	24 0f       	add	r18, r20
    27c0:	35 1f       	adc	r19, r21
    xCount -= pxStreamBuffer->xTail;
    27c2:	28 1b       	sub	r18, r24
    27c4:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    27c6:	24 17       	cp	r18, r20
    27c8:	35 07       	cpc	r19, r21
    27ca:	10 f0       	brcs	.+4      	; 0x27d0 <xStreamBufferSendFromISR+0x68>
    {
        xCount -= pxStreamBuffer->xLength;
    27cc:	24 1b       	sub	r18, r20
    27ce:	35 0b       	sbc	r19, r21
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );

    if( xReturn > ( size_t ) 0 )
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    27d0:	8e 81       	ldd	r24, Y+6	; 0x06
    27d2:	9f 81       	ldd	r25, Y+7	; 0x07
    27d4:	28 17       	cp	r18, r24
    27d6:	39 07       	cpc	r19, r25
    27d8:	90 f0       	brcs	.+36     	; 0x27fe <xStreamBufferSendFromISR+0x96>
        {
            sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    27da:	88 85       	ldd	r24, Y+8	; 0x08
    27dc:	99 85       	ldd	r25, Y+9	; 0x09
    27de:	89 2b       	or	r24, r25
    27e0:	71 f0       	breq	.+28     	; 0x27fe <xStreamBufferSendFromISR+0x96>
    27e2:	88 85       	ldd	r24, Y+8	; 0x08
    27e4:	99 85       	ldd	r25, Y+9	; 0x09
    27e6:	60 e0       	ldi	r22, 0x00	; 0
    27e8:	20 e0       	ldi	r18, 0x00	; 0
    27ea:	30 e0       	ldi	r19, 0x00	; 0
    27ec:	40 e0       	ldi	r20, 0x00	; 0
    27ee:	50 e0       	ldi	r21, 0x00	; 0
    27f0:	00 e0       	ldi	r16, 0x00	; 0
    27f2:	ee 24       	eor	r14, r14
    27f4:	ff 24       	eor	r15, r15
    27f6:	0e 94 16 19 	call	0x322c	; 0x322c <xTaskGenericNotifyFromISR>
    27fa:	19 86       	std	Y+9, r1	; 0x09
    27fc:	18 86       	std	Y+8, r1	; 0x08
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
}
    27fe:	c5 01       	movw	r24, r10
    2800:	df 91       	pop	r29
    2802:	cf 91       	pop	r28
    2804:	1f 91       	pop	r17
    2806:	0f 91       	pop	r16
    2808:	ff 90       	pop	r15
    280a:	ef 90       	pop	r14
    280c:	df 90       	pop	r13
    280e:	cf 90       	pop	r12
    2810:	bf 90       	pop	r11
    2812:	af 90       	pop	r10
    2814:	08 95       	ret

00002816 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    2816:	6f 92       	push	r6
    2818:	7f 92       	push	r7
    281a:	8f 92       	push	r8
    281c:	9f 92       	push	r9
    281e:	af 92       	push	r10
    2820:	bf 92       	push	r11
    2822:	cf 92       	push	r12
    2824:	df 92       	push	r13
    2826:	ef 92       	push	r14
    2828:	ff 92       	push	r15
    282a:	0f 93       	push	r16
    282c:	1f 93       	push	r17
    282e:	cf 93       	push	r28
    2830:	df 93       	push	r29
    2832:	ec 01       	movw	r28, r24
    2834:	4b 01       	movw	r8, r22
    2836:	3a 01       	movw	r6, r20
    2838:	69 01       	movw	r12, r18
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    283a:	8e 85       	ldd	r24, Y+14	; 0x0e
    283c:	80 fd       	sbrc	r24, 0
    283e:	03 c0       	rjmp	.+6      	; 0x2846 <xStreamBufferReceive+0x30>
    2840:	aa 24       	eor	r10, r10
    2842:	bb 24       	eor	r11, r11
    2844:	03 c0       	rjmp	.+6      	; 0x284c <xStreamBufferReceive+0x36>
    2846:	92 e0       	ldi	r25, 0x02	; 2
    2848:	a9 2e       	mov	r10, r25
    284a:	b1 2c       	mov	r11, r1
    284c:	2c 81       	ldd	r18, Y+4	; 0x04
    284e:	3d 81       	ldd	r19, Y+5	; 0x05
    else
    {
        xBytesToStoreMessageLength = 0;
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    2850:	c1 14       	cp	r12, r1
    2852:	d1 04       	cpc	r13, r1
    2854:	91 f1       	breq	.+100    	; 0x28ba <xStreamBufferReceive+0xa4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    2856:	0f b6       	in	r0, 0x3f	; 63
    2858:	f8 94       	cli
    285a:	0f 92       	push	r0
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    285c:	0a 81       	ldd	r16, Y+2	; 0x02
    285e:	1b 81       	ldd	r17, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2860:	88 81       	ld	r24, Y
    2862:	99 81       	ldd	r25, Y+1	; 0x01
    2864:	02 0f       	add	r16, r18
    2866:	13 1f       	adc	r17, r19
    2868:	08 1b       	sub	r16, r24
    286a:	19 0b       	sbc	r17, r25

    if( xCount >= pxStreamBuffer->xLength )
    286c:	02 17       	cp	r16, r18
    286e:	13 07       	cpc	r17, r19
    2870:	10 f0       	brcs	.+4      	; 0x2876 <xStreamBufferReceive+0x60>
    {
        xCount -= pxStreamBuffer->xLength;
    2872:	02 1b       	sub	r16, r18
    2874:	13 0b       	sbc	r17, r19
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    2876:	a0 16       	cp	r10, r16
    2878:	b1 06       	cpc	r11, r17
    287a:	48 f0       	brcs	.+18     	; 0x288e <xStreamBufferReceive+0x78>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    287c:	80 e0       	ldi	r24, 0x00	; 0
    287e:	90 e0       	ldi	r25, 0x00	; 0
    2880:	60 e0       	ldi	r22, 0x00	; 0
    2882:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    2886:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <xTaskGetCurrentTaskHandle>
    288a:	99 87       	std	Y+9, r25	; 0x09
    288c:	88 87       	std	Y+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    288e:	0f 90       	pop	r0
    2890:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    2892:	a0 16       	cp	r10, r16
    2894:	b1 06       	cpc	r11, r17
    2896:	20 f1       	brcs	.+72     	; 0x28e0 <xStreamBufferReceive+0xca>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2898:	80 e0       	ldi	r24, 0x00	; 0
    289a:	40 e0       	ldi	r20, 0x00	; 0
    289c:	50 e0       	ldi	r21, 0x00	; 0
    289e:	60 e0       	ldi	r22, 0x00	; 0
    28a0:	70 e0       	ldi	r23, 0x00	; 0
    28a2:	00 e0       	ldi	r16, 0x00	; 0
    28a4:	10 e0       	ldi	r17, 0x00	; 0
    28a6:	20 e0       	ldi	r18, 0x00	; 0
    28a8:	30 e0       	ldi	r19, 0x00	; 0
    28aa:	ee 24       	eor	r14, r14
    28ac:	ff 24       	eor	r15, r15
    28ae:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    28b2:	19 86       	std	Y+9, r1	; 0x09
    28b4:	18 86       	std	Y+8, r1	; 0x08
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    28b6:	2c 81       	ldd	r18, Y+4	; 0x04
    28b8:	3d 81       	ldd	r19, Y+5	; 0x05
    28ba:	0a 81       	ldd	r16, Y+2	; 0x02
    28bc:	1b 81       	ldd	r17, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    28be:	88 81       	ld	r24, Y
    28c0:	99 81       	ldd	r25, Y+1	; 0x01
    28c2:	02 0f       	add	r16, r18
    28c4:	13 1f       	adc	r17, r19
    28c6:	08 1b       	sub	r16, r24
    28c8:	19 0b       	sbc	r17, r25

    if( xCount >= pxStreamBuffer->xLength )
    28ca:	02 17       	cp	r16, r18
    28cc:	13 07       	cpc	r17, r19
    28ce:	10 f0       	brcs	.+4      	; 0x28d4 <xStreamBufferReceive+0xbe>
    {
        xCount -= pxStreamBuffer->xLength;
    28d0:	02 1b       	sub	r16, r18
    28d2:	13 0b       	sbc	r17, r19
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    28d4:	a0 16       	cp	r10, r16
    28d6:	b1 06       	cpc	r11, r17
    28d8:	18 f0       	brcs	.+6      	; 0x28e0 <xStreamBufferReceive+0xca>
    28da:	cc 24       	eor	r12, r12
    28dc:	dd 24       	eor	r13, r13
    28de:	1f c0       	rjmp	.+62     	; 0x291e <xStreamBufferReceive+0x108>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    28e0:	ce 01       	movw	r24, r28
    28e2:	b4 01       	movw	r22, r8
    28e4:	a3 01       	movw	r20, r6
    28e6:	98 01       	movw	r18, r16
    28e8:	0e 94 58 12 	call	0x24b0	; 0x24b0 <prvReadMessageFromBuffer>
    28ec:	6c 01       	movw	r12, r24

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    28ee:	00 97       	sbiw	r24, 0x00	; 0
    28f0:	b1 f0       	breq	.+44     	; 0x291e <xStreamBufferReceive+0x108>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            sbRECEIVE_COMPLETED( pxStreamBuffer );
    28f2:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <vTaskSuspendAll>
    28f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    28f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    28fa:	89 2b       	or	r24, r25
    28fc:	71 f0       	breq	.+28     	; 0x291a <xStreamBufferReceive+0x104>
    28fe:	8a 85       	ldd	r24, Y+10	; 0x0a
    2900:	9b 85       	ldd	r25, Y+11	; 0x0b
    2902:	60 e0       	ldi	r22, 0x00	; 0
    2904:	20 e0       	ldi	r18, 0x00	; 0
    2906:	30 e0       	ldi	r19, 0x00	; 0
    2908:	40 e0       	ldi	r20, 0x00	; 0
    290a:	50 e0       	ldi	r21, 0x00	; 0
    290c:	00 e0       	ldi	r16, 0x00	; 0
    290e:	ee 24       	eor	r14, r14
    2910:	ff 24       	eor	r15, r15
    2912:	0e 94 0e 1b 	call	0x361c	; 0x361c <xTaskGenericNotify>
    2916:	1b 86       	std	Y+11, r1	; 0x0b
    2918:	1a 86       	std	Y+10, r1	; 0x0a
    291a:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
}
    291e:	c6 01       	movw	r24, r12
    2920:	df 91       	pop	r29
    2922:	cf 91       	pop	r28
    2924:	1f 91       	pop	r17
    2926:	0f 91       	pop	r16
    2928:	ff 90       	pop	r15
    292a:	ef 90       	pop	r14
    292c:	df 90       	pop	r13
    292e:	cf 90       	pop	r12
    2930:	bf 90       	pop	r11
    2932:	af 90       	pop	r10
    2934:	9f 90       	pop	r9
    2936:	8f 90       	pop	r8
    2938:	7f 90       	pop	r7
    293a:	6f 90       	pop	r6
    293c:	08 95       	ret

0000293e <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    293e:	2f 92       	push	r2
    2940:	3f 92       	push	r3
    2942:	4f 92       	push	r4
    2944:	5f 92       	push	r5
    2946:	6f 92       	push	r6
    2948:	7f 92       	push	r7
    294a:	8f 92       	push	r8
    294c:	9f 92       	push	r9
    294e:	af 92       	push	r10
    2950:	bf 92       	push	r11
    2952:	cf 92       	push	r12
    2954:	df 92       	push	r13
    2956:	ef 92       	push	r14
    2958:	ff 92       	push	r15
    295a:	0f 93       	push	r16
    295c:	1f 93       	push	r17
    295e:	df 93       	push	r29
    2960:	cf 93       	push	r28
    2962:	cd b7       	in	r28, 0x3d	; 61
    2964:	de b7       	in	r29, 0x3e	; 62
    2966:	27 97       	sbiw	r28, 0x07	; 7
    2968:	0f b6       	in	r0, 0x3f	; 63
    296a:	f8 94       	cli
    296c:	de bf       	out	0x3e, r29	; 62
    296e:	0f be       	out	0x3f, r0	; 63
    2970:	cd bf       	out	0x3d, r28	; 61
    2972:	5c 01       	movw	r10, r24
    2974:	7f 83       	std	Y+7, r23	; 0x07
    2976:	6e 83       	std	Y+6, r22	; 0x06
    2978:	2a 01       	movw	r4, r20
    297a:	3d 83       	std	Y+5, r19	; 0x05
    297c:	2c 83       	std	Y+4, r18	; 0x04
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    297e:	fc 01       	movw	r30, r24
    2980:	24 81       	ldd	r18, Z+4	; 0x04
    2982:	35 81       	ldd	r19, Z+5	; 0x05
    2984:	21 50       	subi	r18, 0x01	; 1
    2986:	30 40       	sbci	r19, 0x00	; 0

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2988:	86 85       	ldd	r24, Z+14	; 0x0e
    298a:	80 ff       	sbrs	r24, 0
    298c:	0b c0       	rjmp	.+22     	; 0x29a4 <xStreamBufferSend+0x66>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    298e:	42 e0       	ldi	r20, 0x02	; 2
    2990:	64 2e       	mov	r6, r20
    2992:	71 2c       	mov	r7, r1
    2994:	64 0c       	add	r6, r4
    2996:	75 1c       	adc	r7, r5
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    2998:	26 15       	cp	r18, r6
    299a:	37 05       	cpc	r19, r7
    299c:	48 f4       	brcc	.+18     	; 0x29b0 <xStreamBufferSend+0x72>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    299e:	1d 82       	std	Y+5, r1	; 0x05
    29a0:	1c 82       	std	Y+4, r1	; 0x04
    29a2:	06 c0       	rjmp	.+12     	; 0x29b0 <xStreamBufferSend+0x72>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
    29a4:	24 17       	cp	r18, r20
    29a6:	35 07       	cpc	r19, r21
    29a8:	10 f4       	brcc	.+4      	; 0x29ae <xStreamBufferSend+0x70>
    29aa:	39 01       	movw	r6, r18
    29ac:	01 c0       	rjmp	.+2      	; 0x29b0 <xStreamBufferSend+0x72>
    29ae:	3a 01       	movw	r6, r20
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    29b0:	8c 81       	ldd	r24, Y+4	; 0x04
    29b2:	9d 81       	ldd	r25, Y+5	; 0x05
    29b4:	89 2b       	or	r24, r25
    29b6:	09 f4       	brne	.+2      	; 0x29ba <xStreamBufferSend+0x7c>
    29b8:	3d c0       	rjmp	.+122    	; 0x2a34 <xStreamBufferSend+0xf6>
    {
        vTaskSetTimeOutState( &xTimeOut );
    29ba:	8e 01       	movw	r16, r28
    29bc:	0f 5f       	subi	r16, 0xFF	; 255
    29be:	1f 4f       	sbci	r17, 0xFF	; 255
    29c0:	c8 01       	movw	r24, r16
    29c2:	0e 94 a4 18 	call	0x3148	; 0x3148 <vTaskSetTimeOutState>
            taskEXIT_CRITICAL();

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
            pxStreamBuffer->xTaskWaitingToSend = NULL;
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    29c6:	18 01       	movw	r2, r16

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    29c8:	0f b6       	in	r0, 0x3f	; 63
    29ca:	f8 94       	cli
    29cc:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    29ce:	c5 01       	movw	r24, r10
    29d0:	0e 94 6e 11 	call	0x22dc	; 0x22dc <xStreamBufferSpacesAvailable>
    29d4:	4c 01       	movw	r8, r24

                if( xSpace < xRequiredSpace )
    29d6:	86 15       	cp	r24, r6
    29d8:	97 05       	cpc	r25, r7
    29da:	38 f5       	brcc	.+78     	; 0x2a2a <xStreamBufferSend+0xec>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    29dc:	80 e0       	ldi	r24, 0x00	; 0
    29de:	90 e0       	ldi	r25, 0x00	; 0
    29e0:	60 e0       	ldi	r22, 0x00	; 0
    29e2:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    29e6:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <xTaskGetCurrentTaskHandle>
    29ea:	f5 01       	movw	r30, r10
    29ec:	93 87       	std	Z+11, r25	; 0x0b
    29ee:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    29f0:	0f 90       	pop	r0
    29f2:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    29f4:	cc 80       	ldd	r12, Y+4	; 0x04
    29f6:	dd 80       	ldd	r13, Y+5	; 0x05
    29f8:	80 e0       	ldi	r24, 0x00	; 0
    29fa:	40 e0       	ldi	r20, 0x00	; 0
    29fc:	50 e0       	ldi	r21, 0x00	; 0
    29fe:	60 e0       	ldi	r22, 0x00	; 0
    2a00:	70 e0       	ldi	r23, 0x00	; 0
    2a02:	00 e0       	ldi	r16, 0x00	; 0
    2a04:	10 e0       	ldi	r17, 0x00	; 0
    2a06:	20 e0       	ldi	r18, 0x00	; 0
    2a08:	30 e0       	ldi	r19, 0x00	; 0
    2a0a:	ee 24       	eor	r14, r14
    2a0c:	ff 24       	eor	r15, r15
    2a0e:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    2a12:	f5 01       	movw	r30, r10
    2a14:	13 86       	std	Z+11, r1	; 0x0b
    2a16:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2a18:	c1 01       	movw	r24, r2
    2a1a:	be 01       	movw	r22, r28
    2a1c:	6c 5f       	subi	r22, 0xFC	; 252
    2a1e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a20:	0e 94 bf 18 	call	0x317e	; 0x317e <xTaskCheckForTimeOut>
    2a24:	88 23       	and	r24, r24
    2a26:	81 f2       	breq	.-96     	; 0x29c8 <xStreamBufferSend+0x8a>
    2a28:	02 c0       	rjmp	.+4      	; 0x2a2e <xStreamBufferSend+0xf0>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    2a2a:	0f 90       	pop	r0
    2a2c:	0f be       	out	0x3f, r0	; 63
    2a2e:	94 01       	movw	r18, r8
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    2a30:	89 28       	or	r8, r9
    2a32:	21 f4       	brne	.+8      	; 0x2a3c <xStreamBufferSend+0xfe>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2a34:	c5 01       	movw	r24, r10
    2a36:	0e 94 6e 11 	call	0x22dc	; 0x22dc <xStreamBufferSpacesAvailable>
    2a3a:	9c 01       	movw	r18, r24
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2a3c:	c5 01       	movw	r24, r10
    2a3e:	6e 81       	ldd	r22, Y+6	; 0x06
    2a40:	7f 81       	ldd	r23, Y+7	; 0x07
    2a42:	a2 01       	movw	r20, r4
    2a44:	83 01       	movw	r16, r6
    2a46:	0e 94 69 13 	call	0x26d2	; 0x26d2 <prvWriteMessageToBuffer>
    2a4a:	6c 01       	movw	r12, r24

    if( xReturn > ( size_t ) 0 )
    2a4c:	00 97       	sbiw	r24, 0x00	; 0
    2a4e:	71 f1       	breq	.+92     	; 0x2aac <xStreamBufferSend+0x16e>
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2a50:	f5 01       	movw	r30, r10
    2a52:	44 81       	ldd	r20, Z+4	; 0x04
    2a54:	55 81       	ldd	r21, Z+5	; 0x05
    2a56:	22 81       	ldd	r18, Z+2	; 0x02
    2a58:	33 81       	ldd	r19, Z+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2a5a:	80 81       	ld	r24, Z
    2a5c:	91 81       	ldd	r25, Z+1	; 0x01
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2a5e:	24 0f       	add	r18, r20
    2a60:	35 1f       	adc	r19, r21
    xCount -= pxStreamBuffer->xTail;
    2a62:	28 1b       	sub	r18, r24
    2a64:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    2a66:	24 17       	cp	r18, r20
    2a68:	35 07       	cpc	r19, r21
    2a6a:	10 f0       	brcs	.+4      	; 0x2a70 <xStreamBufferSend+0x132>
    {
        xCount -= pxStreamBuffer->xLength;
    2a6c:	24 1b       	sub	r18, r20
    2a6e:	35 0b       	sbc	r19, r21
    if( xReturn > ( size_t ) 0 )
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2a70:	f5 01       	movw	r30, r10
    2a72:	86 81       	ldd	r24, Z+6	; 0x06
    2a74:	97 81       	ldd	r25, Z+7	; 0x07
    2a76:	28 17       	cp	r18, r24
    2a78:	39 07       	cpc	r19, r25
    2a7a:	c0 f0       	brcs	.+48     	; 0x2aac <xStreamBufferSend+0x16e>
        {
            sbSEND_COMPLETED( pxStreamBuffer );
    2a7c:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <vTaskSuspendAll>
    2a80:	f5 01       	movw	r30, r10
    2a82:	80 85       	ldd	r24, Z+8	; 0x08
    2a84:	91 85       	ldd	r25, Z+9	; 0x09
    2a86:	89 2b       	or	r24, r25
    2a88:	79 f0       	breq	.+30     	; 0x2aa8 <xStreamBufferSend+0x16a>
    2a8a:	80 85       	ldd	r24, Z+8	; 0x08
    2a8c:	91 85       	ldd	r25, Z+9	; 0x09
    2a8e:	60 e0       	ldi	r22, 0x00	; 0
    2a90:	20 e0       	ldi	r18, 0x00	; 0
    2a92:	30 e0       	ldi	r19, 0x00	; 0
    2a94:	40 e0       	ldi	r20, 0x00	; 0
    2a96:	50 e0       	ldi	r21, 0x00	; 0
    2a98:	00 e0       	ldi	r16, 0x00	; 0
    2a9a:	ee 24       	eor	r14, r14
    2a9c:	ff 24       	eor	r15, r15
    2a9e:	0e 94 0e 1b 	call	0x361c	; 0x361c <xTaskGenericNotify>
    2aa2:	f5 01       	movw	r30, r10
    2aa4:	11 86       	std	Z+9, r1	; 0x09
    2aa6:	10 86       	std	Z+8, r1	; 0x08
    2aa8:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
}
    2aac:	c6 01       	movw	r24, r12
    2aae:	27 96       	adiw	r28, 0x07	; 7
    2ab0:	0f b6       	in	r0, 0x3f	; 63
    2ab2:	f8 94       	cli
    2ab4:	de bf       	out	0x3e, r29	; 62
    2ab6:	0f be       	out	0x3f, r0	; 63
    2ab8:	cd bf       	out	0x3d, r28	; 61
    2aba:	cf 91       	pop	r28
    2abc:	df 91       	pop	r29
    2abe:	1f 91       	pop	r17
    2ac0:	0f 91       	pop	r16
    2ac2:	ff 90       	pop	r15
    2ac4:	ef 90       	pop	r14
    2ac6:	df 90       	pop	r13
    2ac8:	cf 90       	pop	r12
    2aca:	bf 90       	pop	r11
    2acc:	af 90       	pop	r10
    2ace:	9f 90       	pop	r9
    2ad0:	8f 90       	pop	r8
    2ad2:	7f 90       	pop	r7
    2ad4:	6f 90       	pop	r6
    2ad6:	5f 90       	pop	r5
    2ad8:	4f 90       	pop	r4
    2ada:	3f 90       	pop	r3
    2adc:	2f 90       	pop	r2
    2ade:	08 95       	ret

00002ae0 <xStreamBufferReset>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2ae0:	fc 01       	movw	r30, r24
            uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
        }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    2ae2:	0f b6       	in	r0, 0x3f	; 63
    2ae4:	f8 94       	cli
    2ae6:	0f 92       	push	r0
    {
        if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    2ae8:	80 85       	ldd	r24, Z+8	; 0x08
    2aea:	91 85       	ldd	r25, Z+9	; 0x09
    2aec:	89 2b       	or	r24, r25
    2aee:	c9 f4       	brne	.+50     	; 0x2b22 <xStreamBufferReset+0x42>
        {
            if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    2af0:	82 85       	ldd	r24, Z+10	; 0x0a
    2af2:	93 85       	ldd	r25, Z+11	; 0x0b
    2af4:	89 2b       	or	r24, r25
    2af6:	a9 f4       	brne	.+42     	; 0x2b22 <xStreamBufferReset+0x42>
            {
                prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2af8:	24 85       	ldd	r18, Z+12	; 0x0c
    2afa:	35 85       	ldd	r19, Z+13	; 0x0d
    2afc:	44 81       	ldd	r20, Z+4	; 0x04
    2afe:	55 81       	ldd	r21, Z+5	; 0x05
    2b00:	66 81       	ldd	r22, Z+6	; 0x06
    2b02:	77 81       	ldd	r23, Z+7	; 0x07
    2b04:	96 85       	ldd	r25, Z+14	; 0x0e
            const BaseType_t xWriteValue = 0x55;
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
        } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    2b06:	8f e0       	ldi	r24, 0x0F	; 15
    2b08:	df 01       	movw	r26, r30
    2b0a:	1d 92       	st	X+, r1
    2b0c:	8a 95       	dec	r24
    2b0e:	e9 f7       	brne	.-6      	; 0x2b0a <xStreamBufferReset+0x2a>
    pxStreamBuffer->pucBuffer = pucBuffer;
    2b10:	35 87       	std	Z+13, r19	; 0x0d
    2b12:	24 87       	std	Z+12, r18	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    2b14:	55 83       	std	Z+5, r21	; 0x05
    2b16:	44 83       	std	Z+4, r20	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    2b18:	77 83       	std	Z+7, r23	; 0x07
    2b1a:	66 83       	std	Z+6, r22	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    2b1c:	96 87       	std	Z+14, r25	; 0x0e
    2b1e:	81 e0       	ldi	r24, 0x01	; 1
    2b20:	01 c0       	rjmp	.+2      	; 0x2b24 <xStreamBufferReset+0x44>
    2b22:	80 e0       	ldi	r24, 0x00	; 0

                traceSTREAM_BUFFER_RESET( xStreamBuffer );
            }
        }
    }
    taskEXIT_CRITICAL();
    2b24:	0f 90       	pop	r0
    2b26:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    2b28:	08 95       	ret

00002b2a <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2b2a:	fc 01       	movw	r30, r24

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2b2c:	86 85       	ldd	r24, Z+14	; 0x0e
    2b2e:	81 fd       	sbrc	r24, 1
    2b30:	04 c0       	rjmp	.+8      	; 0x2b3a <vStreamBufferDelete+0x10>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
            {
                /* Both the structure and the buffer were allocated using a single call
                * to pvPortMalloc(), hence only one call to vPortFree() is required. */
                vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2b32:	cf 01       	movw	r24, r30
    2b34:	0e 94 a5 0a 	call	0x154a	; 0x154a <vPortFree>
    2b38:	08 95       	ret
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2b3a:	8f e0       	ldi	r24, 0x0F	; 15
    2b3c:	df 01       	movw	r26, r30
    2b3e:	1d 92       	st	X+, r1
    2b40:	8a 95       	dec	r24
    2b42:	e9 f7       	brne	.-6      	; 0x2b3e <vStreamBufferDelete+0x14>
    2b44:	08 95       	ret

00002b46 <xStreamBufferGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer )
    {
    2b46:	cf 92       	push	r12
    2b48:	df 92       	push	r13
    2b4a:	ff 92       	push	r15
    2b4c:	0f 93       	push	r16
    2b4e:	1f 93       	push	r17
    2b50:	cf 93       	push	r28
    2b52:	df 93       	push	r29
    2b54:	6c 01       	movw	r12, r24
    2b56:	8b 01       	movw	r16, r22
    2b58:	f4 2e       	mov	r15, r20

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    2b5a:	61 15       	cp	r22, r1
    2b5c:	71 05       	cpc	r23, r1
    2b5e:	11 f4       	brne	.+4      	; 0x2b64 <xStreamBufferGenericCreate+0x1e>
    2b60:	01 e0       	ldi	r16, 0x01	; 1
    2b62:	10 e0       	ldi	r17, 0x00	; 0
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    2b64:	c6 01       	movw	r24, r12
    2b66:	40 96       	adiw	r24, 0x10	; 16
    2b68:	c8 16       	cp	r12, r24
    2b6a:	d9 06       	cpc	r13, r25
    2b6c:	18 f0       	brcs	.+6      	; 0x2b74 <xStreamBufferGenericCreate+0x2e>
    2b6e:	a0 e0       	ldi	r26, 0x00	; 0
    2b70:	b0 e0       	ldi	r27, 0x00	; 0
    2b72:	1d c0       	rjmp	.+58     	; 0x2bae <xStreamBufferGenericCreate+0x68>
        {
            xBufferSizeBytes++;
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2b74:	0e 94 b5 0a 	call	0x156a	; 0x156a <pvPortMalloc>
    2b78:	fc 01       	movw	r30, r24
    2b7a:	dc 01       	movw	r26, r24
        else
        {
            pucAllocatedMemory = NULL;
        }

        if( pucAllocatedMemory != NULL )
    2b7c:	00 97       	sbiw	r24, 0x00	; 0
    2b7e:	b9 f0       	breq	.+46     	; 0x2bae <xStreamBufferGenericCreate+0x68>
            const BaseType_t xWriteValue = 0x55;
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
        } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    2b80:	8f e0       	ldi	r24, 0x0F	; 15
    2b82:	ef 01       	movw	r28, r30
    2b84:	19 92       	st	Y+, r1
    2b86:	8a 95       	dec	r24
    2b88:	e9 f7       	brne	.-6      	; 0x2b84 <xStreamBufferGenericCreate+0x3e>
    pxStreamBuffer->pucBuffer = pucBuffer;
    2b8a:	1f 96       	adiw	r26, 0x0f	; 15
    2b8c:	b5 87       	std	Z+13, r27	; 0x0d
    2b8e:	a4 87       	std	Z+12, r26	; 0x0c
    2b90:	1f 97       	sbiw	r26, 0x0f	; 15
    pxStreamBuffer->xLength = xBufferSizeBytes;
    2b92:	08 94       	sec
    2b94:	c1 1c       	adc	r12, r1
    2b96:	d1 1c       	adc	r13, r1
    2b98:	d5 82       	std	Z+5, r13	; 0x05
    2b9a:	c4 82       	std	Z+4, r12	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    2b9c:	17 83       	std	Z+7, r17	; 0x07
    2b9e:	06 83       	std	Z+6, r16	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    2ba0:	16 86       	std	Z+14, r1	; 0x0e
    2ba2:	81 e0       	ldi	r24, 0x01	; 1
    2ba4:	f8 16       	cp	r15, r24
    2ba6:	19 f4       	brne	.+6      	; 0x2bae <xStreamBufferGenericCreate+0x68>
    2ba8:	1e 96       	adiw	r26, 0x0e	; 14
    2baa:	fc 92       	st	X, r15
    2bac:	1e 97       	sbiw	r26, 0x0e	; 14
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    }
    2bae:	cd 01       	movw	r24, r26
    2bb0:	df 91       	pop	r29
    2bb2:	cf 91       	pop	r28
    2bb4:	1f 91       	pop	r17
    2bb6:	0f 91       	pop	r16
    2bb8:	ff 90       	pop	r15
    2bba:	df 90       	pop	r13
    2bbc:	cf 90       	pop	r12
    2bbe:	08 95       	ret

00002bc0 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2bc0:	80 91 a4 06 	lds	r24, 0x06A4
    2bc4:	8f 5f       	subi	r24, 0xFF	; 255
    2bc6:	80 93 a4 06 	sts	0x06A4, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    2bca:	08 95       	ret

00002bcc <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    2bcc:	0f b6       	in	r0, 0x3f	; 63
    2bce:	f8 94       	cli
    2bd0:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    2bd2:	20 91 a7 06 	lds	r18, 0x06A7
    2bd6:	30 91 a8 06 	lds	r19, 0x06A8
    }
    portTICK_TYPE_EXIT_CRITICAL();
    2bda:	0f 90       	pop	r0
    2bdc:	0f be       	out	0x3f, r0	; 63

    return xTicks;
}
    2bde:	c9 01       	movw	r24, r18
    2be0:	08 95       	ret

00002be2 <xTaskGetTickCountFromISR>:
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    {
        xReturn = xTickCount;
    2be2:	20 91 a7 06 	lds	r18, 0x06A7
    2be6:	30 91 a8 06 	lds	r19, 0x06A8
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2bea:	c9 01       	movw	r24, r18
    2bec:	08 95       	ret

00002bee <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    2bee:	80 91 ae 06 	lds	r24, 0x06AE
}
    2bf2:	08 95       	ret

00002bf4 <pcTaskGetName>:
{
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2bf4:	00 97       	sbiw	r24, 0x00	; 0
    2bf6:	21 f4       	brne	.+8      	; 0x2c00 <pcTaskGetName+0xc>
    2bf8:	80 91 a2 06 	lds	r24, 0x06A2
    2bfc:	90 91 a3 06 	lds	r25, 0x06A3
    2c00:	9c 01       	movw	r18, r24
    2c02:	27 5e       	subi	r18, 0xE7	; 231
    2c04:	3f 4f       	sbci	r19, 0xFF	; 255
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
}
    2c06:	c9 01       	movw	r24, r18
    2c08:	08 95       	ret

00002c0a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    2c0a:	ef 92       	push	r14
    2c0c:	ff 92       	push	r15
    2c0e:	0f 93       	push	r16
    2c10:	1f 93       	push	r17
    2c12:	cf 93       	push	r28
    2c14:	df 93       	push	r29
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2c16:	80 91 a4 06 	lds	r24, 0x06A4
    2c1a:	88 23       	and	r24, r24
    2c1c:	09 f0       	breq	.+2      	; 0x2c20 <xTaskIncrementTick+0x16>
    2c1e:	fb c0       	rjmp	.+502    	; 0x2e16 <xTaskIncrementTick+0x20c>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    2c20:	00 91 a7 06 	lds	r16, 0x06A7
    2c24:	10 91 a8 06 	lds	r17, 0x06A8
    2c28:	0f 5f       	subi	r16, 0xFF	; 255
    2c2a:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    2c2c:	10 93 a8 06 	sts	0x06A8, r17
    2c30:	00 93 a7 06 	sts	0x06A7, r16

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    2c34:	01 15       	cp	r16, r1
    2c36:	11 05       	cpc	r17, r1
    2c38:	61 f5       	brne	.+88     	; 0x2c92 <xTaskIncrementTick+0x88>
        {
            taskSWITCH_DELAYED_LISTS();
    2c3a:	20 91 20 07 	lds	r18, 0x0720
    2c3e:	30 91 21 07 	lds	r19, 0x0721
    2c42:	80 91 22 07 	lds	r24, 0x0722
    2c46:	90 91 23 07 	lds	r25, 0x0723
    2c4a:	90 93 21 07 	sts	0x0721, r25
    2c4e:	80 93 20 07 	sts	0x0720, r24
    2c52:	30 93 23 07 	sts	0x0723, r19
    2c56:	20 93 22 07 	sts	0x0722, r18
    2c5a:	80 91 ab 06 	lds	r24, 0x06AB
    2c5e:	8f 5f       	subi	r24, 0xFF	; 255
    2c60:	80 93 ab 06 	sts	0x06AB, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2c64:	e0 91 20 07 	lds	r30, 0x0720
    2c68:	f0 91 21 07 	lds	r31, 0x0721
    2c6c:	80 81       	ld	r24, Z
    2c6e:	88 23       	and	r24, r24
    2c70:	19 f4       	brne	.+6      	; 0x2c78 <xTaskIncrementTick+0x6e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    2c72:	8f ef       	ldi	r24, 0xFF	; 255
    2c74:	9f ef       	ldi	r25, 0xFF	; 255
    2c76:	09 c0       	rjmp	.+18     	; 0x2c8a <xTaskIncrementTick+0x80>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    2c78:	e0 91 20 07 	lds	r30, 0x0720
    2c7c:	f0 91 21 07 	lds	r31, 0x0721
    2c80:	05 80       	ldd	r0, Z+5	; 0x05
    2c82:	f6 81       	ldd	r31, Z+6	; 0x06
    2c84:	e0 2d       	mov	r30, r0
    2c86:	80 81       	ld	r24, Z
    2c88:	91 81       	ldd	r25, Z+1	; 0x01
    2c8a:	90 93 aa 06 	sts	0x06AA, r25
    2c8e:	80 93 a9 06 	sts	0x06A9, r24

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    2c92:	80 91 a9 06 	lds	r24, 0x06A9
    2c96:	90 91 aa 06 	lds	r25, 0x06AA
    2c9a:	08 17       	cp	r16, r24
    2c9c:	19 07       	cpc	r17, r25
    2c9e:	08 f4       	brcc	.+2      	; 0x2ca2 <xTaskIncrementTick+0x98>
    2ca0:	a2 c0       	rjmp	.+324    	; 0x2de6 <xTaskIncrementTick+0x1dc>
    2ca2:	ff 24       	eor	r15, r15
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    2ca4:	39 e0       	ldi	r19, 0x09	; 9
    2ca6:	e3 2e       	mov	r14, r19
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2ca8:	e0 91 20 07 	lds	r30, 0x0720
    2cac:	f0 91 21 07 	lds	r31, 0x0721
    2cb0:	80 81       	ld	r24, Z
    2cb2:	88 23       	and	r24, r24
    2cb4:	19 f4       	brne	.+6      	; 0x2cbc <xTaskIncrementTick+0xb2>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2cb6:	8f ef       	ldi	r24, 0xFF	; 255
    2cb8:	9f ef       	ldi	r25, 0xFF	; 255
    2cba:	0e c0       	rjmp	.+28     	; 0x2cd8 <xTaskIncrementTick+0xce>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2cbc:	e0 91 20 07 	lds	r30, 0x0720
    2cc0:	f0 91 21 07 	lds	r31, 0x0721
    2cc4:	05 80       	ldd	r0, Z+5	; 0x05
    2cc6:	f6 81       	ldd	r31, Z+6	; 0x06
    2cc8:	e0 2d       	mov	r30, r0
    2cca:	c6 81       	ldd	r28, Z+6	; 0x06
    2ccc:	d7 81       	ldd	r29, Z+7	; 0x07
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    2cce:	8a 81       	ldd	r24, Y+2	; 0x02
    2cd0:	9b 81       	ldd	r25, Y+3	; 0x03

                    if( xConstTickCount < xItemValue )
    2cd2:	08 17       	cp	r16, r24
    2cd4:	19 07       	cpc	r17, r25
    2cd6:	28 f4       	brcc	.+10     	; 0x2ce2 <xTaskIncrementTick+0xd8>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    2cd8:	90 93 aa 06 	sts	0x06AA, r25
    2cdc:	80 93 a9 06 	sts	0x06A9, r24
    2ce0:	83 c0       	rjmp	.+262    	; 0x2de8 <xTaskIncrementTick+0x1de>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    2ce2:	aa 85       	ldd	r26, Y+10	; 0x0a
    2ce4:	bb 85       	ldd	r27, Y+11	; 0x0b
    2ce6:	4c 81       	ldd	r20, Y+4	; 0x04
    2ce8:	5d 81       	ldd	r21, Y+5	; 0x05
    2cea:	8e 81       	ldd	r24, Y+6	; 0x06
    2cec:	9f 81       	ldd	r25, Y+7	; 0x07
    2cee:	fa 01       	movw	r30, r20
    2cf0:	95 83       	std	Z+5, r25	; 0x05
    2cf2:	84 83       	std	Z+4, r24	; 0x04
    2cf4:	2e 81       	ldd	r18, Y+6	; 0x06
    2cf6:	3f 81       	ldd	r19, Y+7	; 0x07
    2cf8:	f9 01       	movw	r30, r18
    2cfa:	53 83       	std	Z+3, r21	; 0x03
    2cfc:	42 83       	std	Z+2, r20	; 0x02
    2cfe:	be 01       	movw	r22, r28
    2d00:	6e 5f       	subi	r22, 0xFE	; 254
    2d02:	7f 4f       	sbci	r23, 0xFF	; 255
    2d04:	11 96       	adiw	r26, 0x01	; 1
    2d06:	8d 91       	ld	r24, X+
    2d08:	9c 91       	ld	r25, X
    2d0a:	12 97       	sbiw	r26, 0x02	; 2
    2d0c:	86 17       	cp	r24, r22
    2d0e:	97 07       	cpc	r25, r23
    2d10:	21 f4       	brne	.+8      	; 0x2d1a <xTaskIncrementTick+0x110>
    2d12:	12 96       	adiw	r26, 0x02	; 2
    2d14:	3c 93       	st	X, r19
    2d16:	2e 93       	st	-X, r18
    2d18:	11 97       	sbiw	r26, 0x01	; 1
    2d1a:	1b 86       	std	Y+11, r1	; 0x0b
    2d1c:	1a 86       	std	Y+10, r1	; 0x0a
    2d1e:	8c 91       	ld	r24, X
    2d20:	81 50       	subi	r24, 0x01	; 1
    2d22:	8c 93       	st	X, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2d24:	ac 89       	ldd	r26, Y+20	; 0x14
    2d26:	bd 89       	ldd	r27, Y+21	; 0x15
    2d28:	10 97       	sbiw	r26, 0x00	; 0
    2d2a:	f9 f0       	breq	.+62     	; 0x2d6a <xTaskIncrementTick+0x160>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    2d2c:	2e 85       	ldd	r18, Y+14	; 0x0e
    2d2e:	3f 85       	ldd	r19, Y+15	; 0x0f
    2d30:	88 89       	ldd	r24, Y+16	; 0x10
    2d32:	99 89       	ldd	r25, Y+17	; 0x11
    2d34:	f9 01       	movw	r30, r18
    2d36:	95 83       	std	Z+5, r25	; 0x05
    2d38:	84 83       	std	Z+4, r24	; 0x04
    2d3a:	48 89       	ldd	r20, Y+16	; 0x10
    2d3c:	59 89       	ldd	r21, Y+17	; 0x11
    2d3e:	fa 01       	movw	r30, r20
    2d40:	33 83       	std	Z+3, r19	; 0x03
    2d42:	22 83       	std	Z+2, r18	; 0x02
    2d44:	9e 01       	movw	r18, r28
    2d46:	24 5f       	subi	r18, 0xF4	; 244
    2d48:	3f 4f       	sbci	r19, 0xFF	; 255
    2d4a:	11 96       	adiw	r26, 0x01	; 1
    2d4c:	8d 91       	ld	r24, X+
    2d4e:	9c 91       	ld	r25, X
    2d50:	12 97       	sbiw	r26, 0x02	; 2
    2d52:	82 17       	cp	r24, r18
    2d54:	93 07       	cpc	r25, r19
    2d56:	21 f4       	brne	.+8      	; 0x2d60 <xTaskIncrementTick+0x156>
    2d58:	12 96       	adiw	r26, 0x02	; 2
    2d5a:	5c 93       	st	X, r21
    2d5c:	4e 93       	st	-X, r20
    2d5e:	11 97       	sbiw	r26, 0x01	; 1
    2d60:	1d 8a       	std	Y+21, r1	; 0x15
    2d62:	1c 8a       	std	Y+20, r1	; 0x14
    2d64:	8c 91       	ld	r24, X
    2d66:	81 50       	subi	r24, 0x01	; 1
    2d68:	8c 93       	st	X, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    2d6a:	9e 89       	ldd	r25, Y+22	; 0x16
    2d6c:	80 91 a5 06 	lds	r24, 0x06A5
    2d70:	89 17       	cp	r24, r25
    2d72:	10 f4       	brcc	.+4      	; 0x2d78 <xTaskIncrementTick+0x16e>
    2d74:	90 93 a5 06 	sts	0x06A5, r25
    2d78:	89 2f       	mov	r24, r25
    2d7a:	90 e0       	ldi	r25, 0x00	; 0
    2d7c:	fc 01       	movw	r30, r24
    2d7e:	23 e0       	ldi	r18, 0x03	; 3
    2d80:	ee 0f       	add	r30, r30
    2d82:	ff 1f       	adc	r31, r31
    2d84:	2a 95       	dec	r18
    2d86:	e1 f7       	brne	.-8      	; 0x2d80 <xTaskIncrementTick+0x176>
    2d88:	e8 0f       	add	r30, r24
    2d8a:	f9 1f       	adc	r31, r25
    2d8c:	ec 54       	subi	r30, 0x4C	; 76
    2d8e:	f9 4f       	sbci	r31, 0xF9	; 249
    2d90:	a1 81       	ldd	r26, Z+1	; 0x01
    2d92:	b2 81       	ldd	r27, Z+2	; 0x02
    2d94:	bd 83       	std	Y+5, r27	; 0x05
    2d96:	ac 83       	std	Y+4, r26	; 0x04
    2d98:	14 96       	adiw	r26, 0x04	; 4
    2d9a:	8d 91       	ld	r24, X+
    2d9c:	9c 91       	ld	r25, X
    2d9e:	15 97       	sbiw	r26, 0x05	; 5
    2da0:	9f 83       	std	Y+7, r25	; 0x07
    2da2:	8e 83       	std	Y+6, r24	; 0x06
    2da4:	14 96       	adiw	r26, 0x04	; 4
    2da6:	ed 91       	ld	r30, X+
    2da8:	fc 91       	ld	r31, X
    2daa:	15 97       	sbiw	r26, 0x05	; 5
    2dac:	73 83       	std	Z+3, r23	; 0x03
    2dae:	62 83       	std	Z+2, r22	; 0x02
    2db0:	15 96       	adiw	r26, 0x05	; 5
    2db2:	7c 93       	st	X, r23
    2db4:	6e 93       	st	-X, r22
    2db6:	14 97       	sbiw	r26, 0x04	; 4
    2db8:	ee 89       	ldd	r30, Y+22	; 0x16
    2dba:	ee 9d       	mul	r30, r14
    2dbc:	f0 01       	movw	r30, r0
    2dbe:	11 24       	eor	r1, r1
    2dc0:	ec 54       	subi	r30, 0x4C	; 76
    2dc2:	f9 4f       	sbci	r31, 0xF9	; 249
    2dc4:	fb 87       	std	Y+11, r31	; 0x0b
    2dc6:	ea 87       	std	Y+10, r30	; 0x0a
    2dc8:	80 81       	ld	r24, Z
    2dca:	8f 5f       	subi	r24, 0xFF	; 255
    2dcc:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2dce:	e0 91 a2 06 	lds	r30, 0x06A2
    2dd2:	f0 91 a3 06 	lds	r31, 0x06A3
    2dd6:	9e 89       	ldd	r25, Y+22	; 0x16
    2dd8:	86 89       	ldd	r24, Z+22	; 0x16
    2dda:	98 17       	cp	r25, r24
    2ddc:	08 f4       	brcc	.+2      	; 0x2de0 <xTaskIncrementTick+0x1d6>
    2dde:	64 cf       	rjmp	.-312    	; 0x2ca8 <xTaskIncrementTick+0x9e>
    2de0:	ff 24       	eor	r15, r15
    2de2:	f3 94       	inc	r15
    2de4:	61 cf       	rjmp	.-318    	; 0x2ca8 <xTaskIncrementTick+0x9e>
    2de6:	ff 24       	eor	r15, r15
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2de8:	e0 91 a2 06 	lds	r30, 0x06A2
    2dec:	f0 91 a3 06 	lds	r31, 0x06A3
    2df0:	e6 89       	ldd	r30, Z+22	; 0x16
    2df2:	89 e0       	ldi	r24, 0x09	; 9
    2df4:	e8 9f       	mul	r30, r24
    2df6:	f0 01       	movw	r30, r0
    2df8:	11 24       	eor	r1, r1
    2dfa:	ec 54       	subi	r30, 0x4C	; 76
    2dfc:	f9 4f       	sbci	r31, 0xF9	; 249
    2dfe:	80 81       	ld	r24, Z
    2e00:	82 30       	cpi	r24, 0x02	; 2
    2e02:	10 f0       	brcs	.+4      	; 0x2e08 <xTaskIncrementTick+0x1fe>
    2e04:	ff 24       	eor	r15, r15
    2e06:	f3 94       	inc	r15
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    2e08:	80 91 a6 06 	lds	r24, 0x06A6
    2e0c:	88 23       	and	r24, r24
    2e0e:	69 f0       	breq	.+26     	; 0x2e2a <xTaskIncrementTick+0x220>
    2e10:	ff 24       	eor	r15, r15
    2e12:	f3 94       	inc	r15
    2e14:	0a c0       	rjmp	.+20     	; 0x2e2a <xTaskIncrementTick+0x220>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    2e16:	80 91 ac 06 	lds	r24, 0x06AC
    2e1a:	90 91 ad 06 	lds	r25, 0x06AD
    2e1e:	01 96       	adiw	r24, 0x01	; 1
    2e20:	90 93 ad 06 	sts	0x06AD, r25
    2e24:	80 93 ac 06 	sts	0x06AC, r24
    2e28:	ff 24       	eor	r15, r15
            }
        #endif
    }

    return xSwitchRequired;
}
    2e2a:	8f 2d       	mov	r24, r15
    2e2c:	df 91       	pop	r29
    2e2e:	cf 91       	pop	r28
    2e30:	1f 91       	pop	r17
    2e32:	0f 91       	pop	r16
    2e34:	ff 90       	pop	r15
    2e36:	ef 90       	pop	r14
    2e38:	08 95       	ret

00002e3a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2e3a:	80 91 a4 06 	lds	r24, 0x06A4
    2e3e:	88 23       	and	r24, r24
    2e40:	21 f0       	breq	.+8      	; 0x2e4a <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    2e42:	81 e0       	ldi	r24, 0x01	; 1
    2e44:	80 93 a6 06 	sts	0x06A6, r24
    2e48:	08 95       	ret
    }
    else
    {
        xYieldPending = pdFALSE;
    2e4a:	10 92 a6 06 	sts	0x06A6, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2e4e:	20 91 a5 06 	lds	r18, 0x06A5
    2e52:	99 e0       	ldi	r25, 0x09	; 9
    2e54:	01 c0       	rjmp	.+2      	; 0x2e58 <vTaskSwitchContext+0x1e>
    2e56:	21 50       	subi	r18, 0x01	; 1
    2e58:	29 9f       	mul	r18, r25
    2e5a:	d0 01       	movw	r26, r0
    2e5c:	11 24       	eor	r1, r1
    2e5e:	ac 54       	subi	r26, 0x4C	; 76
    2e60:	b9 4f       	sbci	r27, 0xF9	; 249
    2e62:	8c 91       	ld	r24, X
    2e64:	88 23       	and	r24, r24
    2e66:	b9 f3       	breq	.-18     	; 0x2e56 <vTaskSwitchContext+0x1c>
    2e68:	11 96       	adiw	r26, 0x01	; 1
    2e6a:	ed 91       	ld	r30, X+
    2e6c:	fc 91       	ld	r31, X
    2e6e:	12 97       	sbiw	r26, 0x02	; 2
    2e70:	02 80       	ldd	r0, Z+2	; 0x02
    2e72:	f3 81       	ldd	r31, Z+3	; 0x03
    2e74:	e0 2d       	mov	r30, r0
    2e76:	12 96       	adiw	r26, 0x02	; 2
    2e78:	fc 93       	st	X, r31
    2e7a:	ee 93       	st	-X, r30
    2e7c:	11 97       	sbiw	r26, 0x01	; 1
    2e7e:	cd 01       	movw	r24, r26
    2e80:	03 96       	adiw	r24, 0x03	; 3
    2e82:	e8 17       	cp	r30, r24
    2e84:	f9 07       	cpc	r31, r25
    2e86:	31 f4       	brne	.+12     	; 0x2e94 <vTaskSwitchContext+0x5a>
    2e88:	82 81       	ldd	r24, Z+2	; 0x02
    2e8a:	93 81       	ldd	r25, Z+3	; 0x03
    2e8c:	12 96       	adiw	r26, 0x02	; 2
    2e8e:	9c 93       	st	X, r25
    2e90:	8e 93       	st	-X, r24
    2e92:	11 97       	sbiw	r26, 0x01	; 1
    2e94:	11 96       	adiw	r26, 0x01	; 1
    2e96:	ed 91       	ld	r30, X+
    2e98:	fc 91       	ld	r31, X
    2e9a:	12 97       	sbiw	r26, 0x02	; 2
    2e9c:	86 81       	ldd	r24, Z+6	; 0x06
    2e9e:	97 81       	ldd	r25, Z+7	; 0x07
    2ea0:	90 93 a3 06 	sts	0x06A3, r25
    2ea4:	80 93 a2 06 	sts	0x06A2, r24
    2ea8:	20 93 a5 06 	sts	0x06A5, r18
    2eac:	08 95       	ret

00002eae <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2eae:	cf 93       	push	r28
    2eb0:	df 93       	push	r29
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2eb2:	dc 01       	movw	r26, r24
    2eb4:	15 96       	adiw	r26, 0x05	; 5
    2eb6:	ed 91       	ld	r30, X+
    2eb8:	fc 91       	ld	r31, X
    2eba:	16 97       	sbiw	r26, 0x06	; 6
    2ebc:	c6 81       	ldd	r28, Z+6	; 0x06
    2ebe:	d7 81       	ldd	r29, Z+7	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    2ec0:	ac 89       	ldd	r26, Y+20	; 0x14
    2ec2:	bd 89       	ldd	r27, Y+21	; 0x15
    2ec4:	4e 85       	ldd	r20, Y+14	; 0x0e
    2ec6:	5f 85       	ldd	r21, Y+15	; 0x0f
    2ec8:	88 89       	ldd	r24, Y+16	; 0x10
    2eca:	99 89       	ldd	r25, Y+17	; 0x11
    2ecc:	fa 01       	movw	r30, r20
    2ece:	95 83       	std	Z+5, r25	; 0x05
    2ed0:	84 83       	std	Z+4, r24	; 0x04
    2ed2:	28 89       	ldd	r18, Y+16	; 0x10
    2ed4:	39 89       	ldd	r19, Y+17	; 0x11
    2ed6:	f9 01       	movw	r30, r18
    2ed8:	53 83       	std	Z+3, r21	; 0x03
    2eda:	42 83       	std	Z+2, r20	; 0x02
    2edc:	ae 01       	movw	r20, r28
    2ede:	44 5f       	subi	r20, 0xF4	; 244
    2ee0:	5f 4f       	sbci	r21, 0xFF	; 255
    2ee2:	11 96       	adiw	r26, 0x01	; 1
    2ee4:	8d 91       	ld	r24, X+
    2ee6:	9c 91       	ld	r25, X
    2ee8:	12 97       	sbiw	r26, 0x02	; 2
    2eea:	84 17       	cp	r24, r20
    2eec:	95 07       	cpc	r25, r21
    2eee:	21 f4       	brne	.+8      	; 0x2ef8 <xTaskRemoveFromEventList+0x4a>
    2ef0:	12 96       	adiw	r26, 0x02	; 2
    2ef2:	3c 93       	st	X, r19
    2ef4:	2e 93       	st	-X, r18
    2ef6:	11 97       	sbiw	r26, 0x01	; 1
    2ef8:	1d 8a       	std	Y+21, r1	; 0x15
    2efa:	1c 8a       	std	Y+20, r1	; 0x14
    2efc:	8c 91       	ld	r24, X
    2efe:	81 50       	subi	r24, 0x01	; 1
    2f00:	8c 93       	st	X, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2f02:	80 91 a4 06 	lds	r24, 0x06A4
    2f06:	88 23       	and	r24, r24
    2f08:	09 f0       	breq	.+2      	; 0x2f0c <xTaskRemoveFromEventList+0x5e>
    2f0a:	55 c0       	rjmp	.+170    	; 0x2fb6 <xTaskRemoveFromEventList+0x108>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    2f0c:	aa 85       	ldd	r26, Y+10	; 0x0a
    2f0e:	bb 85       	ldd	r27, Y+11	; 0x0b
    2f10:	4c 81       	ldd	r20, Y+4	; 0x04
    2f12:	5d 81       	ldd	r21, Y+5	; 0x05
    2f14:	8e 81       	ldd	r24, Y+6	; 0x06
    2f16:	9f 81       	ldd	r25, Y+7	; 0x07
    2f18:	fa 01       	movw	r30, r20
    2f1a:	95 83       	std	Z+5, r25	; 0x05
    2f1c:	84 83       	std	Z+4, r24	; 0x04
    2f1e:	2e 81       	ldd	r18, Y+6	; 0x06
    2f20:	3f 81       	ldd	r19, Y+7	; 0x07
    2f22:	f9 01       	movw	r30, r18
    2f24:	53 83       	std	Z+3, r21	; 0x03
    2f26:	42 83       	std	Z+2, r20	; 0x02
    2f28:	ae 01       	movw	r20, r28
    2f2a:	4e 5f       	subi	r20, 0xFE	; 254
    2f2c:	5f 4f       	sbci	r21, 0xFF	; 255
    2f2e:	11 96       	adiw	r26, 0x01	; 1
    2f30:	8d 91       	ld	r24, X+
    2f32:	9c 91       	ld	r25, X
    2f34:	12 97       	sbiw	r26, 0x02	; 2
    2f36:	84 17       	cp	r24, r20
    2f38:	95 07       	cpc	r25, r21
    2f3a:	21 f4       	brne	.+8      	; 0x2f44 <xTaskRemoveFromEventList+0x96>
    2f3c:	12 96       	adiw	r26, 0x02	; 2
    2f3e:	3c 93       	st	X, r19
    2f40:	2e 93       	st	-X, r18
    2f42:	11 97       	sbiw	r26, 0x01	; 1
    2f44:	1b 86       	std	Y+11, r1	; 0x0b
    2f46:	1a 86       	std	Y+10, r1	; 0x0a
    2f48:	8c 91       	ld	r24, X
    2f4a:	81 50       	subi	r24, 0x01	; 1
    2f4c:	8c 93       	st	X, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    2f4e:	9e 89       	ldd	r25, Y+22	; 0x16
    2f50:	80 91 a5 06 	lds	r24, 0x06A5
    2f54:	89 17       	cp	r24, r25
    2f56:	10 f4       	brcc	.+4      	; 0x2f5c <xTaskRemoveFromEventList+0xae>
    2f58:	90 93 a5 06 	sts	0x06A5, r25
    2f5c:	89 2f       	mov	r24, r25
    2f5e:	90 e0       	ldi	r25, 0x00	; 0
    2f60:	fc 01       	movw	r30, r24
    2f62:	63 e0       	ldi	r22, 0x03	; 3
    2f64:	ee 0f       	add	r30, r30
    2f66:	ff 1f       	adc	r31, r31
    2f68:	6a 95       	dec	r22
    2f6a:	e1 f7       	brne	.-8      	; 0x2f64 <xTaskRemoveFromEventList+0xb6>
    2f6c:	e8 0f       	add	r30, r24
    2f6e:	f9 1f       	adc	r31, r25
    2f70:	ec 54       	subi	r30, 0x4C	; 76
    2f72:	f9 4f       	sbci	r31, 0xF9	; 249
    2f74:	a1 81       	ldd	r26, Z+1	; 0x01
    2f76:	b2 81       	ldd	r27, Z+2	; 0x02
    2f78:	bd 83       	std	Y+5, r27	; 0x05
    2f7a:	ac 83       	std	Y+4, r26	; 0x04
    2f7c:	14 96       	adiw	r26, 0x04	; 4
    2f7e:	8d 91       	ld	r24, X+
    2f80:	9c 91       	ld	r25, X
    2f82:	15 97       	sbiw	r26, 0x05	; 5
    2f84:	9f 83       	std	Y+7, r25	; 0x07
    2f86:	8e 83       	std	Y+6, r24	; 0x06
    2f88:	14 96       	adiw	r26, 0x04	; 4
    2f8a:	ed 91       	ld	r30, X+
    2f8c:	fc 91       	ld	r31, X
    2f8e:	15 97       	sbiw	r26, 0x05	; 5
    2f90:	53 83       	std	Z+3, r21	; 0x03
    2f92:	42 83       	std	Z+2, r20	; 0x02
    2f94:	15 96       	adiw	r26, 0x05	; 5
    2f96:	5c 93       	st	X, r21
    2f98:	4e 93       	st	-X, r20
    2f9a:	14 97       	sbiw	r26, 0x04	; 4
    2f9c:	ee 89       	ldd	r30, Y+22	; 0x16
    2f9e:	89 e0       	ldi	r24, 0x09	; 9
    2fa0:	e8 9f       	mul	r30, r24
    2fa2:	f0 01       	movw	r30, r0
    2fa4:	11 24       	eor	r1, r1
    2fa6:	ec 54       	subi	r30, 0x4C	; 76
    2fa8:	f9 4f       	sbci	r31, 0xF9	; 249
    2faa:	fb 87       	std	Y+11, r31	; 0x0b
    2fac:	ea 87       	std	Y+10, r30	; 0x0a
    2fae:	80 81       	ld	r24, Z
    2fb0:	8f 5f       	subi	r24, 0xFF	; 255
    2fb2:	80 83       	st	Z, r24
    2fb4:	1f c0       	rjmp	.+62     	; 0x2ff4 <xTaskRemoveFromEventList+0x146>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2fb6:	a0 91 25 07 	lds	r26, 0x0725
    2fba:	b0 91 26 07 	lds	r27, 0x0726
    2fbe:	bf 87       	std	Y+15, r27	; 0x0f
    2fc0:	ae 87       	std	Y+14, r26	; 0x0e
    2fc2:	14 96       	adiw	r26, 0x04	; 4
    2fc4:	8d 91       	ld	r24, X+
    2fc6:	9c 91       	ld	r25, X
    2fc8:	15 97       	sbiw	r26, 0x05	; 5
    2fca:	99 8b       	std	Y+17, r25	; 0x11
    2fcc:	88 8b       	std	Y+16, r24	; 0x10
    2fce:	14 96       	adiw	r26, 0x04	; 4
    2fd0:	ed 91       	ld	r30, X+
    2fd2:	fc 91       	ld	r31, X
    2fd4:	15 97       	sbiw	r26, 0x05	; 5
    2fd6:	53 83       	std	Z+3, r21	; 0x03
    2fd8:	42 83       	std	Z+2, r20	; 0x02
    2fda:	15 96       	adiw	r26, 0x05	; 5
    2fdc:	5c 93       	st	X, r21
    2fde:	4e 93       	st	-X, r20
    2fe0:	14 97       	sbiw	r26, 0x04	; 4
    2fe2:	84 e2       	ldi	r24, 0x24	; 36
    2fe4:	97 e0       	ldi	r25, 0x07	; 7
    2fe6:	9d 8b       	std	Y+21, r25	; 0x15
    2fe8:	8c 8b       	std	Y+20, r24	; 0x14
    2fea:	80 91 24 07 	lds	r24, 0x0724
    2fee:	8f 5f       	subi	r24, 0xFF	; 255
    2ff0:	80 93 24 07 	sts	0x0724, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2ff4:	e0 91 a2 06 	lds	r30, 0x06A2
    2ff8:	f0 91 a3 06 	lds	r31, 0x06A3
    2ffc:	9e 89       	ldd	r25, Y+22	; 0x16
    2ffe:	86 89       	ldd	r24, Z+22	; 0x16
    3000:	89 17       	cp	r24, r25
    3002:	10 f0       	brcs	.+4      	; 0x3008 <xTaskRemoveFromEventList+0x15a>
    3004:	80 e0       	ldi	r24, 0x00	; 0
    3006:	03 c0       	rjmp	.+6      	; 0x300e <xTaskRemoveFromEventList+0x160>
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    3008:	81 e0       	ldi	r24, 0x01	; 1
    300a:	80 93 a6 06 	sts	0x06A6, r24
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    300e:	df 91       	pop	r29
    3010:	cf 91       	pop	r28
    3012:	08 95       	ret

00003014 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    3014:	cf 93       	push	r28
    3016:	df 93       	push	r29
    3018:	dc 01       	movw	r26, r24
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    301a:	70 68       	ori	r23, 0x80	; 128
    301c:	11 96       	adiw	r26, 0x01	; 1
    301e:	7c 93       	st	X, r23
    3020:	6e 93       	st	-X, r22

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3022:	16 96       	adiw	r26, 0x06	; 6
    3024:	2d 91       	ld	r18, X+
    3026:	3c 91       	ld	r19, X
    3028:	17 97       	sbiw	r26, 0x07	; 7
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    302a:	18 96       	adiw	r26, 0x08	; 8
    302c:	cd 91       	ld	r28, X+
    302e:	dc 91       	ld	r29, X
    3030:	19 97       	sbiw	r26, 0x09	; 9
    3032:	12 96       	adiw	r26, 0x02	; 2
    3034:	6d 91       	ld	r22, X+
    3036:	7c 91       	ld	r23, X
    3038:	13 97       	sbiw	r26, 0x03	; 3
    303a:	14 96       	adiw	r26, 0x04	; 4
    303c:	8d 91       	ld	r24, X+
    303e:	9c 91       	ld	r25, X
    3040:	15 97       	sbiw	r26, 0x05	; 5
    3042:	fb 01       	movw	r30, r22
    3044:	95 83       	std	Z+5, r25	; 0x05
    3046:	84 83       	std	Z+4, r24	; 0x04
    3048:	14 96       	adiw	r26, 0x04	; 4
    304a:	4d 91       	ld	r20, X+
    304c:	5c 91       	ld	r21, X
    304e:	15 97       	sbiw	r26, 0x05	; 5
    3050:	fa 01       	movw	r30, r20
    3052:	73 83       	std	Z+3, r23	; 0x03
    3054:	62 83       	std	Z+2, r22	; 0x02
    3056:	89 81       	ldd	r24, Y+1	; 0x01
    3058:	9a 81       	ldd	r25, Y+2	; 0x02
    305a:	8a 17       	cp	r24, r26
    305c:	9b 07       	cpc	r25, r27
    305e:	11 f4       	brne	.+4      	; 0x3064 <vTaskRemoveFromUnorderedEventList+0x50>
    3060:	5a 83       	std	Y+2, r21	; 0x02
    3062:	49 83       	std	Y+1, r20	; 0x01
    3064:	19 96       	adiw	r26, 0x09	; 9
    3066:	1c 92       	st	X, r1
    3068:	1e 92       	st	-X, r1
    306a:	18 97       	sbiw	r26, 0x08	; 8
    306c:	88 81       	ld	r24, Y
    306e:	81 50       	subi	r24, 0x01	; 1
    3070:	88 83       	st	Y, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    3072:	e9 01       	movw	r28, r18
    3074:	aa 85       	ldd	r26, Y+10	; 0x0a
    3076:	bb 85       	ldd	r27, Y+11	; 0x0b
    3078:	4c 81       	ldd	r20, Y+4	; 0x04
    307a:	5d 81       	ldd	r21, Y+5	; 0x05
    307c:	8e 81       	ldd	r24, Y+6	; 0x06
    307e:	9f 81       	ldd	r25, Y+7	; 0x07
    3080:	fa 01       	movw	r30, r20
    3082:	95 83       	std	Z+5, r25	; 0x05
    3084:	84 83       	std	Z+4, r24	; 0x04
    3086:	0e 80       	ldd	r0, Y+6	; 0x06
    3088:	df 81       	ldd	r29, Y+7	; 0x07
    308a:	c0 2d       	mov	r28, r0
    308c:	5b 83       	std	Y+3, r21	; 0x03
    308e:	4a 83       	std	Y+2, r20	; 0x02
    3090:	a9 01       	movw	r20, r18
    3092:	4e 5f       	subi	r20, 0xFE	; 254
    3094:	5f 4f       	sbci	r21, 0xFF	; 255
    3096:	11 96       	adiw	r26, 0x01	; 1
    3098:	8d 91       	ld	r24, X+
    309a:	9c 91       	ld	r25, X
    309c:	12 97       	sbiw	r26, 0x02	; 2
    309e:	84 17       	cp	r24, r20
    30a0:	95 07       	cpc	r25, r21
    30a2:	21 f4       	brne	.+8      	; 0x30ac <vTaskRemoveFromUnorderedEventList+0x98>
    30a4:	12 96       	adiw	r26, 0x02	; 2
    30a6:	dc 93       	st	X, r29
    30a8:	ce 93       	st	-X, r28
    30aa:	11 97       	sbiw	r26, 0x01	; 1
    30ac:	e9 01       	movw	r28, r18
    30ae:	1b 86       	std	Y+11, r1	; 0x0b
    30b0:	1a 86       	std	Y+10, r1	; 0x0a
    30b2:	8c 91       	ld	r24, X
    30b4:	81 50       	subi	r24, 0x01	; 1
    30b6:	8c 93       	st	X, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    30b8:	9e 89       	ldd	r25, Y+22	; 0x16
    30ba:	80 91 a5 06 	lds	r24, 0x06A5
    30be:	89 17       	cp	r24, r25
    30c0:	10 f4       	brcc	.+4      	; 0x30c6 <vTaskRemoveFromUnorderedEventList+0xb2>
    30c2:	90 93 a5 06 	sts	0x06A5, r25
    30c6:	89 2f       	mov	r24, r25
    30c8:	90 e0       	ldi	r25, 0x00	; 0
    30ca:	fc 01       	movw	r30, r24
    30cc:	73 e0       	ldi	r23, 0x03	; 3
    30ce:	ee 0f       	add	r30, r30
    30d0:	ff 1f       	adc	r31, r31
    30d2:	7a 95       	dec	r23
    30d4:	e1 f7       	brne	.-8      	; 0x30ce <vTaskRemoveFromUnorderedEventList+0xba>
    30d6:	e8 0f       	add	r30, r24
    30d8:	f9 1f       	adc	r31, r25
    30da:	ec 54       	subi	r30, 0x4C	; 76
    30dc:	f9 4f       	sbci	r31, 0xF9	; 249
    30de:	a1 81       	ldd	r26, Z+1	; 0x01
    30e0:	b2 81       	ldd	r27, Z+2	; 0x02
    30e2:	f9 01       	movw	r30, r18
    30e4:	b5 83       	std	Z+5, r27	; 0x05
    30e6:	a4 83       	std	Z+4, r26	; 0x04
    30e8:	14 96       	adiw	r26, 0x04	; 4
    30ea:	8d 91       	ld	r24, X+
    30ec:	9c 91       	ld	r25, X
    30ee:	15 97       	sbiw	r26, 0x05	; 5
    30f0:	97 83       	std	Z+7, r25	; 0x07
    30f2:	86 83       	std	Z+6, r24	; 0x06
    30f4:	14 96       	adiw	r26, 0x04	; 4
    30f6:	ed 91       	ld	r30, X+
    30f8:	fc 91       	ld	r31, X
    30fa:	15 97       	sbiw	r26, 0x05	; 5
    30fc:	53 83       	std	Z+3, r21	; 0x03
    30fe:	42 83       	std	Z+2, r20	; 0x02
    3100:	15 96       	adiw	r26, 0x05	; 5
    3102:	5c 93       	st	X, r21
    3104:	4e 93       	st	-X, r20
    3106:	14 97       	sbiw	r26, 0x04	; 4
    3108:	d9 01       	movw	r26, r18
    310a:	56 96       	adiw	r26, 0x16	; 22
    310c:	ec 91       	ld	r30, X
    310e:	56 97       	sbiw	r26, 0x16	; 22
    3110:	89 e0       	ldi	r24, 0x09	; 9
    3112:	e8 9f       	mul	r30, r24
    3114:	f0 01       	movw	r30, r0
    3116:	11 24       	eor	r1, r1
    3118:	ec 54       	subi	r30, 0x4C	; 76
    311a:	f9 4f       	sbci	r31, 0xF9	; 249
    311c:	1b 96       	adiw	r26, 0x0b	; 11
    311e:	fc 93       	st	X, r31
    3120:	ee 93       	st	-X, r30
    3122:	1a 97       	sbiw	r26, 0x0a	; 10
    3124:	80 81       	ld	r24, Z
    3126:	8f 5f       	subi	r24, 0xFF	; 255
    3128:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    312a:	e0 91 a2 06 	lds	r30, 0x06A2
    312e:	f0 91 a3 06 	lds	r31, 0x06A3
    3132:	56 96       	adiw	r26, 0x16	; 22
    3134:	9c 91       	ld	r25, X
    3136:	86 89       	ldd	r24, Z+22	; 0x16
    3138:	89 17       	cp	r24, r25
    313a:	18 f4       	brcc	.+6      	; 0x3142 <vTaskRemoveFromUnorderedEventList+0x12e>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    313c:	81 e0       	ldi	r24, 0x01	; 1
    313e:	80 93 a6 06 	sts	0x06A6, r24
    }
}
    3142:	df 91       	pop	r29
    3144:	cf 91       	pop	r28
    3146:	08 95       	ret

00003148 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3148:	fc 01       	movw	r30, r24
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    314a:	0f b6       	in	r0, 0x3f	; 63
    314c:	f8 94       	cli
    314e:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    3150:	80 91 ab 06 	lds	r24, 0x06AB
    3154:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    3156:	80 91 a7 06 	lds	r24, 0x06A7
    315a:	90 91 a8 06 	lds	r25, 0x06A8
    315e:	92 83       	std	Z+2, r25	; 0x02
    3160:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    3162:	0f 90       	pop	r0
    3164:	0f be       	out	0x3f, r0	; 63
}
    3166:	08 95       	ret

00003168 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3168:	fc 01       	movw	r30, r24
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    316a:	80 91 ab 06 	lds	r24, 0x06AB
    316e:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    3170:	80 91 a7 06 	lds	r24, 0x06A7
    3174:	90 91 a8 06 	lds	r25, 0x06A8
    3178:	92 83       	std	Z+2, r25	; 0x02
    317a:	81 83       	std	Z+1, r24	; 0x01
}
    317c:	08 95       	ret

0000317e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    317e:	dc 01       	movw	r26, r24
    3180:	fb 01       	movw	r30, r22
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    3182:	0f b6       	in	r0, 0x3f	; 63
    3184:	f8 94       	cli
    3186:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    3188:	40 91 a7 06 	lds	r20, 0x06A7
    318c:	50 91 a8 06 	lds	r21, 0x06A8
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3190:	11 96       	adiw	r26, 0x01	; 1
    3192:	2d 91       	ld	r18, X+
    3194:	3c 91       	ld	r19, X
    3196:	12 97       	sbiw	r26, 0x02	; 2
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3198:	90 91 ab 06 	lds	r25, 0x06AB
    319c:	8c 91       	ld	r24, X
    319e:	98 17       	cp	r25, r24
    31a0:	19 f0       	breq	.+6      	; 0x31a8 <xTaskCheckForTimeOut+0x2a>
    31a2:	42 17       	cp	r20, r18
    31a4:	53 07       	cpc	r21, r19
    31a6:	d0 f4       	brcc	.+52     	; 0x31dc <xTaskCheckForTimeOut+0x5e>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    31a8:	ca 01       	movw	r24, r20
    31aa:	82 1b       	sub	r24, r18
    31ac:	93 0b       	sbc	r25, r19
    31ae:	9c 01       	movw	r18, r24
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    31b0:	80 81       	ld	r24, Z
    31b2:	91 81       	ldd	r25, Z+1	; 0x01
    31b4:	28 17       	cp	r18, r24
    31b6:	39 07       	cpc	r19, r25
    31b8:	88 f4       	brcc	.+34     	; 0x31dc <xTaskCheckForTimeOut+0x5e>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    31ba:	82 1b       	sub	r24, r18
    31bc:	93 0b       	sbc	r25, r19
    31be:	91 83       	std	Z+1, r25	; 0x01
    31c0:	80 83       	st	Z, r24
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    31c2:	80 91 ab 06 	lds	r24, 0x06AB
    31c6:	8c 93       	st	X, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    31c8:	80 91 a7 06 	lds	r24, 0x06A7
    31cc:	90 91 a8 06 	lds	r25, 0x06A8
    31d0:	12 96       	adiw	r26, 0x02	; 2
    31d2:	9c 93       	st	X, r25
    31d4:	8e 93       	st	-X, r24
    31d6:	11 97       	sbiw	r26, 0x01	; 1
    31d8:	80 e0       	ldi	r24, 0x00	; 0
    31da:	03 c0       	rjmp	.+6      	; 0x31e2 <xTaskCheckForTimeOut+0x64>
            vTaskInternalSetTimeOutState( pxTimeOut );
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    31dc:	11 82       	std	Z+1, r1	; 0x01
    31de:	10 82       	st	Z, r1
    31e0:	81 e0       	ldi	r24, 0x01	; 1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
    31e2:	0f 90       	pop	r0
    31e4:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    31e6:	08 95       	ret

000031e8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
    31e8:	81 e0       	ldi	r24, 0x01	; 1
    31ea:	80 93 a6 06 	sts	0x06A6, r24
}
    31ee:	08 95       	ret

000031f0 <xTaskGetCurrentTaskHandle>:
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    31f0:	20 91 a2 06 	lds	r18, 0x06A2
    31f4:	30 91 a3 06 	lds	r19, 0x06A3

        return xReturn;
    }
    31f8:	c9 01       	movw	r24, r18
    31fa:	08 95       	ret

000031fc <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    31fc:	e0 91 a2 06 	lds	r30, 0x06A2
    3200:	f0 91 a3 06 	lds	r31, 0x06A3
    3204:	84 85       	ldd	r24, Z+12	; 0x0c
    3206:	95 85       	ldd	r25, Z+13	; 0x0d

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3208:	a0 91 a2 06 	lds	r26, 0x06A2
    320c:	b0 91 a3 06 	lds	r27, 0x06A3
    3210:	e0 91 a2 06 	lds	r30, 0x06A2
    3214:	f0 91 a3 06 	lds	r31, 0x06A3
    3218:	46 89       	ldd	r20, Z+22	; 0x16
    321a:	2a e0       	ldi	r18, 0x0A	; 10
    321c:	30 e0       	ldi	r19, 0x00	; 0
    321e:	24 1b       	sub	r18, r20
    3220:	31 09       	sbc	r19, r1
    3222:	1d 96       	adiw	r26, 0x0d	; 13
    3224:	3c 93       	st	X, r19
    3226:	2e 93       	st	-X, r18
    3228:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
}
    322a:	08 95       	ret

0000322c <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    322c:	cf 92       	push	r12
    322e:	df 92       	push	r13
    3230:	ef 92       	push	r14
    3232:	ff 92       	push	r15
    3234:	0f 93       	push	r16
    3236:	cf 93       	push	r28
    3238:	df 93       	push	r29
    323a:	ec 01       	movw	r28, r24

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( pulPreviousNotificationValue != NULL )
    323c:	e1 14       	cp	r14, r1
    323e:	f1 04       	cpc	r15, r1
    3240:	89 f0       	breq	.+34     	; 0x3264 <xTaskGenericNotifyFromISR+0x38>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    3242:	e6 2f       	mov	r30, r22
    3244:	f0 e0       	ldi	r31, 0x00	; 0
    3246:	ee 0f       	add	r30, r30
    3248:	ff 1f       	adc	r31, r31
    324a:	ee 0f       	add	r30, r30
    324c:	ff 1f       	adc	r31, r31
    324e:	e8 0f       	add	r30, r24
    3250:	f9 1f       	adc	r31, r25
    3252:	87 a9       	ldd	r24, Z+55	; 0x37
    3254:	90 ad       	ldd	r25, Z+56	; 0x38
    3256:	a1 ad       	ldd	r26, Z+57	; 0x39
    3258:	b2 ad       	ldd	r27, Z+58	; 0x3a
    325a:	f7 01       	movw	r30, r14
    325c:	80 83       	st	Z, r24
    325e:	91 83       	std	Z+1, r25	; 0x01
    3260:	a2 83       	std	Z+2, r26	; 0x02
    3262:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    3264:	a6 2f       	mov	r26, r22
    3266:	b0 e0       	ldi	r27, 0x00	; 0
    3268:	fe 01       	movw	r30, r28
    326a:	ea 0f       	add	r30, r26
    326c:	fb 1f       	adc	r31, r27
    326e:	63 ad       	ldd	r22, Z+59	; 0x3b
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    3270:	82 e0       	ldi	r24, 0x02	; 2
    3272:	83 af       	std	Z+59, r24	; 0x3b

            switch( eAction )
    3274:	02 30       	cpi	r16, 0x02	; 2
    3276:	d1 f0       	breq	.+52     	; 0x32ac <xTaskGenericNotifyFromISR+0x80>
    3278:	03 30       	cpi	r16, 0x03	; 3
    327a:	18 f4       	brcc	.+6      	; 0x3282 <xTaskGenericNotifyFromISR+0x56>
    327c:	01 30       	cpi	r16, 0x01	; 1
    327e:	c9 f5       	brne	.+114    	; 0x32f2 <xTaskGenericNotifyFromISR+0xc6>
    3280:	05 c0       	rjmp	.+10     	; 0x328c <xTaskGenericNotifyFromISR+0x60>
    3282:	03 30       	cpi	r16, 0x03	; 3
    3284:	51 f1       	breq	.+84     	; 0x32da <xTaskGenericNotifyFromISR+0xae>
    3286:	04 30       	cpi	r16, 0x04	; 4
    3288:	a1 f5       	brne	.+104    	; 0x32f2 <xTaskGenericNotifyFromISR+0xc6>
    328a:	23 c0       	rjmp	.+70     	; 0x32d2 <xTaskGenericNotifyFromISR+0xa6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    328c:	fd 01       	movw	r30, r26
    328e:	ee 0f       	add	r30, r30
    3290:	ff 1f       	adc	r31, r31
    3292:	ee 0f       	add	r30, r30
    3294:	ff 1f       	adc	r31, r31
    3296:	ec 0f       	add	r30, r28
    3298:	fd 1f       	adc	r31, r29
    329a:	87 a9       	ldd	r24, Z+55	; 0x37
    329c:	90 ad       	ldd	r25, Z+56	; 0x38
    329e:	a1 ad       	ldd	r26, Z+57	; 0x39
    32a0:	b2 ad       	ldd	r27, Z+58	; 0x3a
    32a2:	82 2b       	or	r24, r18
    32a4:	93 2b       	or	r25, r19
    32a6:	a4 2b       	or	r26, r20
    32a8:	b5 2b       	or	r27, r21
    32aa:	0e c0       	rjmp	.+28     	; 0x32c8 <xTaskGenericNotifyFromISR+0x9c>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    32ac:	fd 01       	movw	r30, r26
    32ae:	ee 0f       	add	r30, r30
    32b0:	ff 1f       	adc	r31, r31
    32b2:	ee 0f       	add	r30, r30
    32b4:	ff 1f       	adc	r31, r31
    32b6:	ec 0f       	add	r30, r28
    32b8:	fd 1f       	adc	r31, r29
    32ba:	87 a9       	ldd	r24, Z+55	; 0x37
    32bc:	90 ad       	ldd	r25, Z+56	; 0x38
    32be:	a1 ad       	ldd	r26, Z+57	; 0x39
    32c0:	b2 ad       	ldd	r27, Z+58	; 0x3a
    32c2:	01 96       	adiw	r24, 0x01	; 1
    32c4:	a1 1d       	adc	r26, r1
    32c6:	b1 1d       	adc	r27, r1
    32c8:	87 ab       	std	Z+55, r24	; 0x37
    32ca:	90 af       	std	Z+56, r25	; 0x38
    32cc:	a1 af       	std	Z+57, r26	; 0x39
    32ce:	b2 af       	std	Z+58, r27	; 0x3a
    32d0:	10 c0       	rjmp	.+32     	; 0x32f2 <xTaskGenericNotifyFromISR+0xc6>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    32d2:	62 30       	cpi	r22, 0x02	; 2
    32d4:	11 f4       	brne	.+4      	; 0x32da <xTaskGenericNotifyFromISR+0xae>
    32d6:	80 e0       	ldi	r24, 0x00	; 0
    32d8:	9d c0       	rjmp	.+314    	; 0x3414 <xTaskGenericNotifyFromISR+0x1e8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    32da:	aa 0f       	add	r26, r26
    32dc:	bb 1f       	adc	r27, r27
    32de:	aa 0f       	add	r26, r26
    32e0:	bb 1f       	adc	r27, r27
    32e2:	ac 0f       	add	r26, r28
    32e4:	bd 1f       	adc	r27, r29
    32e6:	d7 96       	adiw	r26, 0x37	; 55
    32e8:	2d 93       	st	X+, r18
    32ea:	3d 93       	st	X+, r19
    32ec:	4d 93       	st	X+, r20
    32ee:	5c 93       	st	X, r21
    32f0:	da 97       	sbiw	r26, 0x3a	; 58

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    32f2:	61 30       	cpi	r22, 0x01	; 1
    32f4:	09 f0       	breq	.+2      	; 0x32f8 <xTaskGenericNotifyFromISR+0xcc>
    32f6:	8d c0       	rjmp	.+282    	; 0x3412 <xTaskGenericNotifyFromISR+0x1e6>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    32f8:	80 91 a4 06 	lds	r24, 0x06A4
    32fc:	88 23       	and	r24, r24
    32fe:	09 f0       	breq	.+2      	; 0x3302 <xTaskGenericNotifyFromISR+0xd6>
    3300:	55 c0       	rjmp	.+170    	; 0x33ac <xTaskGenericNotifyFromISR+0x180>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3302:	aa 85       	ldd	r26, Y+10	; 0x0a
    3304:	bb 85       	ldd	r27, Y+11	; 0x0b
    3306:	4c 81       	ldd	r20, Y+4	; 0x04
    3308:	5d 81       	ldd	r21, Y+5	; 0x05
    330a:	8e 81       	ldd	r24, Y+6	; 0x06
    330c:	9f 81       	ldd	r25, Y+7	; 0x07
    330e:	fa 01       	movw	r30, r20
    3310:	95 83       	std	Z+5, r25	; 0x05
    3312:	84 83       	std	Z+4, r24	; 0x04
    3314:	2e 81       	ldd	r18, Y+6	; 0x06
    3316:	3f 81       	ldd	r19, Y+7	; 0x07
    3318:	f9 01       	movw	r30, r18
    331a:	53 83       	std	Z+3, r21	; 0x03
    331c:	42 83       	std	Z+2, r20	; 0x02
    331e:	ae 01       	movw	r20, r28
    3320:	4e 5f       	subi	r20, 0xFE	; 254
    3322:	5f 4f       	sbci	r21, 0xFF	; 255
    3324:	11 96       	adiw	r26, 0x01	; 1
    3326:	8d 91       	ld	r24, X+
    3328:	9c 91       	ld	r25, X
    332a:	12 97       	sbiw	r26, 0x02	; 2
    332c:	84 17       	cp	r24, r20
    332e:	95 07       	cpc	r25, r21
    3330:	21 f4       	brne	.+8      	; 0x333a <xTaskGenericNotifyFromISR+0x10e>
    3332:	12 96       	adiw	r26, 0x02	; 2
    3334:	3c 93       	st	X, r19
    3336:	2e 93       	st	-X, r18
    3338:	11 97       	sbiw	r26, 0x01	; 1
    333a:	1b 86       	std	Y+11, r1	; 0x0b
    333c:	1a 86       	std	Y+10, r1	; 0x0a
    333e:	8c 91       	ld	r24, X
    3340:	81 50       	subi	r24, 0x01	; 1
    3342:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    3344:	9e 89       	ldd	r25, Y+22	; 0x16
    3346:	80 91 a5 06 	lds	r24, 0x06A5
    334a:	89 17       	cp	r24, r25
    334c:	10 f4       	brcc	.+4      	; 0x3352 <xTaskGenericNotifyFromISR+0x126>
    334e:	90 93 a5 06 	sts	0x06A5, r25
    3352:	89 2f       	mov	r24, r25
    3354:	90 e0       	ldi	r25, 0x00	; 0
    3356:	fc 01       	movw	r30, r24
    3358:	a3 e0       	ldi	r26, 0x03	; 3
    335a:	ee 0f       	add	r30, r30
    335c:	ff 1f       	adc	r31, r31
    335e:	aa 95       	dec	r26
    3360:	e1 f7       	brne	.-8      	; 0x335a <xTaskGenericNotifyFromISR+0x12e>
    3362:	e8 0f       	add	r30, r24
    3364:	f9 1f       	adc	r31, r25
    3366:	ec 54       	subi	r30, 0x4C	; 76
    3368:	f9 4f       	sbci	r31, 0xF9	; 249
    336a:	a1 81       	ldd	r26, Z+1	; 0x01
    336c:	b2 81       	ldd	r27, Z+2	; 0x02
    336e:	bd 83       	std	Y+5, r27	; 0x05
    3370:	ac 83       	std	Y+4, r26	; 0x04
    3372:	14 96       	adiw	r26, 0x04	; 4
    3374:	8d 91       	ld	r24, X+
    3376:	9c 91       	ld	r25, X
    3378:	15 97       	sbiw	r26, 0x05	; 5
    337a:	9f 83       	std	Y+7, r25	; 0x07
    337c:	8e 83       	std	Y+6, r24	; 0x06
    337e:	14 96       	adiw	r26, 0x04	; 4
    3380:	ed 91       	ld	r30, X+
    3382:	fc 91       	ld	r31, X
    3384:	15 97       	sbiw	r26, 0x05	; 5
    3386:	53 83       	std	Z+3, r21	; 0x03
    3388:	42 83       	std	Z+2, r20	; 0x02
    338a:	15 96       	adiw	r26, 0x05	; 5
    338c:	5c 93       	st	X, r21
    338e:	4e 93       	st	-X, r20
    3390:	14 97       	sbiw	r26, 0x04	; 4
    3392:	ee 89       	ldd	r30, Y+22	; 0x16
    3394:	89 e0       	ldi	r24, 0x09	; 9
    3396:	e8 9f       	mul	r30, r24
    3398:	f0 01       	movw	r30, r0
    339a:	11 24       	eor	r1, r1
    339c:	ec 54       	subi	r30, 0x4C	; 76
    339e:	f9 4f       	sbci	r31, 0xF9	; 249
    33a0:	fb 87       	std	Y+11, r31	; 0x0b
    33a2:	ea 87       	std	Y+10, r30	; 0x0a
    33a4:	80 81       	ld	r24, Z
    33a6:	8f 5f       	subi	r24, 0xFF	; 255
    33a8:	80 83       	st	Z, r24
    33aa:	21 c0       	rjmp	.+66     	; 0x33ee <xTaskGenericNotifyFromISR+0x1c2>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    33ac:	a0 91 25 07 	lds	r26, 0x0725
    33b0:	b0 91 26 07 	lds	r27, 0x0726
    33b4:	bf 87       	std	Y+15, r27	; 0x0f
    33b6:	ae 87       	std	Y+14, r26	; 0x0e
    33b8:	14 96       	adiw	r26, 0x04	; 4
    33ba:	8d 91       	ld	r24, X+
    33bc:	9c 91       	ld	r25, X
    33be:	15 97       	sbiw	r26, 0x05	; 5
    33c0:	99 8b       	std	Y+17, r25	; 0x11
    33c2:	88 8b       	std	Y+16, r24	; 0x10
    33c4:	ce 01       	movw	r24, r28
    33c6:	0c 96       	adiw	r24, 0x0c	; 12
    33c8:	14 96       	adiw	r26, 0x04	; 4
    33ca:	ed 91       	ld	r30, X+
    33cc:	fc 91       	ld	r31, X
    33ce:	15 97       	sbiw	r26, 0x05	; 5
    33d0:	93 83       	std	Z+3, r25	; 0x03
    33d2:	82 83       	std	Z+2, r24	; 0x02
    33d4:	15 96       	adiw	r26, 0x05	; 5
    33d6:	9c 93       	st	X, r25
    33d8:	8e 93       	st	-X, r24
    33da:	14 97       	sbiw	r26, 0x04	; 4
    33dc:	84 e2       	ldi	r24, 0x24	; 36
    33de:	97 e0       	ldi	r25, 0x07	; 7
    33e0:	9d 8b       	std	Y+21, r25	; 0x15
    33e2:	8c 8b       	std	Y+20, r24	; 0x14
    33e4:	80 91 24 07 	lds	r24, 0x0724
    33e8:	8f 5f       	subi	r24, 0xFF	; 255
    33ea:	80 93 24 07 	sts	0x0724, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    33ee:	e0 91 a2 06 	lds	r30, 0x06A2
    33f2:	f0 91 a3 06 	lds	r31, 0x06A3
    33f6:	9e 89       	ldd	r25, Y+22	; 0x16
    33f8:	86 89       	ldd	r24, Z+22	; 0x16
    33fa:	89 17       	cp	r24, r25
    33fc:	50 f4       	brcc	.+20     	; 0x3412 <xTaskGenericNotifyFromISR+0x1e6>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    33fe:	c1 14       	cp	r12, r1
    3400:	d1 04       	cpc	r13, r1
    3402:	19 f0       	breq	.+6      	; 0x340a <xTaskGenericNotifyFromISR+0x1de>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    3404:	81 e0       	ldi	r24, 0x01	; 1
    3406:	f6 01       	movw	r30, r12
    3408:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    340a:	81 e0       	ldi	r24, 0x01	; 1
    340c:	80 93 a6 06 	sts	0x06A6, r24
    3410:	01 c0       	rjmp	.+2      	; 0x3414 <xTaskGenericNotifyFromISR+0x1e8>
    3412:	81 e0       	ldi	r24, 0x01	; 1
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    }
    3414:	df 91       	pop	r29
    3416:	cf 91       	pop	r28
    3418:	0f 91       	pop	r16
    341a:	ff 90       	pop	r15
    341c:	ef 90       	pop	r14
    341e:	df 90       	pop	r13
    3420:	cf 90       	pop	r12
    3422:	08 95       	ret

00003424 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    3424:	cf 93       	push	r28
    3426:	df 93       	push	r29
    3428:	ec 01       	movw	r28, r24
    342a:	e6 2f       	mov	r30, r22
    342c:	ba 01       	movw	r22, r20

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    342e:	f0 e0       	ldi	r31, 0x00	; 0
    3430:	dc 01       	movw	r26, r24
    3432:	ae 0f       	add	r26, r30
    3434:	bf 1f       	adc	r27, r31
    3436:	db 96       	adiw	r26, 0x3b	; 59
    3438:	2c 91       	ld	r18, X
    343a:	db 97       	sbiw	r26, 0x3b	; 59
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    343c:	82 e0       	ldi	r24, 0x02	; 2
    343e:	db 96       	adiw	r26, 0x3b	; 59
    3440:	8c 93       	st	X, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    3442:	ee 0f       	add	r30, r30
    3444:	ff 1f       	adc	r31, r31
    3446:	ee 0f       	add	r30, r30
    3448:	ff 1f       	adc	r31, r31
    344a:	ec 0f       	add	r30, r28
    344c:	fd 1f       	adc	r31, r29
    344e:	87 a9       	ldd	r24, Z+55	; 0x37
    3450:	90 ad       	ldd	r25, Z+56	; 0x38
    3452:	a1 ad       	ldd	r26, Z+57	; 0x39
    3454:	b2 ad       	ldd	r27, Z+58	; 0x3a
    3456:	01 96       	adiw	r24, 0x01	; 1
    3458:	a1 1d       	adc	r26, r1
    345a:	b1 1d       	adc	r27, r1
    345c:	87 ab       	std	Z+55, r24	; 0x37
    345e:	90 af       	std	Z+56, r25	; 0x38
    3460:	a1 af       	std	Z+57, r26	; 0x39
    3462:	b2 af       	std	Z+58, r27	; 0x3a

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3464:	21 30       	cpi	r18, 0x01	; 1
    3466:	09 f0       	breq	.+2      	; 0x346a <vTaskGenericNotifyGiveFromISR+0x46>
    3468:	8c c0       	rjmp	.+280    	; 0x3582 <vTaskGenericNotifyGiveFromISR+0x15e>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    346a:	80 91 a4 06 	lds	r24, 0x06A4
    346e:	88 23       	and	r24, r24
    3470:	09 f0       	breq	.+2      	; 0x3474 <vTaskGenericNotifyGiveFromISR+0x50>
    3472:	55 c0       	rjmp	.+170    	; 0x351e <vTaskGenericNotifyGiveFromISR+0xfa>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3474:	aa 85       	ldd	r26, Y+10	; 0x0a
    3476:	bb 85       	ldd	r27, Y+11	; 0x0b
    3478:	4c 81       	ldd	r20, Y+4	; 0x04
    347a:	5d 81       	ldd	r21, Y+5	; 0x05
    347c:	8e 81       	ldd	r24, Y+6	; 0x06
    347e:	9f 81       	ldd	r25, Y+7	; 0x07
    3480:	fa 01       	movw	r30, r20
    3482:	95 83       	std	Z+5, r25	; 0x05
    3484:	84 83       	std	Z+4, r24	; 0x04
    3486:	2e 81       	ldd	r18, Y+6	; 0x06
    3488:	3f 81       	ldd	r19, Y+7	; 0x07
    348a:	f9 01       	movw	r30, r18
    348c:	53 83       	std	Z+3, r21	; 0x03
    348e:	42 83       	std	Z+2, r20	; 0x02
    3490:	ae 01       	movw	r20, r28
    3492:	4e 5f       	subi	r20, 0xFE	; 254
    3494:	5f 4f       	sbci	r21, 0xFF	; 255
    3496:	11 96       	adiw	r26, 0x01	; 1
    3498:	8d 91       	ld	r24, X+
    349a:	9c 91       	ld	r25, X
    349c:	12 97       	sbiw	r26, 0x02	; 2
    349e:	84 17       	cp	r24, r20
    34a0:	95 07       	cpc	r25, r21
    34a2:	21 f4       	brne	.+8      	; 0x34ac <vTaskGenericNotifyGiveFromISR+0x88>
    34a4:	12 96       	adiw	r26, 0x02	; 2
    34a6:	3c 93       	st	X, r19
    34a8:	2e 93       	st	-X, r18
    34aa:	11 97       	sbiw	r26, 0x01	; 1
    34ac:	1b 86       	std	Y+11, r1	; 0x0b
    34ae:	1a 86       	std	Y+10, r1	; 0x0a
    34b0:	8c 91       	ld	r24, X
    34b2:	81 50       	subi	r24, 0x01	; 1
    34b4:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    34b6:	9e 89       	ldd	r25, Y+22	; 0x16
    34b8:	80 91 a5 06 	lds	r24, 0x06A5
    34bc:	89 17       	cp	r24, r25
    34be:	10 f4       	brcc	.+4      	; 0x34c4 <vTaskGenericNotifyGiveFromISR+0xa0>
    34c0:	90 93 a5 06 	sts	0x06A5, r25
    34c4:	89 2f       	mov	r24, r25
    34c6:	90 e0       	ldi	r25, 0x00	; 0
    34c8:	fc 01       	movw	r30, r24
    34ca:	a3 e0       	ldi	r26, 0x03	; 3
    34cc:	ee 0f       	add	r30, r30
    34ce:	ff 1f       	adc	r31, r31
    34d0:	aa 95       	dec	r26
    34d2:	e1 f7       	brne	.-8      	; 0x34cc <vTaskGenericNotifyGiveFromISR+0xa8>
    34d4:	e8 0f       	add	r30, r24
    34d6:	f9 1f       	adc	r31, r25
    34d8:	ec 54       	subi	r30, 0x4C	; 76
    34da:	f9 4f       	sbci	r31, 0xF9	; 249
    34dc:	a1 81       	ldd	r26, Z+1	; 0x01
    34de:	b2 81       	ldd	r27, Z+2	; 0x02
    34e0:	bd 83       	std	Y+5, r27	; 0x05
    34e2:	ac 83       	std	Y+4, r26	; 0x04
    34e4:	14 96       	adiw	r26, 0x04	; 4
    34e6:	8d 91       	ld	r24, X+
    34e8:	9c 91       	ld	r25, X
    34ea:	15 97       	sbiw	r26, 0x05	; 5
    34ec:	9f 83       	std	Y+7, r25	; 0x07
    34ee:	8e 83       	std	Y+6, r24	; 0x06
    34f0:	14 96       	adiw	r26, 0x04	; 4
    34f2:	ed 91       	ld	r30, X+
    34f4:	fc 91       	ld	r31, X
    34f6:	15 97       	sbiw	r26, 0x05	; 5
    34f8:	53 83       	std	Z+3, r21	; 0x03
    34fa:	42 83       	std	Z+2, r20	; 0x02
    34fc:	15 96       	adiw	r26, 0x05	; 5
    34fe:	5c 93       	st	X, r21
    3500:	4e 93       	st	-X, r20
    3502:	14 97       	sbiw	r26, 0x04	; 4
    3504:	ee 89       	ldd	r30, Y+22	; 0x16
    3506:	89 e0       	ldi	r24, 0x09	; 9
    3508:	e8 9f       	mul	r30, r24
    350a:	f0 01       	movw	r30, r0
    350c:	11 24       	eor	r1, r1
    350e:	ec 54       	subi	r30, 0x4C	; 76
    3510:	f9 4f       	sbci	r31, 0xF9	; 249
    3512:	fb 87       	std	Y+11, r31	; 0x0b
    3514:	ea 87       	std	Y+10, r30	; 0x0a
    3516:	80 81       	ld	r24, Z
    3518:	8f 5f       	subi	r24, 0xFF	; 255
    351a:	80 83       	st	Z, r24
    351c:	21 c0       	rjmp	.+66     	; 0x3560 <vTaskGenericNotifyGiveFromISR+0x13c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    351e:	a0 91 25 07 	lds	r26, 0x0725
    3522:	b0 91 26 07 	lds	r27, 0x0726
    3526:	bf 87       	std	Y+15, r27	; 0x0f
    3528:	ae 87       	std	Y+14, r26	; 0x0e
    352a:	14 96       	adiw	r26, 0x04	; 4
    352c:	8d 91       	ld	r24, X+
    352e:	9c 91       	ld	r25, X
    3530:	15 97       	sbiw	r26, 0x05	; 5
    3532:	99 8b       	std	Y+17, r25	; 0x11
    3534:	88 8b       	std	Y+16, r24	; 0x10
    3536:	ce 01       	movw	r24, r28
    3538:	0c 96       	adiw	r24, 0x0c	; 12
    353a:	14 96       	adiw	r26, 0x04	; 4
    353c:	ed 91       	ld	r30, X+
    353e:	fc 91       	ld	r31, X
    3540:	15 97       	sbiw	r26, 0x05	; 5
    3542:	93 83       	std	Z+3, r25	; 0x03
    3544:	82 83       	std	Z+2, r24	; 0x02
    3546:	15 96       	adiw	r26, 0x05	; 5
    3548:	9c 93       	st	X, r25
    354a:	8e 93       	st	-X, r24
    354c:	14 97       	sbiw	r26, 0x04	; 4
    354e:	84 e2       	ldi	r24, 0x24	; 36
    3550:	97 e0       	ldi	r25, 0x07	; 7
    3552:	9d 8b       	std	Y+21, r25	; 0x15
    3554:	8c 8b       	std	Y+20, r24	; 0x14
    3556:	80 91 24 07 	lds	r24, 0x0724
    355a:	8f 5f       	subi	r24, 0xFF	; 255
    355c:	80 93 24 07 	sts	0x0724, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3560:	e0 91 a2 06 	lds	r30, 0x06A2
    3564:	f0 91 a3 06 	lds	r31, 0x06A3
    3568:	9e 89       	ldd	r25, Y+22	; 0x16
    356a:	86 89       	ldd	r24, Z+22	; 0x16
    356c:	89 17       	cp	r24, r25
    356e:	48 f4       	brcc	.+18     	; 0x3582 <vTaskGenericNotifyGiveFromISR+0x15e>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    3570:	61 15       	cp	r22, r1
    3572:	71 05       	cpc	r23, r1
    3574:	19 f0       	breq	.+6      	; 0x357c <vTaskGenericNotifyGiveFromISR+0x158>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    3576:	81 e0       	ldi	r24, 0x01	; 1
    3578:	fb 01       	movw	r30, r22
    357a:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    357c:	81 e0       	ldi	r24, 0x01	; 1
    357e:	80 93 a6 06 	sts	0x06A6, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    3582:	df 91       	pop	r29
    3584:	cf 91       	pop	r28
    3586:	08 95       	ret

00003588 <xTaskGenericNotifyStateClear>:

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    3588:	00 97       	sbiw	r24, 0x00	; 0
    358a:	21 f4       	brne	.+8      	; 0x3594 <xTaskGenericNotifyStateClear+0xc>
    358c:	80 91 a2 06 	lds	r24, 0x06A2
    3590:	90 91 a3 06 	lds	r25, 0x06A3

        taskENTER_CRITICAL();
    3594:	0f b6       	in	r0, 0x3f	; 63
    3596:	f8 94       	cli
    3598:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    359a:	fc 01       	movw	r30, r24
    359c:	e6 0f       	add	r30, r22
    359e:	f1 1d       	adc	r31, r1
    35a0:	83 ad       	ldd	r24, Z+59	; 0x3b
    35a2:	82 30       	cpi	r24, 0x02	; 2
    35a4:	11 f0       	breq	.+4      	; 0x35aa <xTaskGenericNotifyStateClear+0x22>
    35a6:	80 e0       	ldi	r24, 0x00	; 0
    35a8:	02 c0       	rjmp	.+4      	; 0x35ae <xTaskGenericNotifyStateClear+0x26>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    35aa:	13 ae       	std	Z+59, r1	; 0x3b
    35ac:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = pdFAIL;
            }
        }
        taskEXIT_CRITICAL();
    35ae:	0f 90       	pop	r0
    35b0:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    35b2:	08 95       	ret

000035b4 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    35b4:	ef 92       	push	r14
    35b6:	ff 92       	push	r15
    35b8:	0f 93       	push	r16
    35ba:	1f 93       	push	r17
    35bc:	79 01       	movw	r14, r18
    35be:	8a 01       	movw	r16, r20
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    35c0:	00 97       	sbiw	r24, 0x00	; 0
    35c2:	21 f4       	brne	.+8      	; 0x35cc <ulTaskGenericNotifyValueClear+0x18>
    35c4:	80 91 a2 06 	lds	r24, 0x06A2
    35c8:	90 91 a3 06 	lds	r25, 0x06A3

        taskENTER_CRITICAL();
    35cc:	0f b6       	in	r0, 0x3f	; 63
    35ce:	f8 94       	cli
    35d0:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    35d2:	e6 2f       	mov	r30, r22
    35d4:	f0 e0       	ldi	r31, 0x00	; 0
    35d6:	ee 0f       	add	r30, r30
    35d8:	ff 1f       	adc	r31, r31
    35da:	ee 0f       	add	r30, r30
    35dc:	ff 1f       	adc	r31, r31
    35de:	e8 0f       	add	r30, r24
    35e0:	f9 1f       	adc	r31, r25
    35e2:	27 a9       	ldd	r18, Z+55	; 0x37
    35e4:	30 ad       	ldd	r19, Z+56	; 0x38
    35e6:	41 ad       	ldd	r20, Z+57	; 0x39
    35e8:	52 ad       	ldd	r21, Z+58	; 0x3a
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    35ea:	87 a9       	ldd	r24, Z+55	; 0x37
    35ec:	90 ad       	ldd	r25, Z+56	; 0x38
    35ee:	a1 ad       	ldd	r26, Z+57	; 0x39
    35f0:	b2 ad       	ldd	r27, Z+58	; 0x3a
    35f2:	e0 94       	com	r14
    35f4:	f0 94       	com	r15
    35f6:	00 95       	com	r16
    35f8:	10 95       	com	r17
    35fa:	8e 21       	and	r24, r14
    35fc:	9f 21       	and	r25, r15
    35fe:	a0 23       	and	r26, r16
    3600:	b1 23       	and	r27, r17
    3602:	87 ab       	std	Z+55, r24	; 0x37
    3604:	90 af       	std	Z+56, r25	; 0x38
    3606:	a1 af       	std	Z+57, r26	; 0x39
    3608:	b2 af       	std	Z+58, r27	; 0x3a
        }
        taskEXIT_CRITICAL();
    360a:	0f 90       	pop	r0
    360c:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    360e:	b9 01       	movw	r22, r18
    3610:	ca 01       	movw	r24, r20
    3612:	1f 91       	pop	r17
    3614:	0f 91       	pop	r16
    3616:	ff 90       	pop	r15
    3618:	ef 90       	pop	r14
    361a:	08 95       	ret

0000361c <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    361c:	ef 92       	push	r14
    361e:	ff 92       	push	r15
    3620:	0f 93       	push	r16
    3622:	cf 93       	push	r28
    3624:	df 93       	push	r29
    3626:	ec 01       	movw	r28, r24

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
    3628:	0f b6       	in	r0, 0x3f	; 63
    362a:	f8 94       	cli
    362c:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    362e:	e1 14       	cp	r14, r1
    3630:	f1 04       	cpc	r15, r1
    3632:	89 f0       	breq	.+34     	; 0x3656 <xTaskGenericNotify+0x3a>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    3634:	e6 2f       	mov	r30, r22
    3636:	f0 e0       	ldi	r31, 0x00	; 0
    3638:	ee 0f       	add	r30, r30
    363a:	ff 1f       	adc	r31, r31
    363c:	ee 0f       	add	r30, r30
    363e:	ff 1f       	adc	r31, r31
    3640:	ec 0f       	add	r30, r28
    3642:	fd 1f       	adc	r31, r29
    3644:	87 a9       	ldd	r24, Z+55	; 0x37
    3646:	90 ad       	ldd	r25, Z+56	; 0x38
    3648:	a1 ad       	ldd	r26, Z+57	; 0x39
    364a:	b2 ad       	ldd	r27, Z+58	; 0x3a
    364c:	f7 01       	movw	r30, r14
    364e:	80 83       	st	Z, r24
    3650:	91 83       	std	Z+1, r25	; 0x01
    3652:	a2 83       	std	Z+2, r26	; 0x02
    3654:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    3656:	a6 2f       	mov	r26, r22
    3658:	b0 e0       	ldi	r27, 0x00	; 0
    365a:	fe 01       	movw	r30, r28
    365c:	ea 0f       	add	r30, r26
    365e:	fb 1f       	adc	r31, r27
    3660:	63 ad       	ldd	r22, Z+59	; 0x3b

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    3662:	82 e0       	ldi	r24, 0x02	; 2
    3664:	83 af       	std	Z+59, r24	; 0x3b

            switch( eAction )
    3666:	02 30       	cpi	r16, 0x02	; 2
    3668:	d1 f0       	breq	.+52     	; 0x369e <xTaskGenericNotify+0x82>
    366a:	03 30       	cpi	r16, 0x03	; 3
    366c:	18 f4       	brcc	.+6      	; 0x3674 <xTaskGenericNotify+0x58>
    366e:	01 30       	cpi	r16, 0x01	; 1
    3670:	c9 f5       	brne	.+114    	; 0x36e4 <xTaskGenericNotify+0xc8>
    3672:	05 c0       	rjmp	.+10     	; 0x367e <xTaskGenericNotify+0x62>
    3674:	03 30       	cpi	r16, 0x03	; 3
    3676:	51 f1       	breq	.+84     	; 0x36cc <xTaskGenericNotify+0xb0>
    3678:	04 30       	cpi	r16, 0x04	; 4
    367a:	a1 f5       	brne	.+104    	; 0x36e4 <xTaskGenericNotify+0xc8>
    367c:	23 c0       	rjmp	.+70     	; 0x36c4 <xTaskGenericNotify+0xa8>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    367e:	fd 01       	movw	r30, r26
    3680:	ee 0f       	add	r30, r30
    3682:	ff 1f       	adc	r31, r31
    3684:	ee 0f       	add	r30, r30
    3686:	ff 1f       	adc	r31, r31
    3688:	ec 0f       	add	r30, r28
    368a:	fd 1f       	adc	r31, r29
    368c:	87 a9       	ldd	r24, Z+55	; 0x37
    368e:	90 ad       	ldd	r25, Z+56	; 0x38
    3690:	a1 ad       	ldd	r26, Z+57	; 0x39
    3692:	b2 ad       	ldd	r27, Z+58	; 0x3a
    3694:	82 2b       	or	r24, r18
    3696:	93 2b       	or	r25, r19
    3698:	a4 2b       	or	r26, r20
    369a:	b5 2b       	or	r27, r21
    369c:	0e c0       	rjmp	.+28     	; 0x36ba <xTaskGenericNotify+0x9e>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    369e:	fd 01       	movw	r30, r26
    36a0:	ee 0f       	add	r30, r30
    36a2:	ff 1f       	adc	r31, r31
    36a4:	ee 0f       	add	r30, r30
    36a6:	ff 1f       	adc	r31, r31
    36a8:	ec 0f       	add	r30, r28
    36aa:	fd 1f       	adc	r31, r29
    36ac:	87 a9       	ldd	r24, Z+55	; 0x37
    36ae:	90 ad       	ldd	r25, Z+56	; 0x38
    36b0:	a1 ad       	ldd	r26, Z+57	; 0x39
    36b2:	b2 ad       	ldd	r27, Z+58	; 0x3a
    36b4:	01 96       	adiw	r24, 0x01	; 1
    36b6:	a1 1d       	adc	r26, r1
    36b8:	b1 1d       	adc	r27, r1
    36ba:	87 ab       	std	Z+55, r24	; 0x37
    36bc:	90 af       	std	Z+56, r25	; 0x38
    36be:	a1 af       	std	Z+57, r26	; 0x39
    36c0:	b2 af       	std	Z+58, r27	; 0x3a
    36c2:	10 c0       	rjmp	.+32     	; 0x36e4 <xTaskGenericNotify+0xc8>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    36c4:	62 30       	cpi	r22, 0x02	; 2
    36c6:	11 f4       	brne	.+4      	; 0x36cc <xTaskGenericNotify+0xb0>
    36c8:	80 e0       	ldi	r24, 0x00	; 0
    36ca:	6e c0       	rjmp	.+220    	; 0x37a8 <xTaskGenericNotify+0x18c>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    36cc:	aa 0f       	add	r26, r26
    36ce:	bb 1f       	adc	r27, r27
    36d0:	aa 0f       	add	r26, r26
    36d2:	bb 1f       	adc	r27, r27
    36d4:	ac 0f       	add	r26, r28
    36d6:	bd 1f       	adc	r27, r29
    36d8:	d7 96       	adiw	r26, 0x37	; 55
    36da:	2d 93       	st	X+, r18
    36dc:	3d 93       	st	X+, r19
    36de:	4d 93       	st	X+, r20
    36e0:	5c 93       	st	X, r21
    36e2:	da 97       	sbiw	r26, 0x3a	; 58

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    36e4:	61 30       	cpi	r22, 0x01	; 1
    36e6:	09 f0       	breq	.+2      	; 0x36ea <xTaskGenericNotify+0xce>
    36e8:	5e c0       	rjmp	.+188    	; 0x37a6 <xTaskGenericNotify+0x18a>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    36ea:	aa 85       	ldd	r26, Y+10	; 0x0a
    36ec:	bb 85       	ldd	r27, Y+11	; 0x0b
    36ee:	4c 81       	ldd	r20, Y+4	; 0x04
    36f0:	5d 81       	ldd	r21, Y+5	; 0x05
    36f2:	8e 81       	ldd	r24, Y+6	; 0x06
    36f4:	9f 81       	ldd	r25, Y+7	; 0x07
    36f6:	fa 01       	movw	r30, r20
    36f8:	95 83       	std	Z+5, r25	; 0x05
    36fa:	84 83       	std	Z+4, r24	; 0x04
    36fc:	2e 81       	ldd	r18, Y+6	; 0x06
    36fe:	3f 81       	ldd	r19, Y+7	; 0x07
    3700:	f9 01       	movw	r30, r18
    3702:	53 83       	std	Z+3, r21	; 0x03
    3704:	42 83       	std	Z+2, r20	; 0x02
    3706:	ae 01       	movw	r20, r28
    3708:	4e 5f       	subi	r20, 0xFE	; 254
    370a:	5f 4f       	sbci	r21, 0xFF	; 255
    370c:	11 96       	adiw	r26, 0x01	; 1
    370e:	8d 91       	ld	r24, X+
    3710:	9c 91       	ld	r25, X
    3712:	12 97       	sbiw	r26, 0x02	; 2
    3714:	84 17       	cp	r24, r20
    3716:	95 07       	cpc	r25, r21
    3718:	21 f4       	brne	.+8      	; 0x3722 <xTaskGenericNotify+0x106>
    371a:	12 96       	adiw	r26, 0x02	; 2
    371c:	3c 93       	st	X, r19
    371e:	2e 93       	st	-X, r18
    3720:	11 97       	sbiw	r26, 0x01	; 1
    3722:	1b 86       	std	Y+11, r1	; 0x0b
    3724:	1a 86       	std	Y+10, r1	; 0x0a
    3726:	8c 91       	ld	r24, X
    3728:	81 50       	subi	r24, 0x01	; 1
    372a:	8c 93       	st	X, r24
                prvAddTaskToReadyList( pxTCB );
    372c:	9e 89       	ldd	r25, Y+22	; 0x16
    372e:	80 91 a5 06 	lds	r24, 0x06A5
    3732:	89 17       	cp	r24, r25
    3734:	10 f4       	brcc	.+4      	; 0x373a <xTaskGenericNotify+0x11e>
    3736:	90 93 a5 06 	sts	0x06A5, r25
    373a:	89 2f       	mov	r24, r25
    373c:	90 e0       	ldi	r25, 0x00	; 0
    373e:	fc 01       	movw	r30, r24
    3740:	33 e0       	ldi	r19, 0x03	; 3
    3742:	ee 0f       	add	r30, r30
    3744:	ff 1f       	adc	r31, r31
    3746:	3a 95       	dec	r19
    3748:	e1 f7       	brne	.-8      	; 0x3742 <xTaskGenericNotify+0x126>
    374a:	e8 0f       	add	r30, r24
    374c:	f9 1f       	adc	r31, r25
    374e:	ec 54       	subi	r30, 0x4C	; 76
    3750:	f9 4f       	sbci	r31, 0xF9	; 249
    3752:	a1 81       	ldd	r26, Z+1	; 0x01
    3754:	b2 81       	ldd	r27, Z+2	; 0x02
    3756:	bd 83       	std	Y+5, r27	; 0x05
    3758:	ac 83       	std	Y+4, r26	; 0x04
    375a:	14 96       	adiw	r26, 0x04	; 4
    375c:	8d 91       	ld	r24, X+
    375e:	9c 91       	ld	r25, X
    3760:	15 97       	sbiw	r26, 0x05	; 5
    3762:	9f 83       	std	Y+7, r25	; 0x07
    3764:	8e 83       	std	Y+6, r24	; 0x06
    3766:	14 96       	adiw	r26, 0x04	; 4
    3768:	ed 91       	ld	r30, X+
    376a:	fc 91       	ld	r31, X
    376c:	15 97       	sbiw	r26, 0x05	; 5
    376e:	53 83       	std	Z+3, r21	; 0x03
    3770:	42 83       	std	Z+2, r20	; 0x02
    3772:	15 96       	adiw	r26, 0x05	; 5
    3774:	5c 93       	st	X, r21
    3776:	4e 93       	st	-X, r20
    3778:	14 97       	sbiw	r26, 0x04	; 4
    377a:	ee 89       	ldd	r30, Y+22	; 0x16
    377c:	89 e0       	ldi	r24, 0x09	; 9
    377e:	e8 9f       	mul	r30, r24
    3780:	f0 01       	movw	r30, r0
    3782:	11 24       	eor	r1, r1
    3784:	ec 54       	subi	r30, 0x4C	; 76
    3786:	f9 4f       	sbci	r31, 0xF9	; 249
    3788:	fb 87       	std	Y+11, r31	; 0x0b
    378a:	ea 87       	std	Y+10, r30	; 0x0a
    378c:	80 81       	ld	r24, Z
    378e:	8f 5f       	subi	r24, 0xFF	; 255
    3790:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3792:	e0 91 a2 06 	lds	r30, 0x06A2
    3796:	f0 91 a3 06 	lds	r31, 0x06A3
    379a:	9e 89       	ldd	r25, Y+22	; 0x16
    379c:	86 89       	ldd	r24, Z+22	; 0x16
    379e:	89 17       	cp	r24, r25
    37a0:	10 f4       	brcc	.+4      	; 0x37a6 <xTaskGenericNotify+0x18a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    37a2:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
    37a6:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    37a8:	0f 90       	pop	r0
    37aa:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    37ac:	df 91       	pop	r29
    37ae:	cf 91       	pop	r28
    37b0:	0f 91       	pop	r16
    37b2:	ff 90       	pop	r15
    37b4:	ef 90       	pop	r14
    37b6:	08 95       	ret

000037b8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    37b8:	1f 93       	push	r17
    37ba:	cf 93       	push	r28
    37bc:	df 93       	push	r29
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    37be:	0f b6       	in	r0, 0x3f	; 63
    37c0:	f8 94       	cli
    37c2:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    37c4:	80 91 a4 06 	lds	r24, 0x06A4
    37c8:	81 50       	subi	r24, 0x01	; 1
    37ca:	80 93 a4 06 	sts	0x06A4, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    37ce:	80 91 a4 06 	lds	r24, 0x06A4
    37d2:	88 23       	and	r24, r24
    37d4:	09 f0       	breq	.+2      	; 0x37d8 <xTaskResumeAll+0x20>
    37d6:	c7 c0       	rjmp	.+398    	; 0x3966 <xTaskResumeAll+0x1ae>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    37d8:	80 91 ae 06 	lds	r24, 0x06AE
    37dc:	88 23       	and	r24, r24
    37de:	09 f4       	brne	.+2      	; 0x37e2 <xTaskResumeAll+0x2a>
    37e0:	c2 c0       	rjmp	.+388    	; 0x3966 <xTaskResumeAll+0x1ae>
    37e2:	c0 e0       	ldi	r28, 0x00	; 0
    37e4:	d0 e0       	ldi	r29, 0x00	; 0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    37e6:	79 e0       	ldi	r23, 0x09	; 9

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
                    {
                        xYieldPending = pdTRUE;
    37e8:	61 e0       	ldi	r22, 0x01	; 1
    37ea:	84 c0       	rjmp	.+264    	; 0x38f4 <xTaskResumeAll+0x13c>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    37ec:	e0 91 29 07 	lds	r30, 0x0729
    37f0:	f0 91 2a 07 	lds	r31, 0x072A
    37f4:	c6 81       	ldd	r28, Z+6	; 0x06
    37f6:	d7 81       	ldd	r29, Z+7	; 0x07
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    37f8:	ac 89       	ldd	r26, Y+20	; 0x14
    37fa:	bd 89       	ldd	r27, Y+21	; 0x15
    37fc:	2e 85       	ldd	r18, Y+14	; 0x0e
    37fe:	3f 85       	ldd	r19, Y+15	; 0x0f
    3800:	88 89       	ldd	r24, Y+16	; 0x10
    3802:	99 89       	ldd	r25, Y+17	; 0x11
    3804:	f9 01       	movw	r30, r18
    3806:	95 83       	std	Z+5, r25	; 0x05
    3808:	84 83       	std	Z+4, r24	; 0x04
    380a:	48 89       	ldd	r20, Y+16	; 0x10
    380c:	59 89       	ldd	r21, Y+17	; 0x11
    380e:	fa 01       	movw	r30, r20
    3810:	33 83       	std	Z+3, r19	; 0x03
    3812:	22 83       	std	Z+2, r18	; 0x02
    3814:	9e 01       	movw	r18, r28
    3816:	24 5f       	subi	r18, 0xF4	; 244
    3818:	3f 4f       	sbci	r19, 0xFF	; 255
    381a:	11 96       	adiw	r26, 0x01	; 1
    381c:	8d 91       	ld	r24, X+
    381e:	9c 91       	ld	r25, X
    3820:	12 97       	sbiw	r26, 0x02	; 2
    3822:	82 17       	cp	r24, r18
    3824:	93 07       	cpc	r25, r19
    3826:	21 f4       	brne	.+8      	; 0x3830 <xTaskResumeAll+0x78>
    3828:	12 96       	adiw	r26, 0x02	; 2
    382a:	5c 93       	st	X, r21
    382c:	4e 93       	st	-X, r20
    382e:	11 97       	sbiw	r26, 0x01	; 1
    3830:	1d 8a       	std	Y+21, r1	; 0x15
    3832:	1c 8a       	std	Y+20, r1	; 0x14
    3834:	8c 91       	ld	r24, X
    3836:	81 50       	subi	r24, 0x01	; 1
    3838:	8c 93       	st	X, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    383a:	aa 85       	ldd	r26, Y+10	; 0x0a
    383c:	bb 85       	ldd	r27, Y+11	; 0x0b
    383e:	4c 81       	ldd	r20, Y+4	; 0x04
    3840:	5d 81       	ldd	r21, Y+5	; 0x05
    3842:	8e 81       	ldd	r24, Y+6	; 0x06
    3844:	9f 81       	ldd	r25, Y+7	; 0x07
    3846:	fa 01       	movw	r30, r20
    3848:	95 83       	std	Z+5, r25	; 0x05
    384a:	84 83       	std	Z+4, r24	; 0x04
    384c:	2e 81       	ldd	r18, Y+6	; 0x06
    384e:	3f 81       	ldd	r19, Y+7	; 0x07
    3850:	f9 01       	movw	r30, r18
    3852:	53 83       	std	Z+3, r21	; 0x03
    3854:	42 83       	std	Z+2, r20	; 0x02
    3856:	ae 01       	movw	r20, r28
    3858:	4e 5f       	subi	r20, 0xFE	; 254
    385a:	5f 4f       	sbci	r21, 0xFF	; 255
    385c:	11 96       	adiw	r26, 0x01	; 1
    385e:	8d 91       	ld	r24, X+
    3860:	9c 91       	ld	r25, X
    3862:	12 97       	sbiw	r26, 0x02	; 2
    3864:	84 17       	cp	r24, r20
    3866:	95 07       	cpc	r25, r21
    3868:	21 f4       	brne	.+8      	; 0x3872 <xTaskResumeAll+0xba>
    386a:	12 96       	adiw	r26, 0x02	; 2
    386c:	3c 93       	st	X, r19
    386e:	2e 93       	st	-X, r18
    3870:	11 97       	sbiw	r26, 0x01	; 1
    3872:	1b 86       	std	Y+11, r1	; 0x0b
    3874:	1a 86       	std	Y+10, r1	; 0x0a
    3876:	8c 91       	ld	r24, X
    3878:	81 50       	subi	r24, 0x01	; 1
    387a:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    387c:	9e 89       	ldd	r25, Y+22	; 0x16
    387e:	80 91 a5 06 	lds	r24, 0x06A5
    3882:	89 17       	cp	r24, r25
    3884:	10 f4       	brcc	.+4      	; 0x388a <xTaskResumeAll+0xd2>
    3886:	90 93 a5 06 	sts	0x06A5, r25
    388a:	89 2f       	mov	r24, r25
    388c:	90 e0       	ldi	r25, 0x00	; 0
    388e:	fc 01       	movw	r30, r24
    3890:	23 e0       	ldi	r18, 0x03	; 3
    3892:	ee 0f       	add	r30, r30
    3894:	ff 1f       	adc	r31, r31
    3896:	2a 95       	dec	r18
    3898:	e1 f7       	brne	.-8      	; 0x3892 <xTaskResumeAll+0xda>
    389a:	e8 0f       	add	r30, r24
    389c:	f9 1f       	adc	r31, r25
    389e:	ec 54       	subi	r30, 0x4C	; 76
    38a0:	f9 4f       	sbci	r31, 0xF9	; 249
    38a2:	a1 81       	ldd	r26, Z+1	; 0x01
    38a4:	b2 81       	ldd	r27, Z+2	; 0x02
    38a6:	bd 83       	std	Y+5, r27	; 0x05
    38a8:	ac 83       	std	Y+4, r26	; 0x04
    38aa:	14 96       	adiw	r26, 0x04	; 4
    38ac:	8d 91       	ld	r24, X+
    38ae:	9c 91       	ld	r25, X
    38b0:	15 97       	sbiw	r26, 0x05	; 5
    38b2:	9f 83       	std	Y+7, r25	; 0x07
    38b4:	8e 83       	std	Y+6, r24	; 0x06
    38b6:	14 96       	adiw	r26, 0x04	; 4
    38b8:	ed 91       	ld	r30, X+
    38ba:	fc 91       	ld	r31, X
    38bc:	15 97       	sbiw	r26, 0x05	; 5
    38be:	53 83       	std	Z+3, r21	; 0x03
    38c0:	42 83       	std	Z+2, r20	; 0x02
    38c2:	15 96       	adiw	r26, 0x05	; 5
    38c4:	5c 93       	st	X, r21
    38c6:	4e 93       	st	-X, r20
    38c8:	14 97       	sbiw	r26, 0x04	; 4
    38ca:	ee 89       	ldd	r30, Y+22	; 0x16
    38cc:	e7 9f       	mul	r30, r23
    38ce:	f0 01       	movw	r30, r0
    38d0:	11 24       	eor	r1, r1
    38d2:	ec 54       	subi	r30, 0x4C	; 76
    38d4:	f9 4f       	sbci	r31, 0xF9	; 249
    38d6:	fb 87       	std	Y+11, r31	; 0x0b
    38d8:	ea 87       	std	Y+10, r30	; 0x0a
    38da:	80 81       	ld	r24, Z
    38dc:	8f 5f       	subi	r24, 0xFF	; 255
    38de:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    38e0:	e0 91 a2 06 	lds	r30, 0x06A2
    38e4:	f0 91 a3 06 	lds	r31, 0x06A3
    38e8:	9e 89       	ldd	r25, Y+22	; 0x16
    38ea:	86 89       	ldd	r24, Z+22	; 0x16
    38ec:	98 17       	cp	r25, r24
    38ee:	10 f0       	brcs	.+4      	; 0x38f4 <xTaskResumeAll+0x13c>
                    {
                        xYieldPending = pdTRUE;
    38f0:	60 93 a6 06 	sts	0x06A6, r22
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    38f4:	80 91 24 07 	lds	r24, 0x0724
    38f8:	88 23       	and	r24, r24
    38fa:	09 f0       	breq	.+2      	; 0x38fe <xTaskResumeAll+0x146>
    38fc:	77 cf       	rjmp	.-274    	; 0x37ec <xTaskResumeAll+0x34>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    38fe:	cd 2b       	or	r28, r29
    3900:	b9 f0       	breq	.+46     	; 0x3930 <xTaskResumeAll+0x178>
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3902:	e0 91 20 07 	lds	r30, 0x0720
    3906:	f0 91 21 07 	lds	r31, 0x0721
    390a:	80 81       	ld	r24, Z
    390c:	88 23       	and	r24, r24
    390e:	19 f4       	brne	.+6      	; 0x3916 <xTaskResumeAll+0x15e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    3910:	8f ef       	ldi	r24, 0xFF	; 255
    3912:	9f ef       	ldi	r25, 0xFF	; 255
    3914:	09 c0       	rjmp	.+18     	; 0x3928 <xTaskResumeAll+0x170>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    3916:	e0 91 20 07 	lds	r30, 0x0720
    391a:	f0 91 21 07 	lds	r31, 0x0721
    391e:	05 80       	ldd	r0, Z+5	; 0x05
    3920:	f6 81       	ldd	r31, Z+6	; 0x06
    3922:	e0 2d       	mov	r30, r0
    3924:	80 81       	ld	r24, Z
    3926:	91 81       	ldd	r25, Z+1	; 0x01
    3928:	90 93 aa 06 	sts	0x06AA, r25
    392c:	80 93 a9 06 	sts	0x06A9, r24
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3930:	c0 91 ac 06 	lds	r28, 0x06AC
    3934:	d0 91 ad 06 	lds	r29, 0x06AD

                    if( xPendedCounts > ( TickType_t ) 0U )
    3938:	20 97       	sbiw	r28, 0x00	; 0
    393a:	69 f0       	breq	.+26     	; 0x3956 <xTaskResumeAll+0x19e>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
    393c:	11 e0       	ldi	r17, 0x01	; 1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    393e:	0e 94 05 16 	call	0x2c0a	; 0x2c0a <xTaskIncrementTick>
    3942:	88 23       	and	r24, r24
    3944:	11 f0       	breq	.+4      	; 0x394a <xTaskResumeAll+0x192>
                            {
                                xYieldPending = pdTRUE;
    3946:	10 93 a6 06 	sts	0x06A6, r17
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    394a:	21 97       	sbiw	r28, 0x01	; 1
                        } while( xPendedCounts > ( TickType_t ) 0U );
    394c:	c1 f7       	brne	.-16     	; 0x393e <xTaskResumeAll+0x186>

                        xPendedTicks = 0;
    394e:	10 92 ad 06 	sts	0x06AD, r1
    3952:	10 92 ac 06 	sts	0x06AC, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3956:	80 91 a6 06 	lds	r24, 0x06A6
    395a:	88 23       	and	r24, r24
    395c:	21 f0       	breq	.+8      	; 0x3966 <xTaskResumeAll+0x1ae>
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    395e:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
    3962:	81 e0       	ldi	r24, 0x01	; 1
    3964:	01 c0       	rjmp	.+2      	; 0x3968 <xTaskResumeAll+0x1b0>
    3966:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3968:	0f 90       	pop	r0
    396a:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
}
    396c:	df 91       	pop	r29
    396e:	cf 91       	pop	r28
    3970:	1f 91       	pop	r17
    3972:	08 95       	ret

00003974 <xTaskCatchUpTicks>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3974:	20 91 a4 06 	lds	r18, 0x06A4
    3978:	2f 5f       	subi	r18, 0xFF	; 255
    397a:	20 93 a4 06 	sts	0x06A4, r18
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    xPendedTicks += xTicksToCatchUp;
    397e:	20 91 ac 06 	lds	r18, 0x06AC
    3982:	30 91 ad 06 	lds	r19, 0x06AD
    3986:	28 0f       	add	r18, r24
    3988:	39 1f       	adc	r19, r25
    398a:	30 93 ad 06 	sts	0x06AD, r19
    398e:	20 93 ac 06 	sts	0x06AC, r18
    xYieldOccurred = xTaskResumeAll();
    3992:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>

    return xYieldOccurred;
}
    3996:	08 95       	ret

00003998 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    3998:	0f 93       	push	r16
    399a:	1f 93       	push	r17
    399c:	cf 93       	push	r28
    399e:	df 93       	push	r29
    39a0:	ec 01       	movw	r28, r24
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    39a2:	00 91 a7 06 	lds	r16, 0x06A7
    39a6:	10 91 a8 06 	lds	r17, 0x06A8
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    39aa:	80 91 a2 06 	lds	r24, 0x06A2
    39ae:	90 91 a3 06 	lds	r25, 0x06A3
    39b2:	02 96       	adiw	r24, 0x02	; 2
    39b4:	0e 94 4e 0b 	call	0x169c	; 0x169c <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    39b8:	c0 0f       	add	r28, r16
    39ba:	d1 1f       	adc	r29, r17

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    39bc:	e0 91 a2 06 	lds	r30, 0x06A2
    39c0:	f0 91 a3 06 	lds	r31, 0x06A3
    39c4:	d3 83       	std	Z+3, r29	; 0x03
    39c6:	c2 83       	std	Z+2, r28	; 0x02

            if( xTimeToWake < xConstTickCount )
    39c8:	c0 17       	cp	r28, r16
    39ca:	d1 07       	cpc	r29, r17
    39cc:	68 f4       	brcc	.+26     	; 0x39e8 <prvAddCurrentTaskToDelayedList+0x50>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    39ce:	80 91 22 07 	lds	r24, 0x0722
    39d2:	90 91 23 07 	lds	r25, 0x0723
    39d6:	60 91 a2 06 	lds	r22, 0x06A2
    39da:	70 91 a3 06 	lds	r23, 0x06A3
    39de:	6e 5f       	subi	r22, 0xFE	; 254
    39e0:	7f 4f       	sbci	r23, 0xFF	; 255
    39e2:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsert>
    39e6:	17 c0       	rjmp	.+46     	; 0x3a16 <prvAddCurrentTaskToDelayedList+0x7e>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    39e8:	80 91 20 07 	lds	r24, 0x0720
    39ec:	90 91 21 07 	lds	r25, 0x0721
    39f0:	60 91 a2 06 	lds	r22, 0x06A2
    39f4:	70 91 a3 06 	lds	r23, 0x06A3
    39f8:	6e 5f       	subi	r22, 0xFE	; 254
    39fa:	7f 4f       	sbci	r23, 0xFF	; 255
    39fc:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    3a00:	80 91 a9 06 	lds	r24, 0x06A9
    3a04:	90 91 aa 06 	lds	r25, 0x06AA
    3a08:	c8 17       	cp	r28, r24
    3a0a:	d9 07       	cpc	r29, r25
    3a0c:	20 f4       	brcc	.+8      	; 0x3a16 <prvAddCurrentTaskToDelayedList+0x7e>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    3a0e:	d0 93 aa 06 	sts	0x06AA, r29
    3a12:	c0 93 a9 06 	sts	0x06A9, r28

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    3a16:	df 91       	pop	r29
    3a18:	cf 91       	pop	r28
    3a1a:	1f 91       	pop	r17
    3a1c:	0f 91       	pop	r16
    3a1e:	08 95       	ret

00003a20 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    3a20:	8f 92       	push	r8
    3a22:	9f 92       	push	r9
    3a24:	af 92       	push	r10
    3a26:	bf 92       	push	r11
    3a28:	cf 92       	push	r12
    3a2a:	df 92       	push	r13
    3a2c:	ef 92       	push	r14
    3a2e:	ff 92       	push	r15
    3a30:	0f 93       	push	r16
    3a32:	1f 93       	push	r17
    3a34:	cf 93       	push	r28
    3a36:	df 93       	push	r29
    3a38:	48 01       	movw	r8, r16
    3a3a:	59 01       	movw	r10, r18
    3a3c:	e7 01       	movw	r28, r14
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    3a3e:	0f b6       	in	r0, 0x3f	; 63
    3a40:	f8 94       	cli
    3a42:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    3a44:	e0 91 a2 06 	lds	r30, 0x06A2
    3a48:	f0 91 a3 06 	lds	r31, 0x06A3
    3a4c:	e8 2e       	mov	r14, r24
    3a4e:	ff 24       	eor	r15, r15
    3a50:	ee 0d       	add	r30, r14
    3a52:	ff 1d       	adc	r31, r15
    3a54:	83 ad       	ldd	r24, Z+59	; 0x3b
    3a56:	82 30       	cpi	r24, 0x02	; 2
    3a58:	61 f1       	breq	.+88     	; 0x3ab2 <xTaskGenericNotifyWait+0x92>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    3a5a:	e0 91 a2 06 	lds	r30, 0x06A2
    3a5e:	f0 91 a3 06 	lds	r31, 0x06A3
    3a62:	c7 01       	movw	r24, r14
    3a64:	88 0f       	add	r24, r24
    3a66:	99 1f       	adc	r25, r25
    3a68:	88 0f       	add	r24, r24
    3a6a:	99 1f       	adc	r25, r25
    3a6c:	e8 0f       	add	r30, r24
    3a6e:	f9 1f       	adc	r31, r25
    3a70:	87 a9       	ldd	r24, Z+55	; 0x37
    3a72:	90 ad       	ldd	r25, Z+56	; 0x38
    3a74:	a1 ad       	ldd	r26, Z+57	; 0x39
    3a76:	b2 ad       	ldd	r27, Z+58	; 0x3a
    3a78:	40 95       	com	r20
    3a7a:	50 95       	com	r21
    3a7c:	60 95       	com	r22
    3a7e:	70 95       	com	r23
    3a80:	84 23       	and	r24, r20
    3a82:	95 23       	and	r25, r21
    3a84:	a6 23       	and	r26, r22
    3a86:	b7 23       	and	r27, r23
    3a88:	87 ab       	std	Z+55, r24	; 0x37
    3a8a:	90 af       	std	Z+56, r25	; 0x38
    3a8c:	a1 af       	std	Z+57, r26	; 0x39
    3a8e:	b2 af       	std	Z+58, r27	; 0x3a

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    3a90:	e0 91 a2 06 	lds	r30, 0x06A2
    3a94:	f0 91 a3 06 	lds	r31, 0x06A3
    3a98:	ee 0d       	add	r30, r14
    3a9a:	ff 1d       	adc	r31, r15
    3a9c:	81 e0       	ldi	r24, 0x01	; 1
    3a9e:	83 af       	std	Z+59, r24	; 0x3b

                if( xTicksToWait > ( TickType_t ) 0 )
    3aa0:	c1 14       	cp	r12, r1
    3aa2:	d1 04       	cpc	r13, r1
    3aa4:	31 f0       	breq	.+12     	; 0x3ab2 <xTaskGenericNotifyWait+0x92>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3aa6:	c6 01       	movw	r24, r12
    3aa8:	61 e0       	ldi	r22, 0x01	; 1
    3aaa:	0e 94 cc 1c 	call	0x3998	; 0x3998 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    3aae:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    3ab2:	0f 90       	pop	r0
    3ab4:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    3ab6:	0f b6       	in	r0, 0x3f	; 63
    3ab8:	f8 94       	cli
    3aba:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    3abc:	20 97       	sbiw	r28, 0x00	; 0
    3abe:	99 f0       	breq	.+38     	; 0x3ae6 <xTaskGenericNotifyWait+0xc6>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    3ac0:	e0 91 a2 06 	lds	r30, 0x06A2
    3ac4:	f0 91 a3 06 	lds	r31, 0x06A3
    3ac8:	c7 01       	movw	r24, r14
    3aca:	88 0f       	add	r24, r24
    3acc:	99 1f       	adc	r25, r25
    3ace:	88 0f       	add	r24, r24
    3ad0:	99 1f       	adc	r25, r25
    3ad2:	e8 0f       	add	r30, r24
    3ad4:	f9 1f       	adc	r31, r25
    3ad6:	87 a9       	ldd	r24, Z+55	; 0x37
    3ad8:	90 ad       	ldd	r25, Z+56	; 0x38
    3ada:	a1 ad       	ldd	r26, Z+57	; 0x39
    3adc:	b2 ad       	ldd	r27, Z+58	; 0x3a
    3ade:	88 83       	st	Y, r24
    3ae0:	99 83       	std	Y+1, r25	; 0x01
    3ae2:	aa 83       	std	Y+2, r26	; 0x02
    3ae4:	bb 83       	std	Y+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    3ae6:	e0 91 a2 06 	lds	r30, 0x06A2
    3aea:	f0 91 a3 06 	lds	r31, 0x06A3
    3aee:	ee 0d       	add	r30, r14
    3af0:	ff 1d       	adc	r31, r15
    3af2:	83 ad       	ldd	r24, Z+59	; 0x3b
    3af4:	82 30       	cpi	r24, 0x02	; 2
    3af6:	11 f0       	breq	.+4      	; 0x3afc <xTaskGenericNotifyWait+0xdc>
    3af8:	80 e0       	ldi	r24, 0x00	; 0
    3afa:	1c c0       	rjmp	.+56     	; 0x3b34 <xTaskGenericNotifyWait+0x114>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    3afc:	e0 91 a2 06 	lds	r30, 0x06A2
    3b00:	f0 91 a3 06 	lds	r31, 0x06A3
    3b04:	c7 01       	movw	r24, r14
    3b06:	88 0f       	add	r24, r24
    3b08:	99 1f       	adc	r25, r25
    3b0a:	88 0f       	add	r24, r24
    3b0c:	99 1f       	adc	r25, r25
    3b0e:	e8 0f       	add	r30, r24
    3b10:	f9 1f       	adc	r31, r25
    3b12:	87 a9       	ldd	r24, Z+55	; 0x37
    3b14:	90 ad       	ldd	r25, Z+56	; 0x38
    3b16:	a1 ad       	ldd	r26, Z+57	; 0x39
    3b18:	b2 ad       	ldd	r27, Z+58	; 0x3a
    3b1a:	80 94       	com	r8
    3b1c:	90 94       	com	r9
    3b1e:	a0 94       	com	r10
    3b20:	b0 94       	com	r11
    3b22:	88 21       	and	r24, r8
    3b24:	99 21       	and	r25, r9
    3b26:	aa 21       	and	r26, r10
    3b28:	bb 21       	and	r27, r11
    3b2a:	87 ab       	std	Z+55, r24	; 0x37
    3b2c:	90 af       	std	Z+56, r25	; 0x38
    3b2e:	a1 af       	std	Z+57, r26	; 0x39
    3b30:	b2 af       	std	Z+58, r27	; 0x3a
    3b32:	81 e0       	ldi	r24, 0x01	; 1
                xReturn = pdTRUE;
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    3b34:	e0 91 a2 06 	lds	r30, 0x06A2
    3b38:	f0 91 a3 06 	lds	r31, 0x06A3
    3b3c:	ee 0d       	add	r30, r14
    3b3e:	ff 1d       	adc	r31, r15
    3b40:	13 ae       	std	Z+59, r1	; 0x3b
        }
        taskEXIT_CRITICAL();
    3b42:	0f 90       	pop	r0
    3b44:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    3b46:	df 91       	pop	r29
    3b48:	cf 91       	pop	r28
    3b4a:	1f 91       	pop	r17
    3b4c:	0f 91       	pop	r16
    3b4e:	ff 90       	pop	r15
    3b50:	ef 90       	pop	r14
    3b52:	df 90       	pop	r13
    3b54:	cf 90       	pop	r12
    3b56:	bf 90       	pop	r11
    3b58:	af 90       	pop	r10
    3b5a:	9f 90       	pop	r9
    3b5c:	8f 90       	pop	r8
    3b5e:	08 95       	ret

00003b60 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    3b60:	1f 93       	push	r17
    3b62:	cf 93       	push	r28
    3b64:	df 93       	push	r29
    3b66:	16 2f       	mov	r17, r22
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    3b68:	0f b6       	in	r0, 0x3f	; 63
    3b6a:	f8 94       	cli
    3b6c:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    3b6e:	e0 91 a2 06 	lds	r30, 0x06A2
    3b72:	f0 91 a3 06 	lds	r31, 0x06A3
    3b76:	c8 2f       	mov	r28, r24
    3b78:	d0 e0       	ldi	r29, 0x00	; 0
    3b7a:	ce 01       	movw	r24, r28
    3b7c:	88 0f       	add	r24, r24
    3b7e:	99 1f       	adc	r25, r25
    3b80:	88 0f       	add	r24, r24
    3b82:	99 1f       	adc	r25, r25
    3b84:	e8 0f       	add	r30, r24
    3b86:	f9 1f       	adc	r31, r25
    3b88:	87 a9       	ldd	r24, Z+55	; 0x37
    3b8a:	90 ad       	ldd	r25, Z+56	; 0x38
    3b8c:	a1 ad       	ldd	r26, Z+57	; 0x39
    3b8e:	b2 ad       	ldd	r27, Z+58	; 0x3a
    3b90:	00 97       	sbiw	r24, 0x00	; 0
    3b92:	a1 05       	cpc	r26, r1
    3b94:	b1 05       	cpc	r27, r1
    3b96:	89 f4       	brne	.+34     	; 0x3bba <ulTaskGenericNotifyTake+0x5a>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    3b98:	e0 91 a2 06 	lds	r30, 0x06A2
    3b9c:	f0 91 a3 06 	lds	r31, 0x06A3
    3ba0:	ec 0f       	add	r30, r28
    3ba2:	fd 1f       	adc	r31, r29
    3ba4:	81 e0       	ldi	r24, 0x01	; 1
    3ba6:	83 af       	std	Z+59, r24	; 0x3b

                if( xTicksToWait > ( TickType_t ) 0 )
    3ba8:	41 15       	cp	r20, r1
    3baa:	51 05       	cpc	r21, r1
    3bac:	31 f0       	breq	.+12     	; 0x3bba <ulTaskGenericNotifyTake+0x5a>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3bae:	ca 01       	movw	r24, r20
    3bb0:	61 e0       	ldi	r22, 0x01	; 1
    3bb2:	0e 94 cc 1c 	call	0x3998	; 0x3998 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    3bb6:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    3bba:	0f 90       	pop	r0
    3bbc:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    3bbe:	0f b6       	in	r0, 0x3f	; 63
    3bc0:	f8 94       	cli
    3bc2:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    3bc4:	e0 91 a2 06 	lds	r30, 0x06A2
    3bc8:	f0 91 a3 06 	lds	r31, 0x06A3
    3bcc:	ce 01       	movw	r24, r28
    3bce:	88 0f       	add	r24, r24
    3bd0:	99 1f       	adc	r25, r25
    3bd2:	88 0f       	add	r24, r24
    3bd4:	99 1f       	adc	r25, r25
    3bd6:	e8 0f       	add	r30, r24
    3bd8:	f9 1f       	adc	r31, r25
    3bda:	27 a9       	ldd	r18, Z+55	; 0x37
    3bdc:	30 ad       	ldd	r19, Z+56	; 0x38
    3bde:	41 ad       	ldd	r20, Z+57	; 0x39
    3be0:	52 ad       	ldd	r21, Z+58	; 0x3a

            if( ulReturn != 0UL )
    3be2:	21 15       	cp	r18, r1
    3be4:	31 05       	cpc	r19, r1
    3be6:	41 05       	cpc	r20, r1
    3be8:	51 05       	cpc	r21, r1
    3bea:	f9 f0       	breq	.+62     	; 0x3c2a <ulTaskGenericNotifyTake+0xca>
            {
                if( xClearCountOnExit != pdFALSE )
    3bec:	11 23       	and	r17, r17
    3bee:	59 f0       	breq	.+22     	; 0x3c06 <ulTaskGenericNotifyTake+0xa6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    3bf0:	e0 91 a2 06 	lds	r30, 0x06A2
    3bf4:	f0 91 a3 06 	lds	r31, 0x06A3
    3bf8:	e8 0f       	add	r30, r24
    3bfa:	f9 1f       	adc	r31, r25
    3bfc:	17 aa       	std	Z+55, r1	; 0x37
    3bfe:	10 ae       	std	Z+56, r1	; 0x38
    3c00:	11 ae       	std	Z+57, r1	; 0x39
    3c02:	12 ae       	std	Z+58, r1	; 0x3a
    3c04:	12 c0       	rjmp	.+36     	; 0x3c2a <ulTaskGenericNotifyTake+0xca>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    3c06:	e0 91 a2 06 	lds	r30, 0x06A2
    3c0a:	f0 91 a3 06 	lds	r31, 0x06A3
    3c0e:	21 50       	subi	r18, 0x01	; 1
    3c10:	30 40       	sbci	r19, 0x00	; 0
    3c12:	40 40       	sbci	r20, 0x00	; 0
    3c14:	50 40       	sbci	r21, 0x00	; 0
    3c16:	e8 0f       	add	r30, r24
    3c18:	f9 1f       	adc	r31, r25
    3c1a:	27 ab       	std	Z+55, r18	; 0x37
    3c1c:	30 af       	std	Z+56, r19	; 0x38
    3c1e:	41 af       	std	Z+57, r20	; 0x39
    3c20:	52 af       	std	Z+58, r21	; 0x3a
    3c22:	2f 5f       	subi	r18, 0xFF	; 255
    3c24:	3f 4f       	sbci	r19, 0xFF	; 255
    3c26:	4f 4f       	sbci	r20, 0xFF	; 255
    3c28:	5f 4f       	sbci	r21, 0xFF	; 255
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    3c2a:	e0 91 a2 06 	lds	r30, 0x06A2
    3c2e:	f0 91 a3 06 	lds	r31, 0x06A3
    3c32:	ec 0f       	add	r30, r28
    3c34:	fd 1f       	adc	r31, r29
    3c36:	13 ae       	std	Z+59, r1	; 0x3b
        }
        taskEXIT_CRITICAL();
    3c38:	0f 90       	pop	r0
    3c3a:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    3c3c:	b9 01       	movw	r22, r18
    3c3e:	ca 01       	movw	r24, r20
    3c40:	df 91       	pop	r29
    3c42:	cf 91       	pop	r28
    3c44:	1f 91       	pop	r17
    3c46:	08 95       	ret

00003c48 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    3c48:	0f 93       	push	r16
    3c4a:	1f 93       	push	r17
    3c4c:	8c 01       	movw	r16, r24
    3c4e:	ca 01       	movw	r24, r20
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3c50:	e0 91 a2 06 	lds	r30, 0x06A2
    3c54:	f0 91 a3 06 	lds	r31, 0x06A3
    3c58:	70 68       	ori	r23, 0x80	; 128
    3c5a:	75 87       	std	Z+13, r23	; 0x0d
    3c5c:	64 87       	std	Z+12, r22	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3c5e:	f8 01       	movw	r30, r16
    3c60:	a1 81       	ldd	r26, Z+1	; 0x01
    3c62:	b2 81       	ldd	r27, Z+2	; 0x02
    3c64:	e0 91 a2 06 	lds	r30, 0x06A2
    3c68:	f0 91 a3 06 	lds	r31, 0x06A3
    3c6c:	b7 87       	std	Z+15, r27	; 0x0f
    3c6e:	a6 87       	std	Z+14, r26	; 0x0e
    3c70:	e0 91 a2 06 	lds	r30, 0x06A2
    3c74:	f0 91 a3 06 	lds	r31, 0x06A3
    3c78:	14 96       	adiw	r26, 0x04	; 4
    3c7a:	2d 91       	ld	r18, X+
    3c7c:	3c 91       	ld	r19, X
    3c7e:	15 97       	sbiw	r26, 0x05	; 5
    3c80:	31 8b       	std	Z+17, r19	; 0x11
    3c82:	20 8b       	std	Z+16, r18	; 0x10
    3c84:	20 91 a2 06 	lds	r18, 0x06A2
    3c88:	30 91 a3 06 	lds	r19, 0x06A3
    3c8c:	14 96       	adiw	r26, 0x04	; 4
    3c8e:	ed 91       	ld	r30, X+
    3c90:	fc 91       	ld	r31, X
    3c92:	15 97       	sbiw	r26, 0x05	; 5
    3c94:	24 5f       	subi	r18, 0xF4	; 244
    3c96:	3f 4f       	sbci	r19, 0xFF	; 255
    3c98:	33 83       	std	Z+3, r19	; 0x03
    3c9a:	22 83       	std	Z+2, r18	; 0x02
    3c9c:	20 91 a2 06 	lds	r18, 0x06A2
    3ca0:	30 91 a3 06 	lds	r19, 0x06A3
    3ca4:	24 5f       	subi	r18, 0xF4	; 244
    3ca6:	3f 4f       	sbci	r19, 0xFF	; 255
    3ca8:	15 96       	adiw	r26, 0x05	; 5
    3caa:	3c 93       	st	X, r19
    3cac:	2e 93       	st	-X, r18
    3cae:	14 97       	sbiw	r26, 0x04	; 4
    3cb0:	e0 91 a2 06 	lds	r30, 0x06A2
    3cb4:	f0 91 a3 06 	lds	r31, 0x06A3
    3cb8:	15 8b       	std	Z+21, r17	; 0x15
    3cba:	04 8b       	std	Z+20, r16	; 0x14
    3cbc:	f8 01       	movw	r30, r16
    3cbe:	20 81       	ld	r18, Z
    3cc0:	2f 5f       	subi	r18, 0xFF	; 255
    3cc2:	20 83       	st	Z, r18

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3cc4:	61 e0       	ldi	r22, 0x01	; 1
    3cc6:	0e 94 cc 1c 	call	0x3998	; 0x3998 <prvAddCurrentTaskToDelayedList>
}
    3cca:	1f 91       	pop	r17
    3ccc:	0f 91       	pop	r16
    3cce:	08 95       	ret

00003cd0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    3cd0:	9c 01       	movw	r18, r24
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    3cd2:	00 97       	sbiw	r24, 0x00	; 0
    3cd4:	69 f0       	breq	.+26     	; 0x3cf0 <vTaskDelay+0x20>
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3cd6:	80 91 a4 06 	lds	r24, 0x06A4
    3cda:	8f 5f       	subi	r24, 0xFF	; 255
    3cdc:	80 93 a4 06 	sts	0x06A4, r24
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3ce0:	c9 01       	movw	r24, r18
    3ce2:	60 e0       	ldi	r22, 0x00	; 0
    3ce4:	0e 94 cc 1c 	call	0x3998	; 0x3998 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    3ce8:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3cec:	88 23       	and	r24, r24
    3cee:	11 f4       	brne	.+4      	; 0x3cf4 <vTaskDelay+0x24>
        {
            portYIELD_WITHIN_API();
    3cf0:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
    3cf4:	08 95       	ret

00003cf6 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    3cf6:	1f 93       	push	r17
    3cf8:	fc 01       	movw	r30, r24
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3cfa:	80 91 a4 06 	lds	r24, 0x06A4
    3cfe:	8f 5f       	subi	r24, 0xFF	; 255
    3d00:	80 93 a4 06 	sts	0x06A4, r24

        vTaskSuspendAll();
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    3d04:	80 91 a7 06 	lds	r24, 0x06A7
    3d08:	90 91 a8 06 	lds	r25, 0x06A8

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3d0c:	20 81       	ld	r18, Z
    3d0e:	31 81       	ldd	r19, Z+1	; 0x01
    3d10:	62 0f       	add	r22, r18
    3d12:	73 1f       	adc	r23, r19

            if( xConstTickCount < *pxPreviousWakeTime )
    3d14:	82 17       	cp	r24, r18
    3d16:	93 07       	cpc	r25, r19
    3d18:	28 f4       	brcc	.+10     	; 0x3d24 <xTaskDelayUntil+0x2e>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3d1a:	62 17       	cp	r22, r18
    3d1c:	73 07       	cpc	r23, r19
    3d1e:	28 f0       	brcs	.+10     	; 0x3d2a <xTaskDelayUntil+0x34>
    3d20:	10 e0       	ldi	r17, 0x00	; 0
    3d22:	08 c0       	rjmp	.+16     	; 0x3d34 <xTaskDelayUntil+0x3e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3d24:	62 17       	cp	r22, r18
    3d26:	73 07       	cpc	r23, r19
    3d28:	20 f0       	brcs	.+8      	; 0x3d32 <xTaskDelayUntil+0x3c>
    3d2a:	10 e0       	ldi	r17, 0x00	; 0
    3d2c:	86 17       	cp	r24, r22
    3d2e:	97 07       	cpc	r25, r23
    3d30:	08 f4       	brcc	.+2      	; 0x3d34 <xTaskDelayUntil+0x3e>
    3d32:	11 e0       	ldi	r17, 0x01	; 1
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    3d34:	71 83       	std	Z+1, r23	; 0x01
    3d36:	60 83       	st	Z, r22

            if( xShouldDelay != pdFALSE )
    3d38:	11 23       	and	r17, r17
    3d3a:	39 f0       	breq	.+14     	; 0x3d4a <xTaskDelayUntil+0x54>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    3d3c:	9b 01       	movw	r18, r22
    3d3e:	28 1b       	sub	r18, r24
    3d40:	39 0b       	sbc	r19, r25
    3d42:	c9 01       	movw	r24, r18
    3d44:	60 e0       	ldi	r22, 0x00	; 0
    3d46:	0e 94 cc 1c 	call	0x3998	; 0x3998 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    3d4a:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xTaskResumeAll>

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3d4e:	88 23       	and	r24, r24
    3d50:	11 f4       	brne	.+4      	; 0x3d56 <xTaskDelayUntil+0x60>
        {
            portYIELD_WITHIN_API();
    3d52:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    }
    3d56:	81 2f       	mov	r24, r17
    3d58:	1f 91       	pop	r17
    3d5a:	08 95       	ret

00003d5c <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    3d5c:	0f 93       	push	r16
    3d5e:	1f 93       	push	r17
    3d60:	8b 01       	movw	r16, r22
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3d62:	60 91 a2 06 	lds	r22, 0x06A2
    3d66:	70 91 a3 06 	lds	r23, 0x06A3
    3d6a:	64 5f       	subi	r22, 0xF4	; 244
    3d6c:	7f 4f       	sbci	r23, 0xFF	; 255
    3d6e:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3d72:	c8 01       	movw	r24, r16
    3d74:	61 e0       	ldi	r22, 0x01	; 1
    3d76:	0e 94 cc 1c 	call	0x3998	; 0x3998 <prvAddCurrentTaskToDelayedList>
}
    3d7a:	1f 91       	pop	r17
    3d7c:	0f 91       	pop	r16
    3d7e:	08 95       	ret

00003d80 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3d80:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3d82:	10 92 af 06 	sts	0x06AF, r1
    vPortEndScheduler();
    3d86:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortEndScheduler>
}
    3d8a:	08 95       	ret

00003d8c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3d8c:	0f 93       	push	r16
    3d8e:	1f 93       	push	r17
    3d90:	21 c0       	rjmp	.+66     	; 0x3dd4 <prvIdleTask+0x48>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    3d92:	0f b6       	in	r0, 0x3f	; 63
    3d94:	f8 94       	cli
    3d96:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d98:	e0 91 32 07 	lds	r30, 0x0732
    3d9c:	f0 91 33 07 	lds	r31, 0x0733
    3da0:	06 81       	ldd	r16, Z+6	; 0x06
    3da2:	17 81       	ldd	r17, Z+7	; 0x07
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3da4:	c8 01       	movw	r24, r16
    3da6:	02 96       	adiw	r24, 0x02	; 2
    3da8:	0e 94 4e 0b 	call	0x169c	; 0x169c <uxListRemove>
                    --uxCurrentNumberOfTasks;
    3dac:	80 91 ae 06 	lds	r24, 0x06AE
    3db0:	81 50       	subi	r24, 0x01	; 1
    3db2:	80 93 ae 06 	sts	0x06AE, r24
                    --uxDeletedTasksWaitingCleanUp;
    3db6:	80 91 b2 06 	lds	r24, 0x06B2
    3dba:	81 50       	subi	r24, 0x01	; 1
    3dbc:	80 93 b2 06 	sts	0x06B2, r24
                }
                taskEXIT_CRITICAL();
    3dc0:	0f 90       	pop	r0
    3dc2:	0f be       	out	0x3f, r0	; 63

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    3dc4:	f8 01       	movw	r30, r16
    3dc6:	87 89       	ldd	r24, Z+23	; 0x17
    3dc8:	90 8d       	ldd	r25, Z+24	; 0x18
    3dca:	0e 94 a5 0a 	call	0x154a	; 0x154a <vPortFree>
                vPortFree( pxTCB );
    3dce:	c8 01       	movw	r24, r16
    3dd0:	0e 94 a5 0a 	call	0x154a	; 0x154a <vPortFree>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    3dd4:	80 91 b2 06 	lds	r24, 0x06B2
    3dd8:	88 23       	and	r24, r24
    3dda:	d9 f6       	brne	.-74     	; 0x3d92 <prvIdleTask+0x6>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    3ddc:	80 91 b4 06 	lds	r24, 0x06B4
    3de0:	82 30       	cpi	r24, 0x02	; 2
    3de2:	c0 f3       	brcs	.-16     	; 0x3dd4 <prvIdleTask+0x48>
                {
                    taskYIELD();
    3de4:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
    3de8:	f5 cf       	rjmp	.-22     	; 0x3dd4 <prvIdleTask+0x48>

00003dea <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    3dea:	0f 93       	push	r16
    3dec:	1f 93       	push	r17
    3dee:	cf 93       	push	r28
    3df0:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    3df2:	0f b6       	in	r0, 0x3f	; 63
    3df4:	f8 94       	cli
    3df6:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3df8:	00 97       	sbiw	r24, 0x00	; 0
    3dfa:	11 f0       	breq	.+4      	; 0x3e00 <vTaskDelete+0x16>
    3dfc:	ec 01       	movw	r28, r24
    3dfe:	04 c0       	rjmp	.+8      	; 0x3e08 <vTaskDelete+0x1e>
    3e00:	c0 91 a2 06 	lds	r28, 0x06A2
    3e04:	d0 91 a3 06 	lds	r29, 0x06A3

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3e08:	8e 01       	movw	r16, r28
    3e0a:	0e 5f       	subi	r16, 0xFE	; 254
    3e0c:	1f 4f       	sbci	r17, 0xFF	; 255
    3e0e:	c8 01       	movw	r24, r16
    3e10:	0e 94 4e 0b 	call	0x169c	; 0x169c <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3e14:	8c 89       	ldd	r24, Y+20	; 0x14
    3e16:	9d 89       	ldd	r25, Y+21	; 0x15
    3e18:	89 2b       	or	r24, r25
    3e1a:	21 f0       	breq	.+8      	; 0x3e24 <vTaskDelete+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3e1c:	ce 01       	movw	r24, r28
    3e1e:	0c 96       	adiw	r24, 0x0c	; 12
    3e20:	0e 94 4e 0b 	call	0x169c	; 0x169c <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    3e24:	80 91 b3 06 	lds	r24, 0x06B3
    3e28:	8f 5f       	subi	r24, 0xFF	; 255
    3e2a:	80 93 b3 06 	sts	0x06B3, r24

            if( pxTCB == pxCurrentTCB )
    3e2e:	80 91 a2 06 	lds	r24, 0x06A2
    3e32:	90 91 a3 06 	lds	r25, 0x06A3
    3e36:	c8 17       	cp	r28, r24
    3e38:	d9 07       	cpc	r29, r25
    3e3a:	59 f4       	brne	.+22     	; 0x3e52 <vTaskDelete+0x68>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3e3c:	8d e2       	ldi	r24, 0x2D	; 45
    3e3e:	97 e0       	ldi	r25, 0x07	; 7
    3e40:	b8 01       	movw	r22, r16
    3e42:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    3e46:	80 91 b2 06 	lds	r24, 0x06B2
    3e4a:	8f 5f       	subi	r24, 0xFF	; 255
    3e4c:	80 93 b2 06 	sts	0x06B2, r24
    3e50:	1c c0       	rjmp	.+56     	; 0x3e8a <vTaskDelete+0xa0>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    3e52:	80 91 ae 06 	lds	r24, 0x06AE
    3e56:	81 50       	subi	r24, 0x01	; 1
    3e58:	80 93 ae 06 	sts	0x06AE, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3e5c:	e0 91 20 07 	lds	r30, 0x0720
    3e60:	f0 91 21 07 	lds	r31, 0x0721
    3e64:	80 81       	ld	r24, Z
    3e66:	88 23       	and	r24, r24
    3e68:	19 f4       	brne	.+6      	; 0x3e70 <vTaskDelete+0x86>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    3e6a:	8f ef       	ldi	r24, 0xFF	; 255
    3e6c:	9f ef       	ldi	r25, 0xFF	; 255
    3e6e:	09 c0       	rjmp	.+18     	; 0x3e82 <vTaskDelete+0x98>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    3e70:	e0 91 20 07 	lds	r30, 0x0720
    3e74:	f0 91 21 07 	lds	r31, 0x0721
    3e78:	05 80       	ldd	r0, Z+5	; 0x05
    3e7a:	f6 81       	ldd	r31, Z+6	; 0x06
    3e7c:	e0 2d       	mov	r30, r0
    3e7e:	80 81       	ld	r24, Z
    3e80:	91 81       	ldd	r25, Z+1	; 0x01
    3e82:	90 93 aa 06 	sts	0x06AA, r25
    3e86:	80 93 a9 06 	sts	0x06A9, r24
                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
            }
        }
        taskEXIT_CRITICAL();
    3e8a:	0f 90       	pop	r0
    3e8c:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    3e8e:	80 91 a2 06 	lds	r24, 0x06A2
    3e92:	90 91 a3 06 	lds	r25, 0x06A3
    3e96:	c8 17       	cp	r28, r24
    3e98:	d9 07       	cpc	r29, r25
    3e9a:	39 f0       	breq	.+14     	; 0x3eaa <vTaskDelete+0xc0>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    3e9c:	8f 89       	ldd	r24, Y+23	; 0x17
    3e9e:	98 8d       	ldd	r25, Y+24	; 0x18
    3ea0:	0e 94 a5 0a 	call	0x154a	; 0x154a <vPortFree>
                vPortFree( pxTCB );
    3ea4:	ce 01       	movw	r24, r28
    3ea6:	0e 94 a5 0a 	call	0x154a	; 0x154a <vPortFree>
            prvDeleteTCB( pxTCB );
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    3eaa:	80 91 af 06 	lds	r24, 0x06AF
    3eae:	88 23       	and	r24, r24
    3eb0:	49 f0       	breq	.+18     	; 0x3ec4 <vTaskDelete+0xda>
        {
            if( pxTCB == pxCurrentTCB )
    3eb2:	80 91 a2 06 	lds	r24, 0x06A2
    3eb6:	90 91 a3 06 	lds	r25, 0x06A3
    3eba:	c8 17       	cp	r28, r24
    3ebc:	d9 07       	cpc	r29, r25
    3ebe:	11 f4       	brne	.+4      	; 0x3ec4 <vTaskDelete+0xda>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    3ec0:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    3ec4:	df 91       	pop	r29
    3ec6:	cf 91       	pop	r28
    3ec8:	1f 91       	pop	r17
    3eca:	0f 91       	pop	r16
    3ecc:	08 95       	ret

00003ece <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    3ece:	4f 92       	push	r4
    3ed0:	5f 92       	push	r5
    3ed2:	6f 92       	push	r6
    3ed4:	7f 92       	push	r7
    3ed6:	8f 92       	push	r8
    3ed8:	9f 92       	push	r9
    3eda:	af 92       	push	r10
    3edc:	bf 92       	push	r11
    3ede:	cf 92       	push	r12
    3ee0:	df 92       	push	r13
    3ee2:	ef 92       	push	r14
    3ee4:	ff 92       	push	r15
    3ee6:	0f 93       	push	r16
    3ee8:	1f 93       	push	r17
    3eea:	cf 93       	push	r28
    3eec:	df 93       	push	r29
    3eee:	2c 01       	movw	r4, r24
    3ef0:	4b 01       	movw	r8, r22
    3ef2:	5a 01       	movw	r10, r20
    3ef4:	39 01       	movw	r6, r18
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3ef6:	ca 01       	movw	r24, r20
    3ef8:	0e 94 b5 0a 	call	0x156a	; 0x156a <pvPortMalloc>
    3efc:	ec 01       	movw	r28, r24

                if( pxStack != NULL )
    3efe:	00 97       	sbiw	r24, 0x00	; 0
    3f00:	99 f0       	breq	.+38     	; 0x3f28 <xTaskCreate+0x5a>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3f02:	8c e3       	ldi	r24, 0x3C	; 60
    3f04:	90 e0       	ldi	r25, 0x00	; 0
    3f06:	0e 94 b5 0a 	call	0x156a	; 0x156a <pvPortMalloc>
    3f0a:	6c 01       	movw	r12, r24

                    if( pxNewTCB != NULL )
    3f0c:	00 97       	sbiw	r24, 0x00	; 0
    3f0e:	49 f0       	breq	.+18     	; 0x3f22 <xTaskCreate+0x54>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    3f10:	dc 01       	movw	r26, r24
    3f12:	58 96       	adiw	r26, 0x18	; 24
    3f14:	dc 93       	st	X, r29
    3f16:	ce 93       	st	-X, r28
    3f18:	57 97       	sbiw	r26, 0x17	; 23
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    3f1a:	81 14       	cp	r8, r1
    3f1c:	91 04       	cpc	r9, r1
    3f1e:	31 f4       	brne	.+12     	; 0x3f2c <xTaskCreate+0x5e>
    3f20:	17 c0       	rjmp	.+46     	; 0x3f50 <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    3f22:	ce 01       	movw	r24, r28
    3f24:	0e 94 a5 0a 	call	0x154a	; 0x154a <vPortFree>
    3f28:	8f ef       	ldi	r24, 0xFF	; 255
    3f2a:	f2 c0       	rjmp	.+484    	; 0x4110 <xTaskCreate+0x242>
    3f2c:	f4 01       	movw	r30, r8
    3f2e:	dc 01       	movw	r26, r24
    3f30:	90 e0       	ldi	r25, 0x00	; 0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3f32:	80 81       	ld	r24, Z
    3f34:	59 96       	adiw	r26, 0x19	; 25
    3f36:	8c 93       	st	X, r24
    3f38:	59 97       	sbiw	r26, 0x19	; 25

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    3f3a:	80 81       	ld	r24, Z
    3f3c:	88 23       	and	r24, r24
    3f3e:	29 f0       	breq	.+10     	; 0x3f4a <xTaskCreate+0x7c>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3f40:	9f 5f       	subi	r25, 0xFF	; 255
    3f42:	31 96       	adiw	r30, 0x01	; 1
    3f44:	11 96       	adiw	r26, 0x01	; 1
    3f46:	9e 31       	cpi	r25, 0x1E	; 30
    3f48:	a1 f7       	brne	.-24     	; 0x3f32 <xTaskCreate+0x64>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3f4a:	f6 01       	movw	r30, r12
    3f4c:	16 aa       	std	Z+54, r1	; 0x36
    3f4e:	03 c0       	rjmp	.+6      	; 0x3f56 <xTaskCreate+0x88>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3f50:	dc 01       	movw	r26, r24
    3f52:	59 96       	adiw	r26, 0x19	; 25
    3f54:	1c 92       	st	X, r1
    3f56:	0a 30       	cpi	r16, 0x0A	; 10
    3f58:	08 f0       	brcs	.+2      	; 0x3f5c <xTaskCreate+0x8e>
    3f5a:	09 e0       	ldi	r16, 0x09	; 9
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    3f5c:	f6 01       	movw	r30, r12
    3f5e:	06 8b       	std	Z+22, r16	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3f60:	52 e0       	ldi	r21, 0x02	; 2
    3f62:	85 2e       	mov	r8, r21
    3f64:	91 2c       	mov	r9, r1
    3f66:	8c 0c       	add	r8, r12
    3f68:	9d 1c       	adc	r9, r13
    3f6a:	c4 01       	movw	r24, r8
    3f6c:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3f70:	c6 01       	movw	r24, r12
    3f72:	0c 96       	adiw	r24, 0x0c	; 12
    3f74:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3f78:	d6 01       	movw	r26, r12
    3f7a:	19 96       	adiw	r26, 0x09	; 9
    3f7c:	dc 92       	st	X, r13
    3f7e:	ce 92       	st	-X, r12
    3f80:	18 97       	sbiw	r26, 0x08	; 8

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3f82:	8a e0       	ldi	r24, 0x0A	; 10
    3f84:	90 e0       	ldi	r25, 0x00	; 0
    3f86:	80 1b       	sub	r24, r16
    3f88:	91 09       	sbc	r25, r1
    3f8a:	1d 96       	adiw	r26, 0x0d	; 13
    3f8c:	9c 93       	st	X, r25
    3f8e:	8e 93       	st	-X, r24
    3f90:	1c 97       	sbiw	r26, 0x0c	; 12
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3f92:	53 96       	adiw	r26, 0x13	; 19
    3f94:	dc 92       	st	X, r13
    3f96:	ce 92       	st	-X, r12
    3f98:	52 97       	sbiw	r26, 0x12	; 18
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    3f9a:	f6 01       	movw	r30, r12
    3f9c:	17 aa       	std	Z+55, r1	; 0x37
    3f9e:	10 ae       	std	Z+56, r1	; 0x38
    3fa0:	11 ae       	std	Z+57, r1	; 0x39
    3fa2:	12 ae       	std	Z+58, r1	; 0x3a
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    3fa4:	13 ae       	std	Z+59, r1	; 0x3b
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3fa6:	08 94       	sec
    3fa8:	a1 08       	sbc	r10, r1
    3faa:	b1 08       	sbc	r11, r1
    3fac:	ce 01       	movw	r24, r28
    3fae:	8a 0d       	add	r24, r10
    3fb0:	9b 1d       	adc	r25, r11
    3fb2:	b2 01       	movw	r22, r4
    3fb4:	a3 01       	movw	r20, r6
    3fb6:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <pxPortInitialiseStack>
    3fba:	d6 01       	movw	r26, r12
    3fbc:	8d 93       	st	X+, r24
    3fbe:	9c 93       	st	X, r25
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    3fc0:	e1 14       	cp	r14, r1
    3fc2:	f1 04       	cpc	r15, r1
    3fc4:	19 f0       	breq	.+6      	; 0x3fcc <xTaskCreate+0xfe>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3fc6:	f7 01       	movw	r30, r14
    3fc8:	d1 82       	std	Z+1, r13	; 0x01
    3fca:	c0 82       	st	Z, r12

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    3fcc:	0f b6       	in	r0, 0x3f	; 63
    3fce:	f8 94       	cli
    3fd0:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    3fd2:	80 91 ae 06 	lds	r24, 0x06AE
    3fd6:	8f 5f       	subi	r24, 0xFF	; 255
    3fd8:	80 93 ae 06 	sts	0x06AE, r24

        if( pxCurrentTCB == NULL )
    3fdc:	80 91 a2 06 	lds	r24, 0x06A2
    3fe0:	90 91 a3 06 	lds	r25, 0x06A3
    3fe4:	89 2b       	or	r24, r25
    3fe6:	79 f5       	brne	.+94     	; 0x4046 <xTaskCreate+0x178>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    3fe8:	d0 92 a3 06 	sts	0x06A3, r13
    3fec:	c0 92 a2 06 	sts	0x06A2, r12

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3ff0:	80 91 ae 06 	lds	r24, 0x06AE
    3ff4:	81 30       	cpi	r24, 0x01	; 1
    3ff6:	c9 f5       	brne	.+114    	; 0x406a <xTaskCreate+0x19c>
    3ff8:	c4 eb       	ldi	r28, 0xB4	; 180
    3ffa:	d6 e0       	ldi	r29, 0x06	; 6
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3ffc:	ce 01       	movw	r24, r28
    3ffe:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInitialise>
    4002:	29 96       	adiw	r28, 0x09	; 9

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4004:	f7 e0       	ldi	r31, 0x07	; 7
    4006:	ce 30       	cpi	r28, 0x0E	; 14
    4008:	df 07       	cpc	r29, r31
    400a:	c1 f7       	brne	.-16     	; 0x3ffc <xTaskCreate+0x12e>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    400c:	4e e0       	ldi	r20, 0x0E	; 14
    400e:	e4 2e       	mov	r14, r20
    4010:	47 e0       	ldi	r20, 0x07	; 7
    4012:	f4 2e       	mov	r15, r20
    4014:	c7 01       	movw	r24, r14
    4016:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    401a:	07 e1       	ldi	r16, 0x17	; 23
    401c:	17 e0       	ldi	r17, 0x07	; 7
    401e:	c8 01       	movw	r24, r16
    4020:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4024:	84 e2       	ldi	r24, 0x24	; 36
    4026:	97 e0       	ldi	r25, 0x07	; 7
    4028:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    402c:	8d e2       	ldi	r24, 0x2D	; 45
    402e:	97 e0       	ldi	r25, 0x07	; 7
    4030:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4034:	f0 92 21 07 	sts	0x0721, r15
    4038:	e0 92 20 07 	sts	0x0720, r14
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    403c:	10 93 23 07 	sts	0x0723, r17
    4040:	00 93 22 07 	sts	0x0722, r16
    4044:	12 c0       	rjmp	.+36     	; 0x406a <xTaskCreate+0x19c>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    4046:	80 91 af 06 	lds	r24, 0x06AF
    404a:	88 23       	and	r24, r24
    404c:	71 f4       	brne	.+28     	; 0x406a <xTaskCreate+0x19c>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    404e:	e0 91 a2 06 	lds	r30, 0x06A2
    4052:	f0 91 a3 06 	lds	r31, 0x06A3
    4056:	96 89       	ldd	r25, Z+22	; 0x16
    4058:	d6 01       	movw	r26, r12
    405a:	56 96       	adiw	r26, 0x16	; 22
    405c:	8c 91       	ld	r24, X
    405e:	89 17       	cp	r24, r25
    4060:	20 f0       	brcs	.+8      	; 0x406a <xTaskCreate+0x19c>
                {
                    pxCurrentTCB = pxNewTCB;
    4062:	d0 92 a3 06 	sts	0x06A3, r13
    4066:	c0 92 a2 06 	sts	0x06A2, r12
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    406a:	80 91 b3 06 	lds	r24, 0x06B3
    406e:	8f 5f       	subi	r24, 0xFF	; 255
    4070:	80 93 b3 06 	sts	0x06B3, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    4074:	f6 01       	movw	r30, r12
    4076:	96 89       	ldd	r25, Z+22	; 0x16
    4078:	80 91 a5 06 	lds	r24, 0x06A5
    407c:	89 17       	cp	r24, r25
    407e:	10 f4       	brcc	.+4      	; 0x4084 <xTaskCreate+0x1b6>
    4080:	90 93 a5 06 	sts	0x06A5, r25
    4084:	d6 01       	movw	r26, r12
    4086:	56 96       	adiw	r26, 0x16	; 22
    4088:	8c 91       	ld	r24, X
    408a:	90 e0       	ldi	r25, 0x00	; 0
    408c:	fc 01       	movw	r30, r24
    408e:	33 e0       	ldi	r19, 0x03	; 3
    4090:	ee 0f       	add	r30, r30
    4092:	ff 1f       	adc	r31, r31
    4094:	3a 95       	dec	r19
    4096:	e1 f7       	brne	.-8      	; 0x4090 <xTaskCreate+0x1c2>
    4098:	e8 0f       	add	r30, r24
    409a:	f9 1f       	adc	r31, r25
    409c:	ec 54       	subi	r30, 0x4C	; 76
    409e:	f9 4f       	sbci	r31, 0xF9	; 249
    40a0:	a1 81       	ldd	r26, Z+1	; 0x01
    40a2:	b2 81       	ldd	r27, Z+2	; 0x02
    40a4:	f6 01       	movw	r30, r12
    40a6:	b5 83       	std	Z+5, r27	; 0x05
    40a8:	a4 83       	std	Z+4, r26	; 0x04
    40aa:	14 96       	adiw	r26, 0x04	; 4
    40ac:	8d 91       	ld	r24, X+
    40ae:	9c 91       	ld	r25, X
    40b0:	15 97       	sbiw	r26, 0x05	; 5
    40b2:	97 83       	std	Z+7, r25	; 0x07
    40b4:	86 83       	std	Z+6, r24	; 0x06
    40b6:	14 96       	adiw	r26, 0x04	; 4
    40b8:	ed 91       	ld	r30, X+
    40ba:	fc 91       	ld	r31, X
    40bc:	15 97       	sbiw	r26, 0x05	; 5
    40be:	93 82       	std	Z+3, r9	; 0x03
    40c0:	82 82       	std	Z+2, r8	; 0x02
    40c2:	15 96       	adiw	r26, 0x05	; 5
    40c4:	9c 92       	st	X, r9
    40c6:	8e 92       	st	-X, r8
    40c8:	14 97       	sbiw	r26, 0x04	; 4
    40ca:	d6 01       	movw	r26, r12
    40cc:	56 96       	adiw	r26, 0x16	; 22
    40ce:	ec 91       	ld	r30, X
    40d0:	56 97       	sbiw	r26, 0x16	; 22
    40d2:	89 e0       	ldi	r24, 0x09	; 9
    40d4:	e8 9f       	mul	r30, r24
    40d6:	f0 01       	movw	r30, r0
    40d8:	11 24       	eor	r1, r1
    40da:	ec 54       	subi	r30, 0x4C	; 76
    40dc:	f9 4f       	sbci	r31, 0xF9	; 249
    40de:	1b 96       	adiw	r26, 0x0b	; 11
    40e0:	fc 93       	st	X, r31
    40e2:	ee 93       	st	-X, r30
    40e4:	1a 97       	sbiw	r26, 0x0a	; 10
    40e6:	80 81       	ld	r24, Z
    40e8:	8f 5f       	subi	r24, 0xFF	; 255
    40ea:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    40ec:	0f 90       	pop	r0
    40ee:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    40f0:	80 91 af 06 	lds	r24, 0x06AF
    40f4:	88 23       	and	r24, r24
    40f6:	59 f0       	breq	.+22     	; 0x410e <xTaskCreate+0x240>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    40f8:	e0 91 a2 06 	lds	r30, 0x06A2
    40fc:	f0 91 a3 06 	lds	r31, 0x06A3
    4100:	96 89       	ldd	r25, Z+22	; 0x16
    4102:	f6 01       	movw	r30, r12
    4104:	86 89       	ldd	r24, Z+22	; 0x16
    4106:	98 17       	cp	r25, r24
    4108:	10 f4       	brcc	.+4      	; 0x410e <xTaskCreate+0x240>
        {
            taskYIELD_IF_USING_PREEMPTION();
    410a:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortYield>
    410e:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
    4110:	df 91       	pop	r29
    4112:	cf 91       	pop	r28
    4114:	1f 91       	pop	r17
    4116:	0f 91       	pop	r16
    4118:	ff 90       	pop	r15
    411a:	ef 90       	pop	r14
    411c:	df 90       	pop	r13
    411e:	cf 90       	pop	r12
    4120:	bf 90       	pop	r11
    4122:	af 90       	pop	r10
    4124:	9f 90       	pop	r9
    4126:	8f 90       	pop	r8
    4128:	7f 90       	pop	r7
    412a:	6f 90       	pop	r6
    412c:	5f 90       	pop	r5
    412e:	4f 90       	pop	r4
    4130:	08 95       	ret

00004132 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4132:	ef 92       	push	r14
    4134:	ff 92       	push	r15
    4136:	0f 93       	push	r16
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    4138:	86 ec       	ldi	r24, 0xC6	; 198
    413a:	9e e1       	ldi	r25, 0x1E	; 30
    413c:	60 e6       	ldi	r22, 0x60	; 96
    413e:	70 e0       	ldi	r23, 0x00	; 0
    4140:	45 e5       	ldi	r20, 0x55	; 85
    4142:	50 e0       	ldi	r21, 0x00	; 0
    4144:	20 e0       	ldi	r18, 0x00	; 0
    4146:	30 e0       	ldi	r19, 0x00	; 0
    4148:	00 e0       	ldi	r16, 0x00	; 0
    414a:	e0 eb       	ldi	r30, 0xB0	; 176
    414c:	ee 2e       	mov	r14, r30
    414e:	e6 e0       	ldi	r30, 0x06	; 6
    4150:	fe 2e       	mov	r15, r30
    4152:	0e 94 67 1f 	call	0x3ece	; 0x3ece <xTaskCreate>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    4156:	81 30       	cpi	r24, 0x01	; 1
    4158:	81 f4       	brne	.+32     	; 0x417a <vTaskStartScheduler+0x48>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    415a:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    415c:	8f ef       	ldi	r24, 0xFF	; 255
    415e:	9f ef       	ldi	r25, 0xFF	; 255
    4160:	90 93 aa 06 	sts	0x06AA, r25
    4164:	80 93 a9 06 	sts	0x06A9, r24
        xSchedulerRunning = pdTRUE;
    4168:	81 e0       	ldi	r24, 0x01	; 1
    416a:	80 93 af 06 	sts	0x06AF, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    416e:	10 92 a8 06 	sts	0x06A8, r1
    4172:	10 92 a7 06 	sts	0x06A7, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    4176:	0e 94 c1 0b 	call	0x1782	; 0x1782 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    417a:	80 91 e9 00 	lds	r24, 0x00E9
}
    417e:	0f 91       	pop	r16
    4180:	ff 90       	pop	r15
    4182:	ef 90       	pop	r14
    4184:	08 95       	ret

00004186 <WaitingForLCD>:
void APP_VidGet_PASS_From_Keypad(void*pv);
void APP_VidCheckOnPASS(void *pv);
//void APP_VidView_Menu(void *pv);


void WaitingForLCD(u8 *FlagToWait, u8 *Counter){
    4186:	0f 93       	push	r16
    4188:	1f 93       	push	r17
    418a:	cf 93       	push	r28
    418c:	df 93       	push	r29
    418e:	8c 01       	movw	r16, r24
    4190:	eb 01       	movw	r28, r22
	if (*FlagToWait==1){
    4192:	fc 01       	movw	r30, r24
    4194:	80 81       	ld	r24, Z
    4196:	81 30       	cpi	r24, 0x01	; 1
    4198:	a9 f4       	brne	.+42     	; 0x41c4 <WaitingForLCD+0x3e>
		*Counter+=1;
    419a:	88 81       	ld	r24, Y
    419c:	8f 5f       	subi	r24, 0xFF	; 255
    419e:	88 83       	st	Y, r24
	}
	else {
		return;
	}
	if(*Counter == 20){
    41a0:	84 31       	cpi	r24, 0x14	; 20
    41a2:	81 f4       	brne	.+32     	; 0x41c4 <WaitingForLCD+0x3e>
		xSemaphoreGive(LCDSem);
    41a4:	80 91 3f 07 	lds	r24, 0x073F
    41a8:	90 91 40 07 	lds	r25, 0x0740
    41ac:	60 e0       	ldi	r22, 0x00	; 0
    41ae:	70 e0       	ldi	r23, 0x00	; 0
    41b0:	40 e0       	ldi	r20, 0x00	; 0
    41b2:	50 e0       	ldi	r21, 0x00	; 0
    41b4:	20 e0       	ldi	r18, 0x00	; 0
    41b6:	0e 94 0c 10 	call	0x2018	; 0x2018 <xQueueGenericSend>
		Is_Printed=0;
    41ba:	10 92 38 07 	sts	0x0738, r1
		*Counter=0;
    41be:	18 82       	st	Y, r1
		*FlagToWait=0;
    41c0:	f8 01       	movw	r30, r16
    41c2:	10 82       	st	Z, r1
		return;
	}
}
    41c4:	df 91       	pop	r29
    41c6:	cf 91       	pop	r28
    41c8:	1f 91       	pop	r17
    41ca:	0f 91       	pop	r16
    41cc:	08 95       	ret

000041ce <APP_VidCheckOnPASS>:
		}
		WaitingForLCD(&flagToWait,&Counter);
		vTaskDelay(100);
	}
}
void APP_VidCheckOnPASS(void *pv){
    41ce:	cf 92       	push	r12
    41d0:	df 92       	push	r13
    41d2:	ef 92       	push	r14
    41d4:	ff 92       	push	r15
    41d6:	1f 93       	push	r17
    41d8:	df 93       	push	r29
    41da:	cf 93       	push	r28
    41dc:	00 d0       	rcall	.+0      	; 0x41de <APP_VidCheckOnPASS+0x10>
    41de:	0f 92       	push	r0
    41e0:	cd b7       	in	r28, 0x3d	; 61
    41e2:	de b7       	in	r29, 0x3e	; 62
	u16 PASS_Message;
	u8 Loc_u8IDMessageState;
	u8 Loc_u8PASSMessageState;
	u8 Loc_u8Count=0;
    41e4:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		Loc_u8PASSMessageState=xQueueReceive(PASS_KPD_Message,&PASS_Message,10);
    41e6:	22 e0       	ldi	r18, 0x02	; 2
    41e8:	c2 2e       	mov	r12, r18
    41ea:	d1 2c       	mov	r13, r1
    41ec:	cc 0e       	add	r12, r28
    41ee:	dd 1e       	adc	r13, r29
		if(Loc_u8PASSMessageState==pdPASS)
		{
			Loc_u8IDMessageState=xQueueReceive(ID_Index_Message,&Loc_u8Count,10);
    41f0:	7e 01       	movw	r14, r28
    41f2:	08 94       	sec
    41f4:	e1 1c       	adc	r14, r1
    41f6:	f1 1c       	adc	r15, r1
	u8 Loc_u8IDMessageState;
	u8 Loc_u8PASSMessageState;
	u8 Loc_u8Count=0;
	while(1)
	{
		Loc_u8PASSMessageState=xQueueReceive(PASS_KPD_Message,&PASS_Message,10);
    41f8:	80 91 6d 07 	lds	r24, 0x076D
    41fc:	90 91 6e 07 	lds	r25, 0x076E
    4200:	b6 01       	movw	r22, r12
    4202:	4a e0       	ldi	r20, 0x0A	; 10
    4204:	50 e0       	ldi	r21, 0x00	; 0
    4206:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <xQueueReceive>
		if(Loc_u8PASSMessageState==pdPASS)
    420a:	81 30       	cpi	r24, 0x01	; 1
    420c:	09 f0       	breq	.+2      	; 0x4210 <APP_VidCheckOnPASS+0x42>
    420e:	44 c0       	rjmp	.+136    	; 0x4298 <APP_VidCheckOnPASS+0xca>
		{
			Loc_u8IDMessageState=xQueueReceive(ID_Index_Message,&Loc_u8Count,10);
    4210:	80 91 71 07 	lds	r24, 0x0771
    4214:	90 91 72 07 	lds	r25, 0x0772
    4218:	b7 01       	movw	r22, r14
    421a:	4a e0       	ldi	r20, 0x0A	; 10
    421c:	50 e0       	ldi	r21, 0x00	; 0
    421e:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <xQueueReceive>
    4222:	18 2f       	mov	r17, r24
			if(Loc_u8IDMessageState==pdPASS)
    4224:	81 30       	cpi	r24, 0x01	; 1
    4226:	c1 f5       	brne	.+112    	; 0x4298 <APP_VidCheckOnPASS+0xca>
			{
				if(Customers[Loc_u8Count].Password==PASS_Message)
    4228:	e9 81       	ldd	r30, Y+1	; 0x01
    422a:	f0 e0       	ldi	r31, 0x00	; 0
    422c:	93 e0       	ldi	r25, 0x03	; 3
    422e:	ee 0f       	add	r30, r30
    4230:	ff 1f       	adc	r31, r31
    4232:	9a 95       	dec	r25
    4234:	e1 f7       	brne	.-8      	; 0x422e <APP_VidCheckOnPASS+0x60>
    4236:	e9 5b       	subi	r30, 0xB9	; 185
    4238:	f8 4f       	sbci	r31, 0xF8	; 248
    423a:	20 81       	ld	r18, Z
    423c:	31 81       	ldd	r19, Z+1	; 0x01
    423e:	8a 81       	ldd	r24, Y+2	; 0x02
    4240:	9b 81       	ldd	r25, Y+3	; 0x03
    4242:	28 17       	cp	r18, r24
    4244:	39 07       	cpc	r19, r25
    4246:	01 f5       	brne	.+64     	; 0x4288 <APP_VidCheckOnPASS+0xba>
				{
					HLCD_voidClearDisplay();
    4248:	0e 94 87 06 	call	0xd0e	; 0xd0e <HLCD_voidClearDisplay>
					HLCD_voidSendString("Please wait....");
    424c:	85 e6       	ldi	r24, 0x65	; 101
    424e:	90 e0       	ldi	r25, 0x00	; 0
    4250:	0e 94 0f 06 	call	0xc1e	; 0xc1e <HLCD_voidSendString>
					HLCD_voidClearDisplay();
    4254:	0e 94 87 06 	call	0xd0e	; 0xd0e <HLCD_voidClearDisplay>
					HLCD_voidSendString("Your balance is:");
    4258:	85 e7       	ldi	r24, 0x75	; 117
    425a:	90 e0       	ldi	r25, 0x00	; 0
    425c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <HLCD_voidSendString>
					HLCD_voidSetPosition(1,6);
    4260:	81 e0       	ldi	r24, 0x01	; 1
    4262:	66 e0       	ldi	r22, 0x06	; 6
    4264:	0e 94 6f 06 	call	0xcde	; 0xcde <HLCD_voidSetPosition>
					HLCD_voidSendNumber(Customers[Loc_u8Count].Balance);
    4268:	e9 81       	ldd	r30, Y+1	; 0x01
    426a:	f0 e0       	ldi	r31, 0x00	; 0
    426c:	83 e0       	ldi	r24, 0x03	; 3
    426e:	ee 0f       	add	r30, r30
    4270:	ff 1f       	adc	r31, r31
    4272:	8a 95       	dec	r24
    4274:	e1 f7       	brne	.-8      	; 0x426e <APP_VidCheckOnPASS+0xa0>
    4276:	e7 5b       	subi	r30, 0xB7	; 183
    4278:	f8 4f       	sbci	r31, 0xF8	; 248
    427a:	60 81       	ld	r22, Z
    427c:	71 81       	ldd	r23, Z+1	; 0x01
    427e:	82 81       	ldd	r24, Z+2	; 0x02
    4280:	93 81       	ldd	r25, Z+3	; 0x03
    4282:	0e 94 b1 05 	call	0xb62	; 0xb62 <HLCD_voidSendNumber>
    4286:	06 c0       	rjmp	.+12     	; 0x4294 <APP_VidCheckOnPASS+0xc6>
					flagToWait=1;

				}
				else
				{
					HLCD_voidClearDisplay();
    4288:	0e 94 87 06 	call	0xd0e	; 0xd0e <HLCD_voidClearDisplay>
					HLCD_voidSendString("Pass IS NOTVALID");
    428c:	86 e8       	ldi	r24, 0x86	; 134
    428e:	90 e0       	ldi	r25, 0x00	; 0
    4290:	0e 94 0f 06 	call	0xc1e	; 0xc1e <HLCD_voidSendString>
					flagToWait=1;
    4294:	10 93 36 07 	sts	0x0736, r17
		}
		else
		{
			/* Do Nothing */
		}
		WaitingForLCD(&flagToWait,&Counter);
    4298:	86 e3       	ldi	r24, 0x36	; 54
    429a:	97 e0       	ldi	r25, 0x07	; 7
    429c:	67 e3       	ldi	r22, 0x37	; 55
    429e:	77 e0       	ldi	r23, 0x07	; 7
    42a0:	0e 94 c3 20 	call	0x4186	; 0x4186 <WaitingForLCD>
		vTaskDelay(100);
    42a4:	84 e6       	ldi	r24, 0x64	; 100
    42a6:	90 e0       	ldi	r25, 0x00	; 0
    42a8:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <vTaskDelay>
    42ac:	a5 cf       	rjmp	.-182    	; 0x41f8 <APP_VidCheckOnPASS+0x2a>

000042ae <APP_VidGet_PASS_From_Keypad>:
		WaitingForLCD(&flagToWait,&Counter);
		vTaskDelay(200);
	}
}
void APP_VidGet_PASS_From_Keypad(void *pv)
{
    42ae:	7f 92       	push	r7
    42b0:	8f 92       	push	r8
    42b2:	9f 92       	push	r9
    42b4:	af 92       	push	r10
    42b6:	bf 92       	push	r11
    42b8:	cf 92       	push	r12
    42ba:	df 92       	push	r13
    42bc:	ef 92       	push	r14
    42be:	ff 92       	push	r15
    42c0:	0f 93       	push	r16
    42c2:	1f 93       	push	r17
    42c4:	df 93       	push	r29
    42c6:	cf 93       	push	r28
    42c8:	cd b7       	in	r28, 0x3d	; 61
    42ca:	de b7       	in	r29, 0x3e	; 62
    42cc:	27 97       	sbiw	r28, 0x07	; 7
    42ce:	0f b6       	in	r0, 0x3f	; 63
    42d0:	f8 94       	cli
    42d2:	de bf       	out	0x3e, r29	; 62
    42d4:	0f be       	out	0x3f, r0	; 63
    42d6:	cd bf       	out	0x3d, r28	; 61
	u8 Loc_u8PASSSemState;
	u8 Loc_u8KeyPressed=HKEYPAD_NO_PRESSED_KEY;
	u8 PASS[5]={HKEYPAD_NO_PRESSED_KEY};
    42d8:	fe 01       	movw	r30, r28
    42da:	33 96       	adiw	r30, 0x03	; 3
    42dc:	85 e0       	ldi	r24, 0x05	; 5
    42de:	df 01       	movw	r26, r30
    42e0:	1d 92       	st	X+, r1
    42e2:	8a 95       	dec	r24
    42e4:	e9 f7       	brne	.-6      	; 0x42e0 <APP_VidGet_PASS_From_Keypad+0x32>
    42e6:	8f ef       	ldi	r24, 0xFF	; 255
    42e8:	8b 83       	std	Y+3, r24	; 0x03
    42ea:	00 e0       	ldi	r16, 0x00	; 0
			else{
				// ERROR ENTRY -> GO BACK TO HOME PAGE
				HLCD_voidClearDisplay();
				HLCD_voidSendString("INVALID ENTRY...");
				Loc_Count=0;
				flagToWait=1;
    42ec:	77 24       	eor	r7, r7
    42ee:	73 94       	inc	r7
					Loc_Count++;
				}
				xSemaphoreGive(PassSem);
			}
			else if(Loc_u8KeyPressed == 'E' && (Loc_Count == 4)) {
				Loc_u16PASS=((PASS[0])*1000)+((PASS[1])*100)+((PASS[2])*10)+((PASS[3]));
    42f0:	58 ee       	ldi	r21, 0xE8	; 232
    42f2:	a5 2e       	mov	r10, r21
    42f4:	53 e0       	ldi	r21, 0x03	; 3
    42f6:	b5 2e       	mov	r11, r21
    42f8:	44 e6       	ldi	r20, 0x64	; 100
    42fa:	84 2e       	mov	r8, r20
    42fc:	3a e0       	ldi	r19, 0x0A	; 10
    42fe:	93 2e       	mov	r9, r19
				xQueueSend(PASS_KPD_Message,&Loc_u16PASS,10);
    4300:	6e 01       	movw	r12, r28
    4302:	08 94       	sec
    4304:	c1 1c       	adc	r12, r1
    4306:	d1 1c       	adc	r13, r1
			Loc_u8KeyPressed=HKEYPAD_u8GetPressedKey();
			if ((Loc_u8KeyPressed != 'E') && (Loc_Count < 5)){
				if(Loc_u8KeyPressed != HKEYPAD_NO_PRESSED_KEY){
					HLCD_voidSendNumber(Loc_u8KeyPressed);
					//HLCD_voidSendData('*');
					PASS[Loc_Count]=Loc_u8KeyPressed;
    4308:	7f 01       	movw	r14, r30
	u16 Loc_u16PASS;
	u8 Loc_Count=0;

	while(1)
	{
		Loc_u8PASSSemState=xSemaphoreTake(PassSem,10);
    430a:	80 91 43 07 	lds	r24, 0x0743
    430e:	90 91 44 07 	lds	r25, 0x0744
    4312:	6a e0       	ldi	r22, 0x0A	; 10
    4314:	70 e0       	ldi	r23, 0x00	; 0
    4316:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <xQueueSemaphoreTake>
		if(Loc_u8PASSSemState==pdPASS)
    431a:	81 30       	cpi	r24, 0x01	; 1
    431c:	09 f0       	breq	.+2      	; 0x4320 <APP_VidGet_PASS_From_Keypad+0x72>
    431e:	51 c0       	rjmp	.+162    	; 0x43c2 <APP_VidGet_PASS_From_Keypad+0x114>
		{
			Loc_u8KeyPressed=HKEYPAD_u8GetPressedKey();
    4320:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <HKEYPAD_u8GetPressedKey>
    4324:	18 2f       	mov	r17, r24
			if ((Loc_u8KeyPressed != 'E') && (Loc_Count < 5)){
    4326:	85 34       	cpi	r24, 0x45	; 69
    4328:	e1 f0       	breq	.+56     	; 0x4362 <APP_VidGet_PASS_From_Keypad+0xb4>
    432a:	05 30       	cpi	r16, 0x05	; 5
    432c:	08 f0       	brcs	.+2      	; 0x4330 <APP_VidGet_PASS_From_Keypad+0x82>
    432e:	40 c0       	rjmp	.+128    	; 0x43b0 <APP_VidGet_PASS_From_Keypad+0x102>
				if(Loc_u8KeyPressed != HKEYPAD_NO_PRESSED_KEY){
    4330:	8f 3f       	cpi	r24, 0xFF	; 255
    4332:	59 f0       	breq	.+22     	; 0x434a <APP_VidGet_PASS_From_Keypad+0x9c>
					HLCD_voidSendNumber(Loc_u8KeyPressed);
    4334:	68 2f       	mov	r22, r24
    4336:	70 e0       	ldi	r23, 0x00	; 0
    4338:	80 e0       	ldi	r24, 0x00	; 0
    433a:	90 e0       	ldi	r25, 0x00	; 0
    433c:	0e 94 b1 05 	call	0xb62	; 0xb62 <HLCD_voidSendNumber>
					//HLCD_voidSendData('*');
					PASS[Loc_Count]=Loc_u8KeyPressed;
    4340:	f7 01       	movw	r30, r14
    4342:	e0 0f       	add	r30, r16
    4344:	f1 1d       	adc	r31, r1
    4346:	10 83       	st	Z, r17
					Loc_Count++;
    4348:	0f 5f       	subi	r16, 0xFF	; 255
				}
				xSemaphoreGive(PassSem);
    434a:	80 91 43 07 	lds	r24, 0x0743
    434e:	90 91 44 07 	lds	r25, 0x0744
    4352:	60 e0       	ldi	r22, 0x00	; 0
    4354:	70 e0       	ldi	r23, 0x00	; 0
    4356:	40 e0       	ldi	r20, 0x00	; 0
    4358:	50 e0       	ldi	r21, 0x00	; 0
    435a:	20 e0       	ldi	r18, 0x00	; 0
    435c:	0e 94 0c 10 	call	0x2018	; 0x2018 <xQueueGenericSend>
    4360:	30 c0       	rjmp	.+96     	; 0x43c2 <APP_VidGet_PASS_From_Keypad+0x114>
			}
			else if(Loc_u8KeyPressed == 'E' && (Loc_Count == 4)) {
    4362:	04 30       	cpi	r16, 0x04	; 4
    4364:	29 f5       	brne	.+74     	; 0x43b0 <APP_VidGet_PASS_From_Keypad+0x102>
				Loc_u16PASS=((PASS[0])*1000)+((PASS[1])*100)+((PASS[2])*10)+((PASS[3]));
    4366:	8b 81       	ldd	r24, Y+3	; 0x03
    4368:	90 e0       	ldi	r25, 0x00	; 0
    436a:	8a 9d       	mul	r24, r10
    436c:	90 01       	movw	r18, r0
    436e:	8b 9d       	mul	r24, r11
    4370:	30 0d       	add	r19, r0
    4372:	9a 9d       	mul	r25, r10
    4374:	30 0d       	add	r19, r0
    4376:	11 24       	eor	r1, r1
    4378:	8c 81       	ldd	r24, Y+4	; 0x04
    437a:	88 9d       	mul	r24, r8
    437c:	c0 01       	movw	r24, r0
    437e:	11 24       	eor	r1, r1
    4380:	28 0f       	add	r18, r24
    4382:	39 1f       	adc	r19, r25
    4384:	8e 81       	ldd	r24, Y+6	; 0x06
    4386:	28 0f       	add	r18, r24
    4388:	31 1d       	adc	r19, r1
    438a:	8d 81       	ldd	r24, Y+5	; 0x05
    438c:	89 9d       	mul	r24, r9
    438e:	c0 01       	movw	r24, r0
    4390:	11 24       	eor	r1, r1
    4392:	28 0f       	add	r18, r24
    4394:	39 1f       	adc	r19, r25
    4396:	3a 83       	std	Y+2, r19	; 0x02
    4398:	29 83       	std	Y+1, r18	; 0x01
				xQueueSend(PASS_KPD_Message,&Loc_u16PASS,10);
    439a:	80 91 6d 07 	lds	r24, 0x076D
    439e:	90 91 6e 07 	lds	r25, 0x076E
    43a2:	b6 01       	movw	r22, r12
    43a4:	4a e0       	ldi	r20, 0x0A	; 10
    43a6:	50 e0       	ldi	r21, 0x00	; 0
    43a8:	20 e0       	ldi	r18, 0x00	; 0
    43aa:	0e 94 0c 10 	call	0x2018	; 0x2018 <xQueueGenericSend>
    43ae:	08 c0       	rjmp	.+16     	; 0x43c0 <APP_VidGet_PASS_From_Keypad+0x112>
				Loc_Count=0;
			}
			else{
				// ERROR ENTRY -> GO BACK TO HOME PAGE
				HLCD_voidClearDisplay();
    43b0:	0e 94 87 06 	call	0xd0e	; 0xd0e <HLCD_voidClearDisplay>
				HLCD_voidSendString("INVALID ENTRY...");
    43b4:	87 e9       	ldi	r24, 0x97	; 151
    43b6:	90 e0       	ldi	r25, 0x00	; 0
    43b8:	0e 94 0f 06 	call	0xc1e	; 0xc1e <HLCD_voidSendString>
				Loc_Count=0;
				flagToWait=1;
    43bc:	70 92 36 07 	sts	0x0736, r7
    43c0:	00 e0       	ldi	r16, 0x00	; 0
		}
		else
		{
			/*Do Nothing*/
		}
		WaitingForLCD(&flagToWait,&Counter);
    43c2:	86 e3       	ldi	r24, 0x36	; 54
    43c4:	97 e0       	ldi	r25, 0x07	; 7
    43c6:	67 e3       	ldi	r22, 0x37	; 55
    43c8:	77 e0       	ldi	r23, 0x07	; 7
    43ca:	0e 94 c3 20 	call	0x4186	; 0x4186 <WaitingForLCD>
		vTaskDelay(100);
    43ce:	84 e6       	ldi	r24, 0x64	; 100
    43d0:	90 e0       	ldi	r25, 0x00	; 0
    43d2:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <vTaskDelay>
    43d6:	99 cf       	rjmp	.-206    	; 0x430a <APP_VidGet_PASS_From_Keypad+0x5c>

000043d8 <APP_VidCheckOnID>:
		WaitingForLCD(&flagToWait,&Counter);
		vTaskDelay(100);
	}
}
void APP_VidCheckOnID(void *pv)
{
    43d8:	cf 92       	push	r12
    43da:	df 92       	push	r13
    43dc:	ef 92       	push	r14
    43de:	ff 92       	push	r15
    43e0:	0f 93       	push	r16
    43e2:	1f 93       	push	r17
    43e4:	df 93       	push	r29
    43e6:	cf 93       	push	r28
    43e8:	00 d0       	rcall	.+0      	; 0x43ea <APP_VidCheckOnID+0x12>
    43ea:	0f 92       	push	r0
    43ec:	cd b7       	in	r28, 0x3d	; 61
    43ee:	de b7       	in	r29, 0x3e	; 62
	u16 ID_Message;
	u8 Loc_u8MessageState;
	u8 Loc_u8Count=0;
    43f0:	19 82       	std	Y+1, r1	; 0x01
    43f2:	10 e0       	ldi	r17, 0x00	; 0
	u8 Loc_u8Flag=0;
	while(1)
	{
		Loc_u8MessageState=xQueueReceive(ID_KPD_Message,&ID_Message,10);
    43f4:	72 e0       	ldi	r23, 0x02	; 2
    43f6:	c7 2e       	mov	r12, r23
    43f8:	d1 2c       	mov	r13, r1
    43fa:	cc 0e       	add	r12, r28
    43fc:	dd 1e       	adc	r13, r29
			Loc_u8Count=0;
			if(Loc_u8Flag==0)
			{
				HLCD_voidClearDisplay();
				HLCD_voidSendString("ID IS NOT VALID..");
				flagToWait=1;
    43fe:	01 e0       	ldi	r16, 0x01	; 1
				{
					HLCD_voidClearDisplay();
					HLCD_voidSendString("Enter Pass:");
					HLCD_voidSetPosition(1,6);
					Loc_u8Flag=1;
					xQueueSend(ID_Index_Message,&Loc_u8Count,10);
    4400:	7e 01       	movw	r14, r28
    4402:	08 94       	sec
    4404:	e1 1c       	adc	r14, r1
    4406:	f1 1c       	adc	r15, r1
	u8 Loc_u8MessageState;
	u8 Loc_u8Count=0;
	u8 Loc_u8Flag=0;
	while(1)
	{
		Loc_u8MessageState=xQueueReceive(ID_KPD_Message,&ID_Message,10);
    4408:	80 91 6f 07 	lds	r24, 0x076F
    440c:	90 91 70 07 	lds	r25, 0x0770
    4410:	b6 01       	movw	r22, r12
    4412:	4a e0       	ldi	r20, 0x0A	; 10
    4414:	50 e0       	ldi	r21, 0x00	; 0
    4416:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <xQueueReceive>
		if(Loc_u8MessageState==pdPASS)
    441a:	81 30       	cpi	r24, 0x01	; 1
    441c:	09 f0       	breq	.+2      	; 0x4420 <APP_VidCheckOnID+0x48>
    441e:	47 c0       	rjmp	.+142    	; 0x44ae <APP_VidCheckOnID+0xd6>
		{

			while(Customers[Loc_u8Count].ID!=0)
			{
				if(Customers[Loc_u8Count].ID==ID_Message)
    4420:	2a 81       	ldd	r18, Y+2	; 0x02
    4422:	3b 81       	ldd	r19, Y+3	; 0x03
    4424:	89 81       	ldd	r24, Y+1	; 0x01
    4426:	28 c0       	rjmp	.+80     	; 0x4478 <APP_VidCheckOnID+0xa0>
    4428:	98 2f       	mov	r25, r24
    442a:	9f 5f       	subi	r25, 0xFF	; 255
    442c:	e2 17       	cp	r30, r18
    442e:	f3 07       	cpc	r31, r19
    4430:	11 f5       	brne	.+68     	; 0x4476 <APP_VidCheckOnID+0x9e>
    4432:	89 83       	std	Y+1, r24	; 0x01
				{
					HLCD_voidClearDisplay();
    4434:	0e 94 87 06 	call	0xd0e	; 0xd0e <HLCD_voidClearDisplay>
					HLCD_voidSendString("Enter Pass:");
    4438:	88 ea       	ldi	r24, 0xA8	; 168
    443a:	90 e0       	ldi	r25, 0x00	; 0
    443c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <HLCD_voidSendString>
					HLCD_voidSetPosition(1,6);
    4440:	81 e0       	ldi	r24, 0x01	; 1
    4442:	66 e0       	ldi	r22, 0x06	; 6
    4444:	0e 94 6f 06 	call	0xcde	; 0xcde <HLCD_voidSetPosition>
					Loc_u8Flag=1;
					xQueueSend(ID_Index_Message,&Loc_u8Count,10);
    4448:	80 91 71 07 	lds	r24, 0x0771
    444c:	90 91 72 07 	lds	r25, 0x0772
    4450:	b7 01       	movw	r22, r14
    4452:	4a e0       	ldi	r20, 0x0A	; 10
    4454:	50 e0       	ldi	r21, 0x00	; 0
    4456:	20 e0       	ldi	r18, 0x00	; 0
    4458:	0e 94 0c 10 	call	0x2018	; 0x2018 <xQueueGenericSend>
					xSemaphoreGive(PassSem);
    445c:	80 91 43 07 	lds	r24, 0x0743
    4460:	90 91 44 07 	lds	r25, 0x0744
    4464:	60 e0       	ldi	r22, 0x00	; 0
    4466:	70 e0       	ldi	r23, 0x00	; 0
    4468:	40 e0       	ldi	r20, 0x00	; 0
    446a:	50 e0       	ldi	r21, 0x00	; 0
    446c:	20 e0       	ldi	r18, 0x00	; 0
    446e:	0e 94 0c 10 	call	0x2018	; 0x2018 <xQueueGenericSend>
    4472:	11 e0       	ldi	r17, 0x01	; 1
    4474:	0f c0       	rjmp	.+30     	; 0x4494 <APP_VidCheckOnID+0xbc>
					break;
    4476:	89 2f       	mov	r24, r25
	{
		Loc_u8MessageState=xQueueReceive(ID_KPD_Message,&ID_Message,10);
		if(Loc_u8MessageState==pdPASS)
		{

			while(Customers[Loc_u8Count].ID!=0)
    4478:	e8 2f       	mov	r30, r24
    447a:	f0 e0       	ldi	r31, 0x00	; 0
    447c:	63 e0       	ldi	r22, 0x03	; 3
    447e:	ee 0f       	add	r30, r30
    4480:	ff 1f       	adc	r31, r31
    4482:	6a 95       	dec	r22
    4484:	e1 f7       	brne	.-8      	; 0x447e <APP_VidCheckOnID+0xa6>
    4486:	eb 5b       	subi	r30, 0xBB	; 187
    4488:	f8 4f       	sbci	r31, 0xF8	; 248
    448a:	01 90       	ld	r0, Z+
    448c:	f0 81       	ld	r31, Z
    448e:	e0 2d       	mov	r30, r0
    4490:	30 97       	sbiw	r30, 0x00	; 0
    4492:	51 f6       	brne	.-108    	; 0x4428 <APP_VidCheckOnID+0x50>
				{
					//Do Nothing
				}
				Loc_u8Count++;
			}
			Loc_u8Count=0;
    4494:	19 82       	std	Y+1, r1	; 0x01
			if(Loc_u8Flag==0)
    4496:	11 23       	and	r17, r17
    4498:	11 f0       	breq	.+4      	; 0x449e <APP_VidCheckOnID+0xc6>
    449a:	11 e0       	ldi	r17, 0x01	; 1
    449c:	08 c0       	rjmp	.+16     	; 0x44ae <APP_VidCheckOnID+0xd6>
			{
				HLCD_voidClearDisplay();
    449e:	0e 94 87 06 	call	0xd0e	; 0xd0e <HLCD_voidClearDisplay>
				HLCD_voidSendString("ID IS NOT VALID..");
    44a2:	84 eb       	ldi	r24, 0xB4	; 180
    44a4:	90 e0       	ldi	r25, 0x00	; 0
    44a6:	0e 94 0f 06 	call	0xc1e	; 0xc1e <HLCD_voidSendString>
				flagToWait=1;
    44aa:	00 93 36 07 	sts	0x0736, r16
			else
			{
				//Do Nothing
			}
		}
		WaitingForLCD(&flagToWait,&Counter);
    44ae:	86 e3       	ldi	r24, 0x36	; 54
    44b0:	97 e0       	ldi	r25, 0x07	; 7
    44b2:	67 e3       	ldi	r22, 0x37	; 55
    44b4:	77 e0       	ldi	r23, 0x07	; 7
    44b6:	0e 94 c3 20 	call	0x4186	; 0x4186 <WaitingForLCD>
		vTaskDelay(200);
    44ba:	88 ec       	ldi	r24, 0xC8	; 200
    44bc:	90 e0       	ldi	r25, 0x00	; 0
    44be:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <vTaskDelay>
    44c2:	a2 cf       	rjmp	.-188    	; 0x4408 <APP_VidCheckOnID+0x30>

000044c4 <APP_VidGet_ID_From_Keypad>:
		vTaskDelay(20);
	}

}
void APP_VidGet_ID_From_Keypad(void *pv)
{
    44c4:	7f 92       	push	r7
    44c6:	8f 92       	push	r8
    44c8:	9f 92       	push	r9
    44ca:	af 92       	push	r10
    44cc:	bf 92       	push	r11
    44ce:	cf 92       	push	r12
    44d0:	df 92       	push	r13
    44d2:	ef 92       	push	r14
    44d4:	ff 92       	push	r15
    44d6:	0f 93       	push	r16
    44d8:	1f 93       	push	r17
    44da:	df 93       	push	r29
    44dc:	cf 93       	push	r28
    44de:	cd b7       	in	r28, 0x3d	; 61
    44e0:	de b7       	in	r29, 0x3e	; 62
    44e2:	27 97       	sbiw	r28, 0x07	; 7
    44e4:	0f b6       	in	r0, 0x3f	; 63
    44e6:	f8 94       	cli
    44e8:	de bf       	out	0x3e, r29	; 62
    44ea:	0f be       	out	0x3f, r0	; 63
    44ec:	cd bf       	out	0x3d, r28	; 61
	u8 Loc_u8CardSemState;
	u8 Loc_u8KeyPressed=HKEYPAD_NO_PRESSED_KEY;
	u8 ID[5]={HKEYPAD_NO_PRESSED_KEY};
    44ee:	fe 01       	movw	r30, r28
    44f0:	33 96       	adiw	r30, 0x03	; 3
    44f2:	85 e0       	ldi	r24, 0x05	; 5
    44f4:	df 01       	movw	r26, r30
    44f6:	1d 92       	st	X+, r1
    44f8:	8a 95       	dec	r24
    44fa:	e9 f7       	brne	.-6      	; 0x44f6 <APP_VidGet_ID_From_Keypad+0x32>
    44fc:	8f ef       	ldi	r24, 0xFF	; 255
    44fe:	8b 83       	std	Y+3, r24	; 0x03
    4500:	00 e0       	ldi	r16, 0x00	; 0
			else{
				// ERROR ENTRY -> GO BACK TO HOME PAGE
				HLCD_voidClearDisplay();
				HLCD_voidSendString("INVALID ENTRY...");
				Loc_Count=0;
				flagToWait=1;
    4502:	77 24       	eor	r7, r7
    4504:	73 94       	inc	r7
					Loc_Count++;
				}
				xSemaphoreGive(CardSem);
			}
			else if(Loc_u8KeyPressed == 'E' && (Loc_Count == 4)) {
				Loc_u16ID=((ID[0])*1000)+((ID[1])*100)+((ID[2])*10)+((ID[3]));
    4506:	18 ee       	ldi	r17, 0xE8	; 232
    4508:	a1 2e       	mov	r10, r17
    450a:	13 e0       	ldi	r17, 0x03	; 3
    450c:	b1 2e       	mov	r11, r17
    450e:	b4 e6       	ldi	r27, 0x64	; 100
    4510:	8b 2e       	mov	r8, r27
    4512:	aa e0       	ldi	r26, 0x0A	; 10
    4514:	9a 2e       	mov	r9, r26
				xQueueSend(ID_KPD_Message,&Loc_u16ID,10);
    4516:	6e 01       	movw	r12, r28
    4518:	08 94       	sec
    451a:	c1 1c       	adc	r12, r1
    451c:	d1 1c       	adc	r13, r1
		{
			Loc_u8KeyPressed=HKEYPAD_u8GetPressedKey();
			if ((Loc_u8KeyPressed != 'E') && (Loc_Count < 5)){
				if(Loc_u8KeyPressed != HKEYPAD_NO_PRESSED_KEY){
					HLCD_voidSendNumber(Loc_u8KeyPressed);
					ID[Loc_Count]=Loc_u8KeyPressed;
    451e:	7f 01       	movw	r14, r30
	u8 ID[5]={HKEYPAD_NO_PRESSED_KEY};
	u16 Loc_u16ID;
	u8 Loc_Count=0;
	while(1)
	{
		Loc_u8CardSemState=xSemaphoreTake(CardSem,10);
    4520:	80 91 41 07 	lds	r24, 0x0741
    4524:	90 91 42 07 	lds	r25, 0x0742
    4528:	6a e0       	ldi	r22, 0x0A	; 10
    452a:	70 e0       	ldi	r23, 0x00	; 0
    452c:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <xQueueSemaphoreTake>
		if(Loc_u8CardSemState==pdPASS)
    4530:	81 30       	cpi	r24, 0x01	; 1
    4532:	09 f0       	breq	.+2      	; 0x4536 <APP_VidGet_ID_From_Keypad+0x72>
    4534:	51 c0       	rjmp	.+162    	; 0x45d8 <APP_VidGet_ID_From_Keypad+0x114>
		{
			Loc_u8KeyPressed=HKEYPAD_u8GetPressedKey();
    4536:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <HKEYPAD_u8GetPressedKey>
    453a:	18 2f       	mov	r17, r24
			if ((Loc_u8KeyPressed != 'E') && (Loc_Count < 5)){
    453c:	85 34       	cpi	r24, 0x45	; 69
    453e:	e1 f0       	breq	.+56     	; 0x4578 <APP_VidGet_ID_From_Keypad+0xb4>
    4540:	05 30       	cpi	r16, 0x05	; 5
    4542:	08 f0       	brcs	.+2      	; 0x4546 <APP_VidGet_ID_From_Keypad+0x82>
    4544:	40 c0       	rjmp	.+128    	; 0x45c6 <APP_VidGet_ID_From_Keypad+0x102>
				if(Loc_u8KeyPressed != HKEYPAD_NO_PRESSED_KEY){
    4546:	8f 3f       	cpi	r24, 0xFF	; 255
    4548:	59 f0       	breq	.+22     	; 0x4560 <APP_VidGet_ID_From_Keypad+0x9c>
					HLCD_voidSendNumber(Loc_u8KeyPressed);
    454a:	68 2f       	mov	r22, r24
    454c:	70 e0       	ldi	r23, 0x00	; 0
    454e:	80 e0       	ldi	r24, 0x00	; 0
    4550:	90 e0       	ldi	r25, 0x00	; 0
    4552:	0e 94 b1 05 	call	0xb62	; 0xb62 <HLCD_voidSendNumber>
					ID[Loc_Count]=Loc_u8KeyPressed;
    4556:	f7 01       	movw	r30, r14
    4558:	e0 0f       	add	r30, r16
    455a:	f1 1d       	adc	r31, r1
    455c:	10 83       	st	Z, r17
					Loc_Count++;
    455e:	0f 5f       	subi	r16, 0xFF	; 255
				}
				xSemaphoreGive(CardSem);
    4560:	80 91 41 07 	lds	r24, 0x0741
    4564:	90 91 42 07 	lds	r25, 0x0742
    4568:	60 e0       	ldi	r22, 0x00	; 0
    456a:	70 e0       	ldi	r23, 0x00	; 0
    456c:	40 e0       	ldi	r20, 0x00	; 0
    456e:	50 e0       	ldi	r21, 0x00	; 0
    4570:	20 e0       	ldi	r18, 0x00	; 0
    4572:	0e 94 0c 10 	call	0x2018	; 0x2018 <xQueueGenericSend>
    4576:	30 c0       	rjmp	.+96     	; 0x45d8 <APP_VidGet_ID_From_Keypad+0x114>
			}
			else if(Loc_u8KeyPressed == 'E' && (Loc_Count == 4)) {
    4578:	04 30       	cpi	r16, 0x04	; 4
    457a:	29 f5       	brne	.+74     	; 0x45c6 <APP_VidGet_ID_From_Keypad+0x102>
				Loc_u16ID=((ID[0])*1000)+((ID[1])*100)+((ID[2])*10)+((ID[3]));
    457c:	8b 81       	ldd	r24, Y+3	; 0x03
    457e:	90 e0       	ldi	r25, 0x00	; 0
    4580:	8a 9d       	mul	r24, r10
    4582:	90 01       	movw	r18, r0
    4584:	8b 9d       	mul	r24, r11
    4586:	30 0d       	add	r19, r0
    4588:	9a 9d       	mul	r25, r10
    458a:	30 0d       	add	r19, r0
    458c:	11 24       	eor	r1, r1
    458e:	8c 81       	ldd	r24, Y+4	; 0x04
    4590:	88 9d       	mul	r24, r8
    4592:	c0 01       	movw	r24, r0
    4594:	11 24       	eor	r1, r1
    4596:	28 0f       	add	r18, r24
    4598:	39 1f       	adc	r19, r25
    459a:	8e 81       	ldd	r24, Y+6	; 0x06
    459c:	28 0f       	add	r18, r24
    459e:	31 1d       	adc	r19, r1
    45a0:	8d 81       	ldd	r24, Y+5	; 0x05
    45a2:	89 9d       	mul	r24, r9
    45a4:	c0 01       	movw	r24, r0
    45a6:	11 24       	eor	r1, r1
    45a8:	28 0f       	add	r18, r24
    45aa:	39 1f       	adc	r19, r25
    45ac:	3a 83       	std	Y+2, r19	; 0x02
    45ae:	29 83       	std	Y+1, r18	; 0x01
				xQueueSend(ID_KPD_Message,&Loc_u16ID,10);
    45b0:	80 91 6f 07 	lds	r24, 0x076F
    45b4:	90 91 70 07 	lds	r25, 0x0770
    45b8:	b6 01       	movw	r22, r12
    45ba:	4a e0       	ldi	r20, 0x0A	; 10
    45bc:	50 e0       	ldi	r21, 0x00	; 0
    45be:	20 e0       	ldi	r18, 0x00	; 0
    45c0:	0e 94 0c 10 	call	0x2018	; 0x2018 <xQueueGenericSend>
    45c4:	08 c0       	rjmp	.+16     	; 0x45d6 <APP_VidGet_ID_From_Keypad+0x112>
				Loc_Count=0;
			}
			else{
				// ERROR ENTRY -> GO BACK TO HOME PAGE
				HLCD_voidClearDisplay();
    45c6:	0e 94 87 06 	call	0xd0e	; 0xd0e <HLCD_voidClearDisplay>
				HLCD_voidSendString("INVALID ENTRY...");
    45ca:	87 e9       	ldi	r24, 0x97	; 151
    45cc:	90 e0       	ldi	r25, 0x00	; 0
    45ce:	0e 94 0f 06 	call	0xc1e	; 0xc1e <HLCD_voidSendString>
				Loc_Count=0;
				flagToWait=1;
    45d2:	70 92 36 07 	sts	0x0736, r7
    45d6:	00 e0       	ldi	r16, 0x00	; 0
			}
		}
		WaitingForLCD(&flagToWait,&Counter);
    45d8:	86 e3       	ldi	r24, 0x36	; 54
    45da:	97 e0       	ldi	r25, 0x07	; 7
    45dc:	67 e3       	ldi	r22, 0x37	; 55
    45de:	77 e0       	ldi	r23, 0x07	; 7
    45e0:	0e 94 c3 20 	call	0x4186	; 0x4186 <WaitingForLCD>
		vTaskDelay(100);
    45e4:	84 e6       	ldi	r24, 0x64	; 100
    45e6:	90 e0       	ldi	r25, 0x00	; 0
    45e8:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <vTaskDelay>
    45ec:	99 cf       	rjmp	.-206    	; 0x4520 <APP_VidGet_ID_From_Keypad+0x5c>

000045ee <APP_VidWelcomeTask>:
	{
	}
	return 0;
}
void APP_VidWelcomeTask(void*pv)
{
    45ee:	ef 92       	push	r14
    45f0:	ff 92       	push	r15
    45f2:	1f 93       	push	r17
    45f4:	df 93       	push	r29
    45f6:	cf 93       	push	r28
    45f8:	0f 92       	push	r0
    45fa:	cd b7       	in	r28, 0x3d	; 61
    45fc:	de b7       	in	r29, 0x3e	; 62
	u8 Loc_u8ButtonState=1;
    45fe:	81 e0       	ldi	r24, 0x01	; 1
    4600:	89 83       	std	Y+1, r24	; 0x01
			if (Is_Printed == 0){
				HLCD_voidClearDisplay();
				HLCD_voidSendString("NTI Bank");
				Is_Printed=1;
			}
			DIO_u8GetPinValue(DIO_u8_PORTA,DIO_u8_PIN0,&Loc_u8ButtonState);
    4602:	7e 01       	movw	r14, r28
    4604:	08 94       	sec
    4606:	e1 1c       	adc	r14, r1
    4608:	f1 1c       	adc	r15, r1
{
	u8 Loc_u8ButtonState=1;
	u8 LCDSemState=0;
	while(1)
	{
		LCDSemState=xSemaphoreTake(LCDSem,10);
    460a:	80 91 3f 07 	lds	r24, 0x073F
    460e:	90 91 40 07 	lds	r25, 0x0740
    4612:	6a e0       	ldi	r22, 0x0A	; 10
    4614:	70 e0       	ldi	r23, 0x00	; 0
    4616:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <xQueueSemaphoreTake>
    461a:	18 2f       	mov	r17, r24
		if(LCDSemState==pdPASS)
    461c:	81 30       	cpi	r24, 0x01	; 1
    461e:	71 f5       	brne	.+92     	; 0x467c <APP_VidWelcomeTask+0x8e>
		{
			if (Is_Printed == 0){
    4620:	80 91 38 07 	lds	r24, 0x0738
    4624:	88 23       	and	r24, r24
    4626:	41 f4       	brne	.+16     	; 0x4638 <APP_VidWelcomeTask+0x4a>
				HLCD_voidClearDisplay();
    4628:	0e 94 87 06 	call	0xd0e	; 0xd0e <HLCD_voidClearDisplay>
				HLCD_voidSendString("NTI Bank");
    462c:	86 ec       	ldi	r24, 0xC6	; 198
    462e:	90 e0       	ldi	r25, 0x00	; 0
    4630:	0e 94 0f 06 	call	0xc1e	; 0xc1e <HLCD_voidSendString>
				Is_Printed=1;
    4634:	10 93 38 07 	sts	0x0738, r17
			}
			DIO_u8GetPinValue(DIO_u8_PORTA,DIO_u8_PIN0,&Loc_u8ButtonState);
    4638:	80 e0       	ldi	r24, 0x00	; 0
    463a:	60 e0       	ldi	r22, 0x00	; 0
    463c:	a7 01       	movw	r20, r14
    463e:	0e 94 ab 03 	call	0x756	; 0x756 <DIO_u8GetPinValue>
			if(Loc_u8ButtonState == 0)
    4642:	89 81       	ldd	r24, Y+1	; 0x01
    4644:	88 23       	and	r24, r24
    4646:	79 f4       	brne	.+30     	; 0x4666 <APP_VidWelcomeTask+0x78>
			{
				HLCD_voidClearDisplay();
    4648:	0e 94 87 06 	call	0xd0e	; 0xd0e <HLCD_voidClearDisplay>
				HLCD_voidSendString("Enter ID:");
    464c:	8f ec       	ldi	r24, 0xCF	; 207
    464e:	90 e0       	ldi	r25, 0x00	; 0
    4650:	0e 94 0f 06 	call	0xc1e	; 0xc1e <HLCD_voidSendString>
				HLCD_voidSetPosition(1,6);
    4654:	81 e0       	ldi	r24, 0x01	; 1
    4656:	66 e0       	ldi	r22, 0x06	; 6
    4658:	0e 94 6f 06 	call	0xcde	; 0xcde <HLCD_voidSetPosition>
				xSemaphoreGive(CardSem);
    465c:	80 91 41 07 	lds	r24, 0x0741
    4660:	90 91 42 07 	lds	r25, 0x0742
    4664:	04 c0       	rjmp	.+8      	; 0x466e <APP_VidWelcomeTask+0x80>
			}
			else
			{
				xSemaphoreGive(LCDSem);
    4666:	80 91 3f 07 	lds	r24, 0x073F
    466a:	90 91 40 07 	lds	r25, 0x0740
    466e:	60 e0       	ldi	r22, 0x00	; 0
    4670:	70 e0       	ldi	r23, 0x00	; 0
    4672:	40 e0       	ldi	r20, 0x00	; 0
    4674:	50 e0       	ldi	r21, 0x00	; 0
    4676:	20 e0       	ldi	r18, 0x00	; 0
    4678:	0e 94 0c 10 	call	0x2018	; 0x2018 <xQueueGenericSend>
		}
		else
		{
			/*Do Nothing*/
		}
		vTaskDelay(20);
    467c:	84 e1       	ldi	r24, 0x14	; 20
    467e:	90 e0       	ldi	r25, 0x00	; 0
    4680:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <vTaskDelay>
    4684:	c2 cf       	rjmp	.-124    	; 0x460a <APP_VidWelcomeTask+0x1c>

00004686 <main>:
		*FlagToWait=0;
		return;
	}
}
int main(void)
{
    4686:	ef 92       	push	r14
    4688:	ff 92       	push	r15
    468a:	0f 93       	push	r16

	DIO_voidInit();
    468c:	0e 94 51 02 	call	0x4a2	; 0x4a2 <DIO_voidInit>
	HLCD_voidInit();
    4690:	0e 94 8e 06 	call	0xd1c	; 0xd1c <HLCD_voidInit>
	HKEYPAD_voidInit();
    4694:	0e 94 60 07 	call	0xec0	; 0xec0 <HKEYPAD_voidInit>
	EEPROM_VidInit();
    4698:	0e 94 1a 09 	call	0x1234	; 0x1234 <EEPROM_VidInit>
	EEPROM_write_DataBace (CustomersWrite);
    469c:	8a ee       	ldi	r24, 0xEA	; 234
    469e:	90 e0       	ldi	r25, 0x00	; 0
    46a0:	0e 94 cb 08 	call	0x1196	; 0x1196 <EEPROM_write_DataBace>
	EEPROM_read_DataBace (Customers);
    46a4:	85 e4       	ldi	r24, 0x45	; 69
    46a6:	97 e0       	ldi	r25, 0x07	; 7
    46a8:	0e 94 f8 07 	call	0xff0	; 0xff0 <EEPROM_read_DataBace>

	DIO_u8SetPinDirection(DIO_u8_PORTA,DIO_u8_PIN0,DIO_u8_INPUT_PULLED_UP);
    46ac:	80 e0       	ldi	r24, 0x00	; 0
    46ae:	60 e0       	ldi	r22, 0x00	; 0
    46b0:	42 e0       	ldi	r20, 0x02	; 2
    46b2:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <DIO_u8SetPinDirection>

	vSemaphoreCreateBinary(LCDSem);
    46b6:	81 e0       	ldi	r24, 0x01	; 1
    46b8:	60 e0       	ldi	r22, 0x00	; 0
    46ba:	43 e0       	ldi	r20, 0x03	; 3
    46bc:	0e 94 11 11 	call	0x2222	; 0x2222 <xQueueGenericCreate>
    46c0:	90 93 40 07 	sts	0x0740, r25
    46c4:	80 93 3f 07 	sts	0x073F, r24
    46c8:	00 97       	sbiw	r24, 0x00	; 0
    46ca:	39 f0       	breq	.+14     	; 0x46da <main+0x54>
    46cc:	60 e0       	ldi	r22, 0x00	; 0
    46ce:	70 e0       	ldi	r23, 0x00	; 0
    46d0:	40 e0       	ldi	r20, 0x00	; 0
    46d2:	50 e0       	ldi	r21, 0x00	; 0
    46d4:	20 e0       	ldi	r18, 0x00	; 0
    46d6:	0e 94 0c 10 	call	0x2018	; 0x2018 <xQueueGenericSend>
	CardSem = xSemaphoreCreateCounting(5,1);
    46da:	85 e0       	ldi	r24, 0x05	; 5
    46dc:	61 e0       	ldi	r22, 0x01	; 1
    46de:	0e 94 49 11 	call	0x2292	; 0x2292 <xQueueCreateCountingSemaphore>
    46e2:	90 93 42 07 	sts	0x0742, r25
    46e6:	80 93 41 07 	sts	0x0741, r24
	PassSem = xSemaphoreCreateCounting(5,1);
    46ea:	85 e0       	ldi	r24, 0x05	; 5
    46ec:	61 e0       	ldi	r22, 0x01	; 1
    46ee:	0e 94 49 11 	call	0x2292	; 0x2292 <xQueueCreateCountingSemaphore>
    46f2:	90 93 44 07 	sts	0x0744, r25
    46f6:	80 93 43 07 	sts	0x0743, r24


	ID_KPD_Message=xQueueCreate(1,sizeof(u16));
    46fa:	81 e0       	ldi	r24, 0x01	; 1
    46fc:	62 e0       	ldi	r22, 0x02	; 2
    46fe:	40 e0       	ldi	r20, 0x00	; 0
    4700:	0e 94 11 11 	call	0x2222	; 0x2222 <xQueueGenericCreate>
    4704:	90 93 70 07 	sts	0x0770, r25
    4708:	80 93 6f 07 	sts	0x076F, r24
	PASS_KPD_Message=xQueueCreate(1,sizeof(u16));
    470c:	81 e0       	ldi	r24, 0x01	; 1
    470e:	62 e0       	ldi	r22, 0x02	; 2
    4710:	40 e0       	ldi	r20, 0x00	; 0
    4712:	0e 94 11 11 	call	0x2222	; 0x2222 <xQueueGenericCreate>
    4716:	90 93 6e 07 	sts	0x076E, r25
    471a:	80 93 6d 07 	sts	0x076D, r24
	ID_Index_Message=xQueueCreate(1,sizeof(u8));
    471e:	81 e0       	ldi	r24, 0x01	; 1
    4720:	61 e0       	ldi	r22, 0x01	; 1
    4722:	40 e0       	ldi	r20, 0x00	; 0
    4724:	0e 94 11 11 	call	0x2222	; 0x2222 <xQueueGenericCreate>
    4728:	90 93 72 07 	sts	0x0772, r25
    472c:	80 93 71 07 	sts	0x0771, r24


	xTaskCreate(APP_VidWelcomeTask,NULL,150,NULL,5,NULL);
    4730:	87 ef       	ldi	r24, 0xF7	; 247
    4732:	92 e2       	ldi	r25, 0x22	; 34
    4734:	60 e0       	ldi	r22, 0x00	; 0
    4736:	70 e0       	ldi	r23, 0x00	; 0
    4738:	46 e9       	ldi	r20, 0x96	; 150
    473a:	50 e0       	ldi	r21, 0x00	; 0
    473c:	20 e0       	ldi	r18, 0x00	; 0
    473e:	30 e0       	ldi	r19, 0x00	; 0
    4740:	05 e0       	ldi	r16, 0x05	; 5
    4742:	ee 24       	eor	r14, r14
    4744:	ff 24       	eor	r15, r15
    4746:	0e 94 67 1f 	call	0x3ece	; 0x3ece <xTaskCreate>
	xTaskCreate(APP_VidGet_ID_From_Keypad,NULL,150,NULL,1,NULL);
    474a:	82 e6       	ldi	r24, 0x62	; 98
    474c:	92 e2       	ldi	r25, 0x22	; 34
    474e:	60 e0       	ldi	r22, 0x00	; 0
    4750:	70 e0       	ldi	r23, 0x00	; 0
    4752:	46 e9       	ldi	r20, 0x96	; 150
    4754:	50 e0       	ldi	r21, 0x00	; 0
    4756:	20 e0       	ldi	r18, 0x00	; 0
    4758:	30 e0       	ldi	r19, 0x00	; 0
    475a:	01 e0       	ldi	r16, 0x01	; 1
    475c:	0e 94 67 1f 	call	0x3ece	; 0x3ece <xTaskCreate>
	xTaskCreate(APP_VidCheckOnID,NULL,150,NULL,1,NULL);
    4760:	8c ee       	ldi	r24, 0xEC	; 236
    4762:	91 e2       	ldi	r25, 0x21	; 33
    4764:	60 e0       	ldi	r22, 0x00	; 0
    4766:	70 e0       	ldi	r23, 0x00	; 0
    4768:	46 e9       	ldi	r20, 0x96	; 150
    476a:	50 e0       	ldi	r21, 0x00	; 0
    476c:	20 e0       	ldi	r18, 0x00	; 0
    476e:	30 e0       	ldi	r19, 0x00	; 0
    4770:	0e 94 67 1f 	call	0x3ece	; 0x3ece <xTaskCreate>
	xTaskCreate(APP_VidGet_PASS_From_Keypad,NULL,150,NULL,1,NULL);
    4774:	87 e5       	ldi	r24, 0x57	; 87
    4776:	91 e2       	ldi	r25, 0x21	; 33
    4778:	60 e0       	ldi	r22, 0x00	; 0
    477a:	70 e0       	ldi	r23, 0x00	; 0
    477c:	46 e9       	ldi	r20, 0x96	; 150
    477e:	50 e0       	ldi	r21, 0x00	; 0
    4780:	20 e0       	ldi	r18, 0x00	; 0
    4782:	30 e0       	ldi	r19, 0x00	; 0
    4784:	0e 94 67 1f 	call	0x3ece	; 0x3ece <xTaskCreate>
	xTaskCreate(APP_VidCheckOnPASS,NULL,150,NULL,1,NULL);
    4788:	87 ee       	ldi	r24, 0xE7	; 231
    478a:	90 e2       	ldi	r25, 0x20	; 32
    478c:	60 e0       	ldi	r22, 0x00	; 0
    478e:	70 e0       	ldi	r23, 0x00	; 0
    4790:	46 e9       	ldi	r20, 0x96	; 150
    4792:	50 e0       	ldi	r21, 0x00	; 0
    4794:	20 e0       	ldi	r18, 0x00	; 0
    4796:	30 e0       	ldi	r19, 0x00	; 0
    4798:	0e 94 67 1f 	call	0x3ece	; 0x3ece <xTaskCreate>
	//xTaskCreate(APP_VidView_Menu,NULL,300,NULL,4,NULL);

	xSemaphoreTake(CardSem,10);
    479c:	80 91 41 07 	lds	r24, 0x0741
    47a0:	90 91 42 07 	lds	r25, 0x0742
    47a4:	6a e0       	ldi	r22, 0x0A	; 10
    47a6:	70 e0       	ldi	r23, 0x00	; 0
    47a8:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <xQueueSemaphoreTake>
	xSemaphoreTake(PassSem,10);
    47ac:	80 91 43 07 	lds	r24, 0x0743
    47b0:	90 91 44 07 	lds	r25, 0x0744
    47b4:	6a e0       	ldi	r22, 0x0A	; 10
    47b6:	70 e0       	ldi	r23, 0x00	; 0
    47b8:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <xQueueSemaphoreTake>
	//xSemaphoreTake(MenuSem,10);

	vTaskStartScheduler();
    47bc:	0e 94 99 20 	call	0x4132	; 0x4132 <vTaskStartScheduler>
    47c0:	ff cf       	rjmp	.-2      	; 0x47c0 <main+0x13a>

000047c2 <__udivmodhi4>:
    47c2:	aa 1b       	sub	r26, r26
    47c4:	bb 1b       	sub	r27, r27
    47c6:	51 e1       	ldi	r21, 0x11	; 17
    47c8:	07 c0       	rjmp	.+14     	; 0x47d8 <__udivmodhi4_ep>

000047ca <__udivmodhi4_loop>:
    47ca:	aa 1f       	adc	r26, r26
    47cc:	bb 1f       	adc	r27, r27
    47ce:	a6 17       	cp	r26, r22
    47d0:	b7 07       	cpc	r27, r23
    47d2:	10 f0       	brcs	.+4      	; 0x47d8 <__udivmodhi4_ep>
    47d4:	a6 1b       	sub	r26, r22
    47d6:	b7 0b       	sbc	r27, r23

000047d8 <__udivmodhi4_ep>:
    47d8:	88 1f       	adc	r24, r24
    47da:	99 1f       	adc	r25, r25
    47dc:	5a 95       	dec	r21
    47de:	a9 f7       	brne	.-22     	; 0x47ca <__udivmodhi4_loop>
    47e0:	80 95       	com	r24
    47e2:	90 95       	com	r25
    47e4:	bc 01       	movw	r22, r24
    47e6:	cd 01       	movw	r24, r26
    47e8:	08 95       	ret

000047ea <__udivmodsi4>:
    47ea:	a1 e2       	ldi	r26, 0x21	; 33
    47ec:	1a 2e       	mov	r1, r26
    47ee:	aa 1b       	sub	r26, r26
    47f0:	bb 1b       	sub	r27, r27
    47f2:	fd 01       	movw	r30, r26
    47f4:	0d c0       	rjmp	.+26     	; 0x4810 <__udivmodsi4_ep>

000047f6 <__udivmodsi4_loop>:
    47f6:	aa 1f       	adc	r26, r26
    47f8:	bb 1f       	adc	r27, r27
    47fa:	ee 1f       	adc	r30, r30
    47fc:	ff 1f       	adc	r31, r31
    47fe:	a2 17       	cp	r26, r18
    4800:	b3 07       	cpc	r27, r19
    4802:	e4 07       	cpc	r30, r20
    4804:	f5 07       	cpc	r31, r21
    4806:	20 f0       	brcs	.+8      	; 0x4810 <__udivmodsi4_ep>
    4808:	a2 1b       	sub	r26, r18
    480a:	b3 0b       	sbc	r27, r19
    480c:	e4 0b       	sbc	r30, r20
    480e:	f5 0b       	sbc	r31, r21

00004810 <__udivmodsi4_ep>:
    4810:	66 1f       	adc	r22, r22
    4812:	77 1f       	adc	r23, r23
    4814:	88 1f       	adc	r24, r24
    4816:	99 1f       	adc	r25, r25
    4818:	1a 94       	dec	r1
    481a:	69 f7       	brne	.-38     	; 0x47f6 <__udivmodsi4_loop>
    481c:	60 95       	com	r22
    481e:	70 95       	com	r23
    4820:	80 95       	com	r24
    4822:	90 95       	com	r25
    4824:	9b 01       	movw	r18, r22
    4826:	ac 01       	movw	r20, r24
    4828:	bd 01       	movw	r22, r26
    482a:	cf 01       	movw	r24, r30
    482c:	08 95       	ret

0000482e <memcpy>:
    482e:	fb 01       	movw	r30, r22
    4830:	dc 01       	movw	r26, r24
    4832:	02 c0       	rjmp	.+4      	; 0x4838 <memcpy+0xa>
    4834:	01 90       	ld	r0, Z+
    4836:	0d 92       	st	X+, r0
    4838:	41 50       	subi	r20, 0x01	; 1
    483a:	50 40       	sbci	r21, 0x00	; 0
    483c:	d8 f7       	brcc	.-10     	; 0x4834 <memcpy+0x6>
    483e:	08 95       	ret

00004840 <memset>:
    4840:	dc 01       	movw	r26, r24
    4842:	01 c0       	rjmp	.+2      	; 0x4846 <memset+0x6>
    4844:	6d 93       	st	X+, r22
    4846:	41 50       	subi	r20, 0x01	; 1
    4848:	50 40       	sbci	r21, 0x00	; 0
    484a:	e0 f7       	brcc	.-8      	; 0x4844 <memset+0x4>
    484c:	08 95       	ret

0000484e <_exit>:
    484e:	f8 94       	cli

00004850 <__stop_program>:
    4850:	ff cf       	rjmp	.-2      	; 0x4850 <__stop_program>
